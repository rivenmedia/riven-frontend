// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

/**
 * AddMediaItemPayload
 */
export const zAddMediaItemPayload = z.object({
    tmdb_ids: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    tvdb_ids: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    media_type: z.enum([
        'movie',
        'tv'
    ]).register(z.globalRegistry, {
        description: 'Media type'
    })
});

export type AddMediaItemPayloadZodType = z.infer<typeof zAddMediaItemPayload>;

/**
 * AllDebridModel
 */
export const zAllDebridModel = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable AllDebrid'
    })).default(false),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'AllDebrid API key'
    })).default('')
});

export type AllDebridModelZodType = z.infer<typeof zAllDebridModel>;

/**
 * LibraryProfileFilterRules
 * Filter rules for library profile matching (metadata-only)
 */
export const zLibraryProfileFilterRules = z.object({
    content_types: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    genres: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    exclude_genres: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    min_year: z.optional(z.union([
        z.int().gte(1900),
        z.null()
    ])),
    max_year: z.optional(z.union([
        z.int().gte(1900),
        z.null()
    ])),
    is_anime: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    networks: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    countries: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    languages: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    min_rating: z.optional(z.union([
        z.number().gte(0).lte(10),
        z.null()
    ])),
    max_rating: z.optional(z.union([
        z.number().gte(0).lte(10),
        z.null()
    ])),
    content_ratings: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Filter rules for library profile matching (metadata-only)'
});

export type LibraryProfileFilterRulesZodType = z.infer<typeof zLibraryProfileFilterRules>;

/**
 * LibraryProfile
 * Library profile configuration for organizing media into different libraries
 */
export const zLibraryProfile = z.object({
    name: z.string().register(z.globalRegistry, {
        description: 'Human-readable profile name'
    }),
    library_path: z.string().register(z.globalRegistry, {
        description: "VFS path prefix for this profile (e.g., '/kids', '/anime')"
    }),
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable this profile'
    })).default(true),
    filter_rules: z.optional(zLibraryProfileFilterRules)
}).register(z.globalRegistry, {
    description: 'Library profile configuration for organizing media into different libraries'
});

export type LibraryProfileZodType = z.infer<typeof zLibraryProfile>;

/**
 * FilesystemModel
 */
export const zFilesystemModel = z.object({
    mount_path: z.optional(z.string().register(z.globalRegistry, {
        description: 'Path where Riven will mount the virtual filesystem'
    })).default('/path/to/riven/mount'),
    library_profiles: z.optional(z.record(z.string(), zLibraryProfile).register(z.globalRegistry, {
        description: "Library profiles for organizing media into different libraries based on metadata. An example profile is provided (disabled by default) - enable them or create your own. Each profile filters media by metadata (genres, ratings, etc.) and creates VFS paths. Media appears in all matching profile paths. Use '!' prefix in filter lists to exclude values (e.g., genres: ['action', '!horror'] = action movies but not horror)."
    })),
    cache_dir: z.optional(z.string().register(z.globalRegistry, {
        description: 'Directory for caching downloaded chunks'
    })).default('/dev/shm/riven-cache'),
    cache_max_size_mb: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Maximum cache size in MB (10 GiB default)'
    })).default(10240),
    cache_ttl_seconds: z.optional(z.int().register(z.globalRegistry, {
        description: 'Cache time-to-live in seconds (2 hours default)'
    })).default(7200),
    cache_eviction: z.optional(z.enum([
        'LRU',
        'TTL'
    ]).register(z.globalRegistry, {
        description: 'Cache eviction policy (LRU or TTL)'
    })),
    cache_metrics: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable cache metrics logging'
    })).default(true),
    movie_dir_template: z.optional(z.string().register(z.globalRegistry, {
        description: "Template for movie directory names. Available variables: title, year, tmdb_id, imdb_id, resolution, codec, hdr, audio, quality, is_remux, is_proper, is_repack, is_extended, is_directors_cut, container. Example: '{title} ({year})' or '{title} ({year}) [{resolution}]'"
    })).default('{title} ({year}) {{tmdb-{tmdb_id}}}'),
    movie_file_template: z.optional(z.string().register(z.globalRegistry, {
        description: "Template for movie file names (without extension). Available variables: title, year, tmdb_id, imdb_id, resolution, codec, hdr, audio, quality, remux, proper, repack, extended, directors_cut, edition (string flags, empty if false). Example: '{title} ({year})' or '{title} ({year}) {edition} [{resolution}] {remux}'"
    })).default('{title} ({year})'),
    show_dir_template: z.optional(z.string().register(z.globalRegistry, {
        description: "Template for show directory names. Available variables: title, year, tvdb_id, imdb_id. Example: '{title} ({year})' or '{title} ({year}) {{tvdb-{tvdb_id}}}'"
    })).default('{title} ({year}) {{tvdb-{tvdb_id}}}'),
    season_dir_template: z.optional(z.string().register(z.globalRegistry, {
        description: "Template for season directory names. Available variables: season (number), show (parent show data with [title], [year], [tvdb_id], [imdb_id]). Example: 'Season {season:02d}' or 'S{season:02d}' or '{show[title]} - Season {season}'"
    })).default('Season {season:02d}'),
    episode_file_template: z.optional(z.string().register(z.globalRegistry, {
        description: "Template for episode file names (without extension). Available variables: title, season, episode, show (parent show data with [title], [year], [tvdb_id], [imdb_id]), resolution, codec, hdr, audio, quality, remux, proper, repack, extended, directors_cut, edition. Example: '{show[title]} - s{season:02d}e{episode:02d}' or 'S{season:02d}E{episode:02d} - {title}'. Multi-episode files automatically use range format (e.g., e01-05) based on episode number formatting."
    })).default('{show[title]} - s{season:02d}e{episode:02d}')
});

export type FilesystemModelZodType = z.infer<typeof zFilesystemModel>;

/**
 * PlexLibraryModel
 */
export const zPlexLibraryModel = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Plex library updates'
    })).default(false),
    token: z.optional(z.string().register(z.globalRegistry, {
        description: 'Plex authentication token'
    })).default(''),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Plex server URL'
    })).default('http://localhost:32400')
});

export type PlexLibraryModelZodType = z.infer<typeof zPlexLibraryModel>;

/**
 * JellyfinLibraryModel
 */
export const zJellyfinLibraryModel = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Jellyfin library updates'
    })).default(false),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Jellyfin API key'
    })).default(''),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Jellyfin server URL'
    })).default('http://localhost:8096')
});

export type JellyfinLibraryModelZodType = z.infer<typeof zJellyfinLibraryModel>;

/**
 * EmbyLibraryModel
 */
export const zEmbyLibraryModel = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Emby library updates'
    })).default(false),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Emby API key'
    })).default(''),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Emby server URL'
    })).default('http://localhost:8096')
});

export type EmbyLibraryModelZodType = z.infer<typeof zEmbyLibraryModel>;

/**
 * UpdatersModel
 */
export const zUpdatersModel = z.object({
    updater_interval: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Interval in seconds between library updates'
    })).default(120),
    library_path: z.optional(z.string().register(z.globalRegistry, {
        description: 'Path to which your media library mount point'
    })).default('/path/to/library/mount'),
    plex: z.optional(zPlexLibraryModel),
    jellyfin: z.optional(zJellyfinLibraryModel),
    emby: z.optional(zEmbyLibraryModel)
});

export type UpdatersModelZodType = z.infer<typeof zUpdatersModel>;

/**
 * RealDebridModel
 */
export const zRealDebridModel = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Real-Debrid'
    })).default(false),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Real-Debrid API key'
    })).default('')
});

export type RealDebridModelZodType = z.infer<typeof zRealDebridModel>;

/**
 * DebridLinkModel
 */
export const zDebridLinkModel = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Debrid-Link'
    })).default(false),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Debrid-Link API key'
    })).default('')
});

export type DebridLinkModelZodType = z.infer<typeof zDebridLinkModel>;

/**
 * DownloadersModel
 */
export const zDownloadersModel = z.object({
    video_extensions: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'list of video file extensions to consider for downloads'
    })),
    movie_filesize_mb_min: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Minimum file size in MB for movies'
    })).default(700),
    movie_filesize_mb_max: z.optional(z.int().gte(-1).register(z.globalRegistry, {
        description: 'Maximum file size in MB for movies (-1 for no limit)'
    })).default(-1),
    episode_filesize_mb_min: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Minimum file size in MB for episodes'
    })).default(100),
    episode_filesize_mb_max: z.optional(z.int().gte(-1).register(z.globalRegistry, {
        description: 'Maximum file size in MB for episodes (-1 for no limit)'
    })).default(-1),
    proxy_url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Proxy URL for downloaders (optional)'
    })).default(''),
    real_debrid: z.optional(zRealDebridModel),
    debrid_link: z.optional(zDebridLinkModel),
    all_debrid: z.optional(zAllDebridModel)
});

export type DownloadersModelZodType = z.infer<typeof zDownloadersModel>;

/**
 * OverseerrModel
 */
export const zOverseerrModel = z.object({
    update_interval: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Update interval in seconds'
    })).default(60),
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Overseerr integration'
    })).default(false),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Overseerr URL'
    })).default('http://localhost:5055'),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Overseerr API key'
    })).default(''),
    use_webhook: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Use webhook instead of polling'
    })).default(false)
});

export type OverseerrModelZodType = z.infer<typeof zOverseerrModel>;

/**
 * PlexWatchlistModel
 */
export const zPlexWatchlistModel = z.object({
    update_interval: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Update interval in seconds'
    })).default(60),
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Plex Watchlist integration'
    })).default(false),
    rss: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Plex Watchlist RSS feed URLs'
    }))
});

export type PlexWatchlistModelZodType = z.infer<typeof zPlexWatchlistModel>;

/**
 * MdblistModel
 */
export const zMdblistModel = z.object({
    update_interval: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Update interval in seconds (24 hours default)'
    })).default(86400),
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable MDBList integration'
    })).default(false),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'MDBList API key'
    })).default(''),
    lists: z.optional(z.array(z.union([
        z.int(),
        z.string()
    ])).register(z.globalRegistry, {
        description: 'MDBList list IDs to monitor'
    }))
});

export type MdblistModelZodType = z.infer<typeof zMdblistModel>;

/**
 * ListrrModel
 */
export const zListrrModel = z.object({
    update_interval: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Update interval in seconds (24 hours default)'
    })).default(86400),
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Listrr integration'
    })).default(false),
    movie_lists: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Listrr movie list IDs'
    })),
    show_lists: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Listrr TV show list IDs'
    })),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Listrr API key'
    })).default('')
});

export type ListrrModelZodType = z.infer<typeof zListrrModel>;

/**
 * TraktOauthModel
 */
export const zTraktOauthModel = z.object({
    oauth_client_id: z.optional(z.string().register(z.globalRegistry, {
        description: 'Trakt OAuth client ID'
    })).default(''),
    oauth_client_secret: z.optional(z.string().register(z.globalRegistry, {
        description: 'Trakt OAuth client secret'
    })).default(''),
    oauth_redirect_uri: z.optional(z.string().register(z.globalRegistry, {
        description: 'Trakt OAuth redirect URI'
    })).default(''),
    access_token: z.optional(z.string().register(z.globalRegistry, {
        description: 'Trakt OAuth access token'
    })).default(''),
    refresh_token: z.optional(z.string().register(z.globalRegistry, {
        description: 'Trakt OAuth refresh token'
    })).default('')
});

export type TraktOauthModelZodType = z.infer<typeof zTraktOauthModel>;

/**
 * TraktModel
 */
export const zTraktModel = z.object({
    update_interval: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Update interval in seconds (24 hours default)'
    })).default(86400),
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Trakt integration'
    })).default(false),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Trakt API key'
    })).default(''),
    watchlist: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Trakt usernames for watchlist monitoring'
    })),
    user_lists: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Trakt user list URLs to monitor'
    })),
    collection: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Trakt usernames for collection monitoring'
    })),
    fetch_trending: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Fetch trending content from Trakt'
    })).default(false),
    trending_count: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Number of trending items to fetch'
    })).default(10),
    fetch_popular: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Fetch popular content from Trakt'
    })).default(false),
    popular_count: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Number of popular items to fetch'
    })).default(10),
    fetch_most_watched: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Fetch most watched content from Trakt'
    })).default(false),
    most_watched_period: z.optional(z.string().register(z.globalRegistry, {
        description: 'Period for most watched (daily, weekly, monthly, yearly)'
    })).default('weekly'),
    most_watched_count: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Number of most watched items to fetch'
    })).default(10),
    oauth: z.optional(zTraktOauthModel),
    proxy_url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Proxy URL for Trakt API requests'
    })).default('')
});

export type TraktModelZodType = z.infer<typeof zTraktModel>;

/**
 * ContentModel
 */
export const zContentModel = z.object({
    overseerr: z.optional(zOverseerrModel),
    plex_watchlist: z.optional(zPlexWatchlistModel),
    mdblist: z.optional(zMdblistModel),
    listrr: z.optional(zListrrModel),
    trakt: z.optional(zTraktModel)
});

export type ContentModelZodType = z.infer<typeof zContentModel>;

/**
 * TorrentioConfig
 */
export const zTorrentioConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Torrentio scraper'
    })).default(false),
    filter: z.optional(z.string().register(z.globalRegistry, {
        description: 'Torrentio filter parameters'
    })).default('sort=qualitysize%7Cqualityfilter=480p,scr,cam'),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Torrentio URL'
    })).default('http://torrentio.strem.fun'),
    timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Request timeout in seconds'
    })).default(30),
    retries: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Number of retries for failed requests'
    })).default(1),
    ratelimit: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable rate limiting'
    })).default(true),
    proxy_url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Proxy URL for Torrentio requests'
    })).default('')
});

export type TorrentioConfigZodType = z.infer<typeof zTorrentioConfig>;

/**
 * JackettConfig
 */
export const zJackettConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Jackett scraper'
    })).default(false),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Jackett URL'
    })).default('http://localhost:9117'),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Jackett API key'
    })).default(''),
    timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Request timeout in seconds'
    })).default(30),
    retries: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Number of retries for failed requests'
    })).default(1),
    infohash_fetch_timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Timeout in seconds for parallel infohash fetching from URLs'
    })).default(30),
    ratelimit: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable rate limiting'
    })).default(true)
});

export type JackettConfigZodType = z.infer<typeof zJackettConfig>;

/**
 * ProwlarrConfig
 */
export const zProwlarrConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Prowlarr scraper'
    })).default(false),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Prowlarr URL'
    })).default('http://localhost:9696'),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Prowlarr API key'
    })).default(''),
    timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Request timeout in seconds'
    })).default(30),
    retries: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Number of retries for failed requests'
    })).default(1),
    infohash_fetch_timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Timeout in seconds for parallel infohash fetching from URLs'
    })).default(30),
    ratelimit: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable rate limiting'
    })).default(true),
    limiter_seconds: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Rate limiter cooldown in seconds'
    })).default(60)
});

export type ProwlarrConfigZodType = z.infer<typeof zProwlarrConfig>;

/**
 * OrionoidConfigParametersDict
 */
export const zOrionoidConfigParametersDict = z.object({
    video3d: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Include 3D video results'
    })).default(false),
    videoquality: z.optional(z.string().register(z.globalRegistry, {
        description: 'Video quality filter'
    })).default('sd_hd8k'),
    limitcount: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Maximum number of results'
    })).default(5)
});

export type OrionoidConfigParametersDictZodType = z.infer<typeof zOrionoidConfigParametersDict>;

/**
 * OrionoidConfig
 */
export const zOrionoidConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Orionoid scraper'
    })).default(false),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Orionoid API key'
    })).default(''),
    cached_results_only: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Only return cached/downloadable results'
    })).default(false),
    parameters: z.optional(zOrionoidConfigParametersDict),
    timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Request timeout in seconds'
    })).default(30),
    retries: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Number of retries for failed requests'
    })).default(1),
    ratelimit: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable rate limiting'
    })).default(true)
});

export type OrionoidConfigZodType = z.infer<typeof zOrionoidConfig>;

/**
 * MediafusionConfig
 */
export const zMediafusionConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Mediafusion scraper'
    })).default(false),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Mediafusion URL'
    })).default('http://localhost:8000'),
    timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Request timeout in seconds'
    })).default(30),
    retries: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Number of retries for failed requests'
    })).default(1),
    ratelimit: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable rate limiting'
    })).default(true)
});

export type MediafusionConfigZodType = z.infer<typeof zMediafusionConfig>;

/**
 * ZileanConfig
 */
export const zZileanConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Zilean scraper'
    })).default(false),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Zilean URL'
    })).default('http://localhost:8181'),
    timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Request timeout in seconds'
    })).default(30),
    retries: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Number of retries for failed requests'
    })).default(1),
    ratelimit: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable rate limiting'
    })).default(true)
});

export type ZileanConfigZodType = z.infer<typeof zZileanConfig>;

/**
 * CometConfig
 */
export const zCometConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Comet scraper'
    })).default(false),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Comet URL'
    })).default('http://localhost:8000'),
    timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Request timeout in seconds'
    })).default(30),
    retries: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Number of retries for failed requests'
    })).default(1),
    ratelimit: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable rate limiting'
    })).default(true)
});

export type CometConfigZodType = z.infer<typeof zCometConfig>;

/**
 * RarbgConfig
 */
export const zRarbgConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable RARBG scraper'
    })).default(false),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'RARBG URL'
    })).default('https://therarbg.to'),
    timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Request timeout in seconds'
    })).default(30),
    retries: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Number of retries for failed requests'
    })).default(1),
    ratelimit: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable rate limiting'
    })).default(true)
});

export type RarbgConfigZodType = z.infer<typeof zRarbgConfig>;

/**
 * ScraperModel
 */
export const zScraperModel = z.object({
    after_2: z.optional(z.number().register(z.globalRegistry, {
        description: 'Hours to wait after 2 failed scrapes'
    })).default(2),
    after_5: z.optional(z.number().register(z.globalRegistry, {
        description: 'Hours to wait after 5 failed scrapes'
    })).default(6),
    after_10: z.optional(z.number().register(z.globalRegistry, {
        description: 'Hours to wait after 10 failed scrapes'
    })).default(24),
    enable_aliases: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable title aliases for better matching'
    })).default(true),
    bucket_limit: z.optional(z.int().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Maximum results per quality bucket'
    })).default(5),
    max_failed_attempts: z.optional(z.int().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Maximum failed scrape attempts before giving up'
    })).default(0),
    dubbed_anime_only: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Only scrape dubbed anime content'
    })).default(false),
    torrentio: z.optional(zTorrentioConfig),
    jackett: z.optional(zJackettConfig),
    prowlarr: z.optional(zProwlarrConfig),
    orionoid: z.optional(zOrionoidConfig),
    mediafusion: z.optional(zMediafusionConfig),
    zilean: z.optional(zZileanConfig),
    comet: z.optional(zCometConfig),
    rarbg: z.optional(zRarbgConfig)
});

export type ScraperModelZodType = z.infer<typeof zScraperModel>;

/**
 * ResolutionConfig
 * Configuration for which resolutions are enabled.
 */
export const zResolutionConfig = z.object({
    r2160p: z.optional(z.boolean()).default(false),
    r1080p: z.optional(z.boolean()).default(true),
    r720p: z.optional(z.boolean()).default(true),
    r480p: z.optional(z.boolean()).default(false),
    r360p: z.optional(z.boolean()).default(false),
    unknown: z.optional(z.boolean()).default(true)
}).register(z.globalRegistry, {
    description: 'Configuration for which resolutions are enabled.'
});

export type ResolutionConfigZodType = z.infer<typeof zResolutionConfig>;

/**
 * OptionsConfig
 * Configuration for various options.
 */
export const zOptionsConfig = z.object({
    title_similarity: z.optional(z.number()).default(0.85),
    remove_all_trash: z.optional(z.boolean()).default(true),
    remove_ranks_under: z.optional(z.int()).default(-10000),
    remove_unknown_languages: z.optional(z.boolean()).default(false),
    allow_english_in_languages: z.optional(z.boolean()).default(true),
    enable_fetch_speed_mode: z.optional(z.boolean()).default(true),
    remove_adult_content: z.optional(z.boolean()).default(true)
}).register(z.globalRegistry, {
    description: 'Configuration for various options.'
});

export type OptionsConfigZodType = z.infer<typeof zOptionsConfig>;

/**
 * LanguagesConfig
 * Configuration for which languages are enabled.
 */
export const zLanguagesConfig = z.object({
    required: z.optional(z.array(z.string())).default([]),
    exclude: z.optional(z.array(z.string())).default([]),
    preferred: z.optional(z.array(z.string())).default([])
}).register(z.globalRegistry, {
    description: 'Configuration for which languages are enabled.'
});

export type LanguagesConfigZodType = z.infer<typeof zLanguagesConfig>;

/**
 * CustomRank
 * Custom Ranks used in SettingsModel.
 */
export const zCustomRank = z.object({
    fetch: z.optional(z.boolean()).default(true),
    use_custom_rank: z.optional(z.boolean()).default(false),
    rank: z.optional(z.int()).default(0)
}).register(z.globalRegistry, {
    description: 'Custom Ranks used in SettingsModel.'
});

export type CustomRankZodType = z.infer<typeof zCustomRank>;

/**
 * QualityRankModel
 * Ranking configuration for quality attributes.
 */
export const zQualityRankModel = z.object({
    av1: z.optional(zCustomRank),
    avc: z.optional(zCustomRank),
    bluray: z.optional(zCustomRank),
    dvd: z.optional(zCustomRank),
    hdtv: z.optional(zCustomRank),
    hevc: z.optional(zCustomRank),
    mpeg: z.optional(zCustomRank),
    remux: z.optional(zCustomRank),
    vhs: z.optional(zCustomRank),
    web: z.optional(zCustomRank),
    webdl: z.optional(zCustomRank),
    webmux: z.optional(zCustomRank),
    xvid: z.optional(zCustomRank)
}).register(z.globalRegistry, {
    description: 'Ranking configuration for quality attributes.'
});

export type QualityRankModelZodType = z.infer<typeof zQualityRankModel>;

/**
 * RipsRankModel
 * Ranking configuration for rips attributes.
 */
export const zRipsRankModel = z.object({
    bdrip: z.optional(zCustomRank),
    brrip: z.optional(zCustomRank),
    dvdrip: z.optional(zCustomRank),
    hdrip: z.optional(zCustomRank),
    ppvrip: z.optional(zCustomRank),
    satrip: z.optional(zCustomRank),
    tvrip: z.optional(zCustomRank),
    uhdrip: z.optional(zCustomRank),
    vhsrip: z.optional(zCustomRank),
    webdlrip: z.optional(zCustomRank),
    webrip: z.optional(zCustomRank)
}).register(z.globalRegistry, {
    description: 'Ranking configuration for rips attributes.'
});

export type RipsRankModelZodType = z.infer<typeof zRipsRankModel>;

/**
 * HdrRankModel
 * Ranking configuration for HDR attributes.
 */
export const zHdrRankModel = z.object({
    bit10: z.optional(zCustomRank),
    dolby_vision: z.optional(zCustomRank),
    hdr: z.optional(zCustomRank),
    hdr10plus: z.optional(zCustomRank),
    sdr: z.optional(zCustomRank)
}).register(z.globalRegistry, {
    description: 'Ranking configuration for HDR attributes.'
});

export type HdrRankModelZodType = z.infer<typeof zHdrRankModel>;

/**
 * AudioRankModel
 * Ranking configuration for audio attributes.
 */
export const zAudioRankModel = z.object({
    aac: z.optional(zCustomRank),
    atmos: z.optional(zCustomRank),
    dolby_digital: z.optional(zCustomRank),
    dolby_digital_plus: z.optional(zCustomRank),
    dts_lossy: z.optional(zCustomRank),
    dts_lossless: z.optional(zCustomRank),
    flac: z.optional(zCustomRank),
    mono: z.optional(zCustomRank),
    mp3: z.optional(zCustomRank),
    stereo: z.optional(zCustomRank),
    surround: z.optional(zCustomRank),
    truehd: z.optional(zCustomRank)
}).register(z.globalRegistry, {
    description: 'Ranking configuration for audio attributes.'
});

export type AudioRankModelZodType = z.infer<typeof zAudioRankModel>;

/**
 * ExtrasRankModel
 * Ranking configuration for extras attributes.
 */
export const zExtrasRankModel = z.object({
    '3d': z.optional(zCustomRank),
    converted: z.optional(zCustomRank),
    documentary: z.optional(zCustomRank),
    dubbed: z.optional(zCustomRank),
    edition: z.optional(zCustomRank),
    hardcoded: z.optional(zCustomRank),
    network: z.optional(zCustomRank),
    proper: z.optional(zCustomRank),
    repack: z.optional(zCustomRank),
    retail: z.optional(zCustomRank),
    site: z.optional(zCustomRank),
    subbed: z.optional(zCustomRank),
    upscaled: z.optional(zCustomRank),
    scene: z.optional(zCustomRank),
    uncensored: z.optional(zCustomRank)
}).register(z.globalRegistry, {
    description: 'Ranking configuration for extras attributes.'
});

export type ExtrasRankModelZodType = z.infer<typeof zExtrasRankModel>;

/**
 * TrashRankModel
 * Ranking configuration for trash attributes.
 */
export const zTrashRankModel = z.object({
    cam: z.optional(zCustomRank),
    clean_audio: z.optional(zCustomRank),
    pdtv: z.optional(zCustomRank),
    r5: z.optional(zCustomRank),
    screener: z.optional(zCustomRank),
    size: z.optional(zCustomRank),
    telecine: z.optional(zCustomRank),
    telesync: z.optional(zCustomRank)
}).register(z.globalRegistry, {
    description: 'Ranking configuration for trash attributes.'
});

export type TrashRankModelZodType = z.infer<typeof zTrashRankModel>;

/**
 * CustomRanksConfig
 * Configuration for custom ranks.
 */
export const zCustomRanksConfig = z.object({
    quality: z.optional(zQualityRankModel),
    rips: z.optional(zRipsRankModel),
    hdr: z.optional(zHdrRankModel),
    audio: z.optional(zAudioRankModel),
    extras: z.optional(zExtrasRankModel),
    trash: z.optional(zTrashRankModel)
}).register(z.globalRegistry, {
    description: 'Configuration for custom ranks.'
});

export type CustomRanksConfigZodType = z.infer<typeof zCustomRanksConfig>;

/**
 * RTNSettingsModel
 */
export const zRtnSettingsModel = z.object({
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'Name of the settings'
    })).default('example'),
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether these settings will be used or not'
    })).default(true),
    require: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Patterns torrents must match to be considered'
    })),
    exclude: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Patterns that, if matched, result in torrent exclusion'
    })),
    preferred: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Patterns indicating preferred attributes in torrents'
    })),
    resolutions: z.optional(zResolutionConfig),
    options: z.optional(zOptionsConfig),
    languages: z.optional(zLanguagesConfig),
    custom_ranks: z.optional(zCustomRanksConfig)
});

export type RtnSettingsModelZodType = z.infer<typeof zRtnSettingsModel>;

/**
 * IndexerModel
 */
export const zIndexerModel = z.object({
    schedule_offset_minutes: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Offset in minutes after aired_at time to schedule scraping for episodes and movies (30 minutes default)'
    })).default(30)
});

export type IndexerModelZodType = z.infer<typeof zIndexerModel>;

/**
 * DatabaseModel
 */
export const zDatabaseModel = z.object({
    host: z.optional(z.string().min(1).register(z.globalRegistry, {
        description: 'Database connection string'
    }))
});

export type DatabaseModelZodType = z.infer<typeof zDatabaseModel>;

/**
 * NotificationsModel
 */
export const zNotificationsModel = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable notifications'
    })).default(false),
    on_item_type: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Item types to send notifications for'
    })),
    service_urls: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Notification service URLs (e.g., Discord webhooks)'
    }))
});

export type NotificationsModelZodType = z.infer<typeof zNotificationsModel>;

/**
 * SubtitleProviderConfig
 */
export const zSubtitleProviderConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable this subtitle provider'
    })).default(false)
});

export type SubtitleProviderConfigZodType = z.infer<typeof zSubtitleProviderConfig>;

/**
 * SubtitleProvidersDict
 */
export const zSubtitleProvidersDict = z.object({
    opensubtitles: z.optional(zSubtitleProviderConfig)
});

export type SubtitleProvidersDictZodType = z.infer<typeof zSubtitleProvidersDict>;

/**
 * SubtitleConfig
 */
export const zSubtitleConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable subtitle downloading'
    })).default(false),
    languages: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Subtitle languages to download (ISO 639-2 codes)'
    })),
    providers: z.optional(zSubtitleProvidersDict)
});

export type SubtitleConfigZodType = z.infer<typeof zSubtitleConfig>;

/**
 * PostProcessing
 */
export const zPostProcessing = z.object({
    subtitle: z.optional(zSubtitleConfig)
});

export type PostProcessingZodType = z.infer<typeof zPostProcessing>;

/**
 * LoggingModel
 */
export const zLoggingModel = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable file logging'
    })).default(true),
    clean_interval: z.optional(z.int().register(z.globalRegistry, {
        description: 'Log cleanup interval in seconds (1 hour default)'
    })).default(3600),
    retention_hours: z.optional(z.int().register(z.globalRegistry, {
        description: 'Log retention period in hours'
    })).default(24),
    rotation_mb: z.optional(z.int().register(z.globalRegistry, {
        description: 'Log file rotation size in MB'
    })).default(10),
    compression: z.optional(z.enum([
        'zip',
        'gz',
        'bz2',
        'xz',
        'disabled'
    ]).register(z.globalRegistry, {
        description: 'Log compression format (empty for no compression)'
    }))
});

export type LoggingModelZodType = z.infer<typeof zLoggingModel>;

/**
 * StreamModel
 */
export const zStreamModel = z.object({
    chunk_size_mb: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Chunk size in MB for streaming downloads (1 MB default). Note: Smaller chunks are generally more efficient, as the entire chunk must be downloaded before it can be read.'
    })).default(1),
    connect_timeout_seconds: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Timeout in seconds for establishing a connection to the streaming service (10 seconds default)'
    })).default(10),
    chunk_wait_timeout_seconds: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Timeout in seconds for reading a chunk during streaming (10 seconds default)'
    })).default(10),
    activity_timeout_seconds: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Timeout in seconds before a stream is considered inactive during resource cleanup (60 seconds default)'
    })).default(60)
});

export type StreamModelZodType = z.infer<typeof zStreamModel>;

/**
 * AppModel
 */
export const zAppModel = z.object({
    version: z.optional(z.string().register(z.globalRegistry, {
        description: 'Application version'
    })),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'API key for Riven API access'
    })).default(''),
    log_level: z.optional(z.enum([
        'TRACE',
        'DEBUG',
        'INFO',
        'WARNING',
        'ERROR',
        'CRITICAL'
    ]).register(z.globalRegistry, {
        description: 'Logging level'
    })),
    enable_network_tracing: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable detailed network request/response logging'
    })).default(false),
    enable_stream_tracing: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable detailed stream request/response logging'
    })).default(false),
    retry_interval: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Interval in seconds to retry failed library items (24 hours default, 0 to disable)'
    })).default(86400),
    tracemalloc: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Python memory tracking (debug)'
    })).default(false),
    filesystem: z.optional(zFilesystemModel),
    updaters: z.optional(zUpdatersModel),
    downloaders: z.optional(zDownloadersModel),
    content: z.optional(zContentModel),
    scraping: z.optional(zScraperModel),
    ranking: z.optional(zRtnSettingsModel),
    indexer: z.optional(zIndexerModel),
    database: z.optional(zDatabaseModel),
    notifications: z.optional(zNotificationsModel),
    post_processing: z.optional(zPostProcessing),
    logging: z.optional(zLoggingModel),
    stream: z.optional(zStreamModel)
});

export type AppModelZodType = z.infer<typeof zAppModel>;

/**
 * AudioMetadata
 * Audio track metadata
 */
export const zAudioMetadata = z.object({
    codec: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    channels: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    sample_rate: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    language: z.optional(z.union([
        z.string(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Audio track metadata'
});

export type AudioMetadataZodType = z.infer<typeof zAudioMetadata>;

/**
 * CalendarResponse
 */
export const zCalendarResponse = z.object({
    data: z.record(z.string(), z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: 'Dictionary with dates as keys and lists of media items as values'
    })
});

export type CalendarResponseZodType = z.infer<typeof zCalendarResponse>;

/**
 * DebridFile
 * Represents a file from a debrid service
 */
export const zDebridFile = z.object({
    file_id: z.union([
        z.int(),
        z.null()
    ]),
    filename: z.string(),
    filesize: z.int(),
    download_url: z.optional(z.union([
        z.string(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Represents a file from a debrid service'
});

export type DebridFileZodType = z.infer<typeof zDebridFile>;

/**
 * Container
 * Root model for container mapping file IDs to file information.
 *
 * Example:
 * {
 * "4": {
 * "filename": "show.s01e01.mkv",
 * "filesize": 30791392598
 * },
 * "5": {
 * "filename": "show.s01e02.mkv",
 * "filesize": 25573181861
 * }
 * }
 */
export const zContainer = z.record(z.string(), zDebridFile).register(z.globalRegistry, {
    description: 'Root model for container mapping file IDs to file information.\n\nExample:\n{\n    "4": {\n        "filename": "show.s01e01.mkv",\n        "filesize": 30791392598\n    },\n    "5": {\n        "filename": "show.s01e02.mkv",\n        "filesize": 25573181861\n    }\n}'
});

export type ContainerZodType = z.infer<typeof zContainer>;

/**
 * DataSource
 * Source of metadata
 */
export const zDataSource = z.enum([
    'parsed',
    'probed',
    'hybrid'
]).register(z.globalRegistry, {
    description: 'Source of metadata'
});

export type DataSourceZodType = z.infer<typeof zDataSource>;

/**
 * DownloaderUserInfo
 * Normalized downloader user information response
 */
export const zDownloaderUserInfo = z.object({
    service: z.enum([
        'realdebrid',
        'alldebrid',
        'debridlink'
    ]),
    username: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    email: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    user_id: z.union([
        z.int(),
        z.string()
    ]),
    premium_status: z.enum([
        'free',
        'premium'
    ]),
    premium_expires_at: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    premium_days_left: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    points: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    total_downloaded_bytes: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    cooldown_until: z.optional(z.union([
        z.string(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Normalized downloader user information response'
});

export type DownloaderUserInfoZodType = z.infer<typeof zDownloaderUserInfo>;

/**
 * DownloaderUserInfoResponse
 * Response containing user info for all initialized downloader services
 */
export const zDownloaderUserInfoResponse = z.object({
    services: z.array(zDownloaderUserInfo)
}).register(z.globalRegistry, {
    description: 'Response containing user info for all initialized downloader services'
});

export type DownloaderUserInfoResponseZodType = z.infer<typeof zDownloaderUserInfoResponse>;

/**
 * EventResponse
 */
export const zEventResponse = z.object({
    events: z.record(z.string(), z.array(z.int()))
});

export type EventResponseZodType = z.infer<typeof zEventResponse>;

/**
 * EventTypesResponse
 */
export const zEventTypesResponse = z.object({
    event_types: z.array(z.string())
});

export type EventTypesResponseZodType = z.infer<typeof zEventTypesResponse>;

/**
 * ValidationError
 */
export const zValidationError = z.object({
    loc: z.array(z.union([
        z.string(),
        z.int()
    ])),
    msg: z.string(),
    type: z.string()
});

export type ValidationErrorZodType = z.infer<typeof zValidationError>;

/**
 * HTTPValidationError
 */
export const zHttpValidationError = z.object({
    detail: z.optional(z.array(zValidationError))
});

export type HttpValidationErrorZodType = z.infer<typeof zHttpValidationError>;

/**
 * IdListPayload
 */
export const zIdListPayload = z.object({
    ids: z.array(z.string()).min(1).register(z.globalRegistry, {
        description: 'List of IDs'
    })
});

export type IdListPayloadZodType = z.infer<typeof zIdListPayload>;

/**
 * ItemAliasesResponse
 */
export const zItemAliasesResponse = z.object({
    aliases: z.union([
        z.record(z.string(), z.array(z.string())),
        z.null()
    ])
});

export type ItemAliasesResponseZodType = z.infer<typeof zItemAliasesResponse>;

/**
 * ItemsResponse
 */
export const zItemsResponse = z.object({
    success: z.boolean().register(z.globalRegistry, {
        description: 'Boolean signifying whether the request was successful'
    }),
    items: z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: 'The list of media items'
    }),
    page: z.int().register(z.globalRegistry, {
        description: 'Current page number'
    }),
    limit: z.int().register(z.globalRegistry, {
        description: 'Number of items per page'
    }),
    total_items: z.int().register(z.globalRegistry, {
        description: 'Total number of items'
    }),
    total_pages: z.int().register(z.globalRegistry, {
        description: 'Total number of pages'
    })
});

export type ItemsResponseZodType = z.infer<typeof zItemsResponse>;

/**
 * LogsResponse
 */
export const zLogsResponse = z.object({
    logs: z.array(z.string())
});

export type LogsResponseZodType = z.infer<typeof zLogsResponse>;

/**
 * VideoMetadata
 * Video track metadata
 */
export const zVideoMetadata = z.object({
    codec: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    resolution_width: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    resolution_height: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    frame_rate: z.optional(z.union([
        z.number(),
        z.null()
    ])),
    bit_depth: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    hdr_type: z.optional(z.union([
        z.string(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Video track metadata'
});

export type VideoMetadataZodType = z.infer<typeof zVideoMetadata>;

/**
 * SubtitleMetadata
 * Subtitle track metadata
 */
export const zSubtitleMetadata = z.object({
    codec: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    language: z.optional(z.union([
        z.string(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Subtitle track metadata'
});

export type SubtitleMetadataZodType = z.infer<typeof zSubtitleMetadata>;

/**
 * MediaMetadata
 * Unified media metadata model combining parsed and probed data.
 *
 * This model consolidates filename-parsed data (RTN) and file-probed data (ffprobe)
 * into a single, coherent structure. When both sources provide the same attribute,
 * probed data takes precedence as the source of truth.
 *
 * Attributes:
 * filename: Original filename
 * parsed_title: Clean title extracted from filename
 * year: Release year
 * video: Video track metadata (codec, resolution, HDR, etc.)
 * audio_tracks: list of audio tracks with codec, channels, language
 * subtitle_tracks: list of subtitle tracks with codec, language
 * duration: Duration in seconds (probed only)
 * file_size: File size in bytes (probed only)
 * bitrate: Overall bitrate in bits/sec (probed only)
 * container_format: Container format(s) (probed only)
 * quality_source: Source quality (BluRay, WEB-DL, etc.) (parsed only)
 * is_remux: Whether this is a remux release (parsed only)
 * is_proper: Whether this is a proper release (parsed only)
 * is_repack: Whether this is a repack release (parsed only)
 * is_remastered: Whether this is remastered (parsed only)
 * is_upscaled: Whether this is upscaled (parsed only)
 * is_directors_cut: Whether this is director's cut (parsed only)
 * is_extended: Whether this is extended edition (parsed only)
 * seasons: Season numbers (for shows) (parsed only)
 * episodes: Episode numbers (for shows) (parsed only)
 * data_source: Source of the metadata (parsed, probed, or hybrid)
 * parsed_at: ISO timestamp when filename was parsed
 * probed_at: ISO timestamp when file was probed
 */
export const zMediaMetadata = z.object({
    filename: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    parsed_title: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    year: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    video: z.optional(z.union([
        zVideoMetadata,
        z.null()
    ])),
    audio_tracks: z.optional(z.array(zAudioMetadata)),
    subtitle_tracks: z.optional(z.array(zSubtitleMetadata)),
    duration: z.optional(z.union([
        z.number(),
        z.null()
    ])),
    file_size: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    bitrate: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    container_formats: z.optional(z.array(z.string())),
    quality_source: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    is_remux: z.optional(z.boolean()).default(false),
    is_proper: z.optional(z.boolean()).default(false),
    is_repack: z.optional(z.boolean()).default(false),
    is_remastered: z.optional(z.boolean()).default(false),
    is_upscaled: z.optional(z.boolean()).default(false),
    is_directors_cut: z.optional(z.boolean()).default(false),
    is_extended: z.optional(z.boolean()).default(false),
    seasons: z.optional(z.array(z.int())),
    episodes: z.optional(z.array(z.int())),
    data_source: z.optional(zDataSource),
    parsed_at: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    probed_at: z.optional(z.union([
        z.string(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: "Unified media metadata model combining parsed and probed data.\n\nThis model consolidates filename-parsed data (RTN) and file-probed data (ffprobe)\ninto a single, coherent structure. When both sources provide the same attribute,\nprobed data takes precedence as the source of truth.\n\nAttributes:\n    filename: Original filename\n    parsed_title: Clean title extracted from filename\n    year: Release year\n    video: Video track metadata (codec, resolution, HDR, etc.)\n    audio_tracks: list of audio tracks with codec, channels, language\n    subtitle_tracks: list of subtitle tracks with codec, language\n    duration: Duration in seconds (probed only)\n    file_size: File size in bytes (probed only)\n    bitrate: Overall bitrate in bits/sec (probed only)\n    container_format: Container format(s) (probed only)\n    quality_source: Source quality (BluRay, WEB-DL, etc.) (parsed only)\n    is_remux: Whether this is a remux release (parsed only)\n    is_proper: Whether this is a proper release (parsed only)\n    is_repack: Whether this is a repack release (parsed only)\n    is_remastered: Whether this is remastered (parsed only)\n    is_upscaled: Whether this is upscaled (parsed only)\n    is_directors_cut: Whether this is director's cut (parsed only)\n    is_extended: Whether this is extended edition (parsed only)\n    seasons: Season numbers (for shows) (parsed only)\n    episodes: Episode numbers (for shows) (parsed only)\n    data_source: Source of the metadata (parsed, probed, or hybrid)\n    parsed_at: ISO timestamp when filename was parsed\n    probed_at: ISO timestamp when file was probed"
});

export type MediaMetadataZodType = z.infer<typeof zMediaMetadata>;

/**
 * MediaTypeEnum
 */
export const zMediaTypeEnum = z.enum([
    'movie',
    'show',
    'season',
    'episode',
    'anime'
]);

export type MediaTypeEnumZodType = z.infer<typeof zMediaTypeEnum>;

/**
 * MessageResponse
 */
export const zMessageResponse = z.object({
    message: z.string()
});

export type MessageResponseZodType = z.infer<typeof zMessageResponse>;

/**
 * MountResponse
 */
export const zMountResponse = z.object({
    files: z.record(z.string(), z.string())
});

export type MountResponseZodType = z.infer<typeof zMountResponse>;

/**
 * OverseerrWebhookResponse
 */
export const zOverseerrWebhookResponse = z.object({
    success: z.boolean(),
    message: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

export type OverseerrWebhookResponseZodType = z.infer<typeof zOverseerrWebhookResponse>;

/**
 * ParseTorrentTitleResponse
 */
export const zParseTorrentTitleResponse = z.object({
    message: z.string(),
    data: z.array(z.record(z.string(), z.unknown()))
});

export type ParseTorrentTitleResponseZodType = z.infer<typeof zParseTorrentTitleResponse>;

/**
 * ParsedData
 * Parsed data model for a torrent title.
 */
export const zParsedData = z.object({
    raw_title: z.string(),
    parsed_title: z.optional(z.string()).default(''),
    normalized_title: z.optional(z.string()).default(''),
    trash: z.optional(z.boolean()).default(false),
    adult: z.optional(z.boolean()).default(false),
    year: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    resolution: z.optional(z.string()).default('unknown'),
    seasons: z.optional(z.array(z.int())).default([]),
    episodes: z.optional(z.array(z.int())).default([]),
    complete: z.optional(z.boolean()).default(false),
    volumes: z.optional(z.array(z.int())).default([]),
    languages: z.optional(z.array(z.string())).default([]),
    quality: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    hdr: z.optional(z.array(z.string())).default([]),
    codec: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    audio: z.optional(z.array(z.string())).default([]),
    channels: z.optional(z.array(z.string())).default([]),
    dubbed: z.optional(z.boolean()).default(false),
    subbed: z.optional(z.boolean()).default(false),
    date: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    group: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    edition: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    bit_depth: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    bitrate: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    network: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    extended: z.optional(z.boolean()).default(false),
    converted: z.optional(z.boolean()).default(false),
    hardcoded: z.optional(z.boolean()).default(false),
    region: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    ppv: z.optional(z.boolean()).default(false),
    site: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    size: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    proper: z.optional(z.boolean()).default(false),
    repack: z.optional(z.boolean()).default(false),
    retail: z.optional(z.boolean()).default(false),
    upscaled: z.optional(z.boolean()).default(false),
    remastered: z.optional(z.boolean()).default(false),
    unrated: z.optional(z.boolean()).default(false),
    uncensored: z.optional(z.boolean()).default(false),
    documentary: z.optional(z.boolean()).default(false),
    commentary: z.optional(z.boolean()).default(false),
    episode_code: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    country: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    container: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    extension: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    extras: z.optional(z.array(z.string())).default([]),
    torrent: z.optional(z.boolean()).default(false),
    scene: z.optional(z.boolean()).default(false)
}).register(z.globalRegistry, {
    description: 'Parsed data model for a torrent title.'
});

export type ParsedDataZodType = z.infer<typeof zParsedData>;

/**
 * PauseResponse
 */
export const zPauseResponse = z.object({
    message: z.string(),
    ids: z.array(z.int()).min(1).register(z.globalRegistry, {
        description: 'The IDs to pause'
    })
});

export type PauseResponseZodType = z.infer<typeof zPauseResponse>;

/**
 * ReindexPayload
 */
export const zReindexPayload = z.object({
    item_id: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    tvdb_id: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    tmdb_id: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    imdb_id: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

export type ReindexPayloadZodType = z.infer<typeof zReindexPayload>;

/**
 * RemoveResponse
 */
export const zRemoveResponse = z.object({
    message: z.string(),
    ids: z.array(z.int()).register(z.globalRegistry, {
        description: 'The IDs to remove'
    })
});

export type RemoveResponseZodType = z.infer<typeof zRemoveResponse>;

/**
 * ResetResponse
 */
export const zResetResponse = z.object({
    message: z.string(),
    ids: z.array(z.int())
});

export type ResetResponseZodType = z.infer<typeof zResetResponse>;

/**
 * RetryResponse
 */
export const zRetryResponse = z.object({
    message: z.string(),
    ids: z.array(z.int()).min(1).register(z.globalRegistry, {
        description: 'The IDs to retry'
    })
});

export type RetryResponseZodType = z.infer<typeof zRetryResponse>;

/**
 * RootResponse
 */
export const zRootResponse = z.object({
    message: z.string(),
    version: z.string()
});

export type RootResponseZodType = z.infer<typeof zRootResponse>;

/**
 * Stream
 */
export const zStream = z.object({
    infohash: z.string(),
    raw_title: z.string(),
    parsed_title: z.string(),
    parsed_data: zParsedData,
    rank: z.int(),
    lev_ratio: z.number(),
    is_cached: z.optional(z.boolean()).default(false)
});

export type StreamZodType = z.infer<typeof zStream>;

/**
 * ScrapeItemResponse
 */
export const zScrapeItemResponse = z.object({
    message: z.string(),
    streams: z.record(z.string(), zStream)
});

export type ScrapeItemResponseZodType = z.infer<typeof zScrapeItemResponse>;

/**
 * SelectFilesResponse
 */
export const zSelectFilesResponse = z.object({
    message: z.string(),
    download_type: z.enum([
        'cached',
        'uncached'
    ])
});

export type SelectFilesResponseZodType = z.infer<typeof zSelectFilesResponse>;

/**
 * SetSettings
 */
export const zSetSettings = z.object({
    key: z.string(),
    value: z.unknown()
});

export type SetSettingsZodType = z.infer<typeof zSetSettings>;

/**
 * ShowFileData
 * Root model for show file data that maps seasons to episodes to file data.
 *
 * Example:
 * {
 * 1: {  # Season 1
 * 1: {"filename": "path/to/s01e01.mkv"},  # Episode 1
 * 2: {"filename": "path/to/s01e02.mkv"}   # Episode 2
 * },
 * 2: {  # Season 2
 * 1: {"filename": "path/to/s02e01.mkv"}   # Episode 1
 * }
 * }
 */
export const zShowFileData = z.record(z.string(), z.record(z.string(), zDebridFile)).register(z.globalRegistry, {
    description: 'Root model for show file data that maps seasons to episodes to file data.\n\nExample:\n{\n    1: {  # Season 1\n        1: {"filename": "path/to/s01e01.mkv"},  # Episode 1\n        2: {"filename": "path/to/s01e02.mkv"}   # Episode 2\n    },\n    2: {  # Season 2\n        1: {"filename": "path/to/s02e01.mkv"}   # Episode 1\n    }\n}'
});

export type ShowFileDataZodType = z.infer<typeof zShowFileData>;

/**
 * SortOrderEnum
 */
export const zSortOrderEnum = z.enum([
    'title_asc',
    'title_desc',
    'date_asc',
    'date_desc'
]);

export type SortOrderEnumZodType = z.infer<typeof zSortOrderEnum>;

/**
 * TorrentFile
 * Represents a file within a torrent
 */
export const zTorrentFile = z.object({
    id: z.int(),
    path: z.string(),
    bytes: z.int(),
    selected: z.unknown(),
    download_url: z.string()
}).register(z.globalRegistry, {
    description: 'Represents a file within a torrent'
});

export type TorrentFileZodType = z.infer<typeof zTorrentFile>;

/**
 * TorrentInfo
 * Torrent information from a debrid service
 */
export const zTorrentInfo = z.object({
    id: z.union([
        z.int(),
        z.string()
    ]),
    name: z.string(),
    status: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    infohash: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    progress: z.optional(z.union([
        z.number(),
        z.null()
    ])),
    bytes: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    created_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    expires_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    completed_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    alternative_filename: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    files: z.optional(z.record(z.string(), zTorrentFile)),
    links: z.optional(z.array(z.string()))
}).register(z.globalRegistry, {
    description: 'Torrent information from a debrid service'
});

export type TorrentInfoZodType = z.infer<typeof zTorrentInfo>;

/**
 * TorrentContainer
 * Represents a collection of files from an infohash from a debrid service
 */
export const zTorrentContainer = z.object({
    infohash: z.string(),
    files: z.optional(z.array(zDebridFile)),
    torrent_id: z.optional(z.union([
        z.int(),
        z.string(),
        z.null()
    ])),
    torrent_info: z.optional(z.union([
        zTorrentInfo,
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Represents a collection of files from an infohash from a debrid service'
});

export type TorrentContainerZodType = z.infer<typeof zTorrentContainer>;

/**
 * StartSessionResponse
 */
export const zStartSessionResponse = z.object({
    message: z.string(),
    session_id: z.string(),
    torrent_id: z.union([
        z.string(),
        z.int()
    ]),
    torrent_info: zTorrentInfo,
    containers: z.union([
        zTorrentContainer,
        z.null()
    ]),
    expires_at: z.string()
});

export type StartSessionResponseZodType = z.infer<typeof zStartSessionResponse>;

/**
 * StateResponse
 */
export const zStateResponse = z.object({
    success: z.boolean().register(z.globalRegistry, {
        description: 'Boolean signifying whether the request was successful'
    }),
    states: z.array(z.string()).register(z.globalRegistry, {
        description: 'The list of states'
    })
});

export type StateResponseZodType = z.infer<typeof zStateResponse>;

/**
 * States
 */
export const zStates = z.enum([
    'Unknown',
    'Unreleased',
    'Ongoing',
    'Requested',
    'Indexed',
    'Scraped',
    'Downloaded',
    'Symlinked',
    'Completed',
    'PartiallyCompleted',
    'Failed',
    'Paused'
]);

export type StatesZodType = z.infer<typeof zStates>;

/**
 * StatesFilter
 */
export const zStatesFilter = z.enum([
    'All'
]);

export type StatesFilterZodType = z.infer<typeof zStatesFilter>;

/**
 * StatsResponse
 */
export const zStatsResponse = z.object({
    total_items: z.int(),
    total_movies: z.int(),
    total_shows: z.int(),
    total_seasons: z.int(),
    total_episodes: z.int(),
    total_symlinks: z.int(),
    incomplete_items: z.int(),
    states: z.record(z.string(), z.int()),
    activity: z.record(z.string(), z.int()).register(z.globalRegistry, {
        description: 'Dictionary mapping date strings to count of items requested on that day'
    }),
    media_year_releases: z.array(z.record(z.string(), z.union([
        z.int(),
        z.null()
    ]))).register(z.globalRegistry, {
        description: "List of dictionaries with 'year' and 'count' keys representing media item releases per year"
    })
});

export type StatsResponseZodType = z.infer<typeof zStatsResponse>;

/**
 * StreamsResponse
 */
export const zStreamsResponse = z.object({
    message: z.string(),
    streams: z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: 'The list of streams'
    }),
    blacklisted_streams: z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: 'The list of blacklisted streams'
    })
});

export type StreamsResponseZodType = z.infer<typeof zStreamsResponse>;

/**
 * TraktOAuthInitiateResponse
 */
export const zTraktOAuthInitiateResponse = z.object({
    auth_url: z.string()
});

export type TraktOAuthInitiateResponseZodType = z.infer<typeof zTraktOAuthInitiateResponse>;

/**
 * UploadLogsResponse
 */
export const zUploadLogsResponse = z.object({
    success: z.boolean(),
    url: z.url().min(1).max(2083).register(z.globalRegistry, {
        description: 'URL to the uploaded log file. 50M Filesize limit. 180 day retention.'
    })
});

export type UploadLogsResponseZodType = z.infer<typeof zUploadLogsResponse>;

/**
 * VFSStatsResponse
 */
export const zVfsStatsResponse = z.object({
    stats: z.record(z.string(), z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: 'VFS statistics'
    })
});

export type VfsStatsResponseZodType = z.infer<typeof zVfsStatsResponse>;

export const zRootData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type RootDataZodType = z.infer<typeof zRootData>;

/**
 * Successful Response
 */
export const zRootResponse2 = zRootResponse;

export type RootResponseZodType2 = z.infer<typeof zRootResponse2>;

export const zHealthData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type HealthDataZodType = z.infer<typeof zHealthData>;

/**
 * Successful Response
 */
export const zHealthResponse = zMessageResponse;

export type HealthResponseZodType = z.infer<typeof zHealthResponse>;

export const zDownloadUserInfoData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type DownloadUserInfoDataZodType = z.infer<typeof zDownloadUserInfoData>;

/**
 * Successful Response
 */
export const zDownloadUserInfoResponse = zDownloaderUserInfoResponse;

export type DownloadUserInfoResponseZodType = z.infer<typeof zDownloadUserInfoResponse>;

export const zGenerateApikeyData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type GenerateApikeyDataZodType = z.infer<typeof zGenerateApikeyData>;

/**
 * Successful Response
 */
export const zGenerateApikeyResponse = zMessageResponse;

export type GenerateApikeyResponseZodType = z.infer<typeof zGenerateApikeyResponse>;

export const zServicesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type ServicesDataZodType = z.infer<typeof zServicesData>;

/**
 * Response Services
 * Successful Response
 */
export const zServicesResponse = z.record(z.string(), z.boolean()).register(z.globalRegistry, {
    description: 'Successful Response'
});

export type ServicesResponseZodType = z.infer<typeof zServicesResponse>;

export const zTraktOauthInitiateData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type TraktOauthInitiateDataZodType = z.infer<typeof zTraktOauthInitiateData>;

/**
 * Successful Response
 */
export const zTraktOauthInitiateResponse = zTraktOAuthInitiateResponse;

export type TraktOauthInitiateResponseZodType = z.infer<typeof zTraktOauthInitiateResponse>;

export const zTraktOauthCallbackData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        code: z.string().register(z.globalRegistry, {
            description: 'The OAuth code returned by Trakt'
        })
    })
});

export type TraktOauthCallbackDataZodType = z.infer<typeof zTraktOauthCallbackData>;

/**
 * Successful Response
 */
export const zTraktOauthCallbackResponse = zMessageResponse;

export type TraktOauthCallbackResponseZodType = z.infer<typeof zTraktOauthCallbackResponse>;

export const zStatsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type StatsDataZodType = z.infer<typeof zStatsData>;

/**
 * Successful Response
 */
export const zStatsResponse2 = zStatsResponse;

export type StatsResponseZodType2 = z.infer<typeof zStatsResponse2>;

export const zLogsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type LogsDataZodType = z.infer<typeof zLogsData>;

/**
 * Successful Response
 */
export const zLogsResponse2 = zLogsResponse;

export type LogsResponseZodType2 = z.infer<typeof zLogsResponse2>;

export const zEventsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type EventsDataZodType = z.infer<typeof zEventsData>;

/**
 * Successful Response
 */
export const zEventsResponse = zEventResponse;

export type EventsResponseZodType = z.infer<typeof zEventsResponse>;

export const zMountData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type MountDataZodType = z.infer<typeof zMountData>;

/**
 * Successful Response
 */
export const zMountResponse2 = zMountResponse;

export type MountResponseZodType2 = z.infer<typeof zMountResponse2>;

export const zUploadLogsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type UploadLogsDataZodType = z.infer<typeof zUploadLogsData>;

/**
 * Successful Response
 */
export const zUploadLogsResponse2 = zUploadLogsResponse;

export type UploadLogsResponseZodType2 = z.infer<typeof zUploadLogsResponse2>;

export const zFetchCalendarData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type FetchCalendarDataZodType = z.infer<typeof zFetchCalendarData>;

/**
 * Successful Response
 */
export const zFetchCalendarResponse = zCalendarResponse;

export type FetchCalendarResponseZodType = z.infer<typeof zFetchCalendarResponse>;

export const zGetVfsStatsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type GetVfsStatsDataZodType = z.infer<typeof zGetVfsStatsData>;

/**
 * Successful Response
 */
export const zGetVfsStatsResponse = zVfsStatsResponse;

export type GetVfsStatsResponseZodType = z.infer<typeof zGetVfsStatsResponse>;

export const zGetStatesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type GetStatesDataZodType = z.infer<typeof zGetStatesData>;

/**
 * Successful Response
 */
export const zGetStatesResponse = zStateResponse;

export type GetStatesResponseZodType = z.infer<typeof zGetStatesResponse>;

export const zGetItemsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        limit: z.optional(z.int().gte(1).register(z.globalRegistry, {
            description: 'Number of items per page'
        })).default(50),
        page: z.optional(z.int().gte(1).register(z.globalRegistry, {
            description: 'Page number'
        })).default(1),
        type: z.optional(z.union([
            z.array(zMediaTypeEnum),
            z.null()
        ])),
        states: z.optional(z.union([
            z.array(z.union([
                zStates,
                zStatesFilter
            ])),
            z.null()
        ])),
        sort: z.optional(z.union([
            z.array(zSortOrderEnum),
            z.null()
        ])),
        search: z.optional(z.union([
            z.string().min(1),
            z.null()
        ])),
        extended: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Include extended item details'
        })).default(false)
    }))
});

export type GetItemsDataZodType = z.infer<typeof zGetItemsData>;

/**
 * Successful Response
 */
export const zGetItemsResponse = zItemsResponse;

export type GetItemsResponseZodType = z.infer<typeof zGetItemsResponse>;

export const zAddItemsData = z.object({
    body: zAddMediaItemPayload,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type AddItemsDataZodType = z.infer<typeof zAddItemsData>;

/**
 * Successful Response
 */
export const zAddItemsResponse = zMessageResponse;

export type AddItemsResponseZodType = z.infer<typeof zAddItemsResponse>;

export const zGetItemData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string().register(z.globalRegistry, {
            description: "\n                The ID of the media item. For 'item' type, use the numeric item ID;\n                for 'movie' or 'tv' types, use the TMDB or TVDB ID respectively.\n            "
        })
    }),
    query: z.object({
        media_type: z.enum([
            'movie',
            'tv',
            'item'
        ]).register(z.globalRegistry, {
            description: 'The type of media item'
        }),
        extended: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Whether to include extended information'
        })).default(false)
    })
});

export type GetItemDataZodType = z.infer<typeof zGetItemData>;

/**
 * Response Get Item
 * Successful Response
 */
export const zGetItemResponse = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: 'Successful Response'
});

export type GetItemResponseZodType = z.infer<typeof zGetItemResponse>;

export const zResetItemsData = z.object({
    body: zIdListPayload,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type ResetItemsDataZodType = z.infer<typeof zResetItemsData>;

/**
 * Successful Response
 */
export const zResetItemsResponse = zResetResponse;

export type ResetItemsResponseZodType = z.infer<typeof zResetItemsResponse>;

export const zRetryItemsData = z.object({
    body: zIdListPayload,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type RetryItemsDataZodType = z.infer<typeof zRetryItemsData>;

/**
 * Successful Response
 */
export const zRetryItemsResponse = zRetryResponse;

export type RetryItemsResponseZodType = z.infer<typeof zRetryItemsResponse>;

export const zRetryLibraryItemsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type RetryLibraryItemsDataZodType = z.infer<typeof zRetryLibraryItemsData>;

/**
 * Successful Response
 */
export const zRetryLibraryItemsResponse = zRetryResponse;

export type RetryLibraryItemsResponseZodType = z.infer<typeof zRetryLibraryItemsResponse>;

export const zRemoveItemData = z.object({
    body: zIdListPayload,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type RemoveItemDataZodType = z.infer<typeof zRemoveItemData>;

/**
 * Successful Response
 */
export const zRemoveItemResponse = zRemoveResponse;

export type RemoveItemResponseZodType = z.infer<typeof zRemoveItemResponse>;

export const zGetItemStreamsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        item_id: z.int().gte(1).register(z.globalRegistry, {
            description: 'The ID of the media item'
        })
    }),
    query: z.optional(z.never())
});

export type GetItemStreamsDataZodType = z.infer<typeof zGetItemStreamsData>;

/**
 * Successful Response
 */
export const zGetItemStreamsResponse = zStreamsResponse;

export type GetItemStreamsResponseZodType = z.infer<typeof zGetItemStreamsResponse>;

export const zBlacklistItemStreamData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        item_id: z.int().gte(1).register(z.globalRegistry, {
            description: 'The ID of the media item'
        }),
        stream_id: z.int().gte(1).register(z.globalRegistry, {
            description: 'The ID of the stream'
        })
    }),
    query: z.optional(z.never())
});

export type BlacklistItemStreamDataZodType = z.infer<typeof zBlacklistItemStreamData>;

/**
 * Successful Response
 */
export const zBlacklistItemStreamResponse = zMessageResponse;

export type BlacklistItemStreamResponseZodType = z.infer<typeof zBlacklistItemStreamResponse>;

export const zUnblacklistItemStreamData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        item_id: z.int().gte(1).register(z.globalRegistry, {
            description: 'The ID of the media item'
        }),
        stream_id: z.int().gte(1).register(z.globalRegistry, {
            description: 'The ID of the stream'
        })
    }),
    query: z.optional(z.never())
});

export type UnblacklistItemStreamDataZodType = z.infer<typeof zUnblacklistItemStreamData>;

/**
 * Successful Response
 */
export const zUnblacklistItemStreamResponse = zMessageResponse;

export type UnblacklistItemStreamResponseZodType = z.infer<typeof zUnblacklistItemStreamResponse>;

export const zResetItemStreamsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        item_id: z.int().gte(1).register(z.globalRegistry, {
            description: 'The ID of the media item'
        })
    }),
    query: z.optional(z.never())
});

export type ResetItemStreamsDataZodType = z.infer<typeof zResetItemStreamsData>;

/**
 * Successful Response
 */
export const zResetItemStreamsResponse = zMessageResponse;

export type ResetItemStreamsResponseZodType = z.infer<typeof zResetItemStreamsResponse>;

export const zPauseItemsData = z.object({
    body: zIdListPayload,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type PauseItemsDataZodType = z.infer<typeof zPauseItemsData>;

/**
 * Successful Response
 */
export const zPauseItemsResponse = zPauseResponse;

export type PauseItemsResponseZodType = z.infer<typeof zPauseItemsResponse>;

export const zUnpauseItemsData = z.object({
    body: zIdListPayload,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type UnpauseItemsDataZodType = z.infer<typeof zUnpauseItemsData>;

/**
 * Successful Response
 */
export const zUnpauseItemsResponse = zPauseResponse;

export type UnpauseItemsResponseZodType = z.infer<typeof zUnpauseItemsResponse>;

export const zCompositeReindexerData = z.object({
    body: zReindexPayload,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type CompositeReindexerDataZodType = z.infer<typeof zCompositeReindexerData>;

/**
 * Successful Response
 */
export const zCompositeReindexerResponse = zMessageResponse;

export type CompositeReindexerResponseZodType = z.infer<typeof zCompositeReindexerResponse>;

export const zGetItemAliasesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        item_id: z.int().gte(1).register(z.globalRegistry, {
            description: 'The ID of the media item'
        })
    }),
    query: z.optional(z.never())
});

export type GetItemAliasesDataZodType = z.infer<typeof zGetItemAliasesData>;

/**
 * Successful Response
 */
export const zGetItemAliasesResponse = zItemAliasesResponse;

export type GetItemAliasesResponseZodType = z.infer<typeof zGetItemAliasesResponse>;

export const zGetItemMetadataData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        item_id: z.int().gte(1).register(z.globalRegistry, {
            description: 'The ID of the media item'
        })
    }),
    query: z.optional(z.never())
});

export type GetItemMetadataDataZodType = z.infer<typeof zGetItemMetadataData>;

/**
 * Successful Response
 */
export const zGetItemMetadataResponse = zMediaMetadata;

export type GetItemMetadataResponseZodType = z.infer<typeof zGetItemMetadataResponse>;

export const zScrapeItemData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        item_id: z.optional(z.union([
            z.int(),
            z.null()
        ])),
        tmdb_id: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        tvdb_id: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        imdb_id: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        media_type: z.optional(z.union([
            z.enum([
                'movie',
                'tv'
            ]),
            z.null()
        ]))
    }))
});

export type ScrapeItemDataZodType = z.infer<typeof zScrapeItemData>;

/**
 * Successful Response
 */
export const zScrapeItemResponse2 = zScrapeItemResponse;

export type ScrapeItemResponseZodType2 = z.infer<typeof zScrapeItemResponse2>;

export const zStartManualSessionData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        magnet: z.string(),
        item_id: z.optional(z.union([
            z.int(),
            z.null()
        ])),
        tmdb_id: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        tvdb_id: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        imdb_id: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        media_type: z.optional(z.union([
            z.enum([
                'movie',
                'tv'
            ]),
            z.null()
        ]))
    })
});

export type StartManualSessionDataZodType = z.infer<typeof zStartManualSessionData>;

/**
 * Successful Response
 */
export const zStartManualSessionResponse = zStartSessionResponse;

export type StartManualSessionResponseZodType = z.infer<typeof zStartManualSessionResponse>;

export const zManualSelectData = z.object({
    body: zContainer,
    path: z.object({
        session_id: z.string().register(z.globalRegistry, {
            description: 'Identifier of the scraping session containing item and torrent context.'
        })
    }),
    query: z.optional(z.never())
});

export type ManualSelectDataZodType = z.infer<typeof zManualSelectData>;

/**
 * Successful Response
 */
export const zManualSelectResponse = zSelectFilesResponse;

export type ManualSelectResponseZodType = z.infer<typeof zManualSelectResponse>;

export const zManualUpdateAttributesData = z.object({
    body: z.union([
        zDebridFile,
        zShowFileData
    ]),
    path: z.object({
        session_id: z.string().register(z.globalRegistry, {
            description: 'Identifier of the scraping session containing item and torrent context.'
        })
    }),
    query: z.optional(z.never())
});

export type ManualUpdateAttributesDataZodType = z.infer<typeof zManualUpdateAttributesData>;

/**
 * Successful Response
 */
export const zManualUpdateAttributesResponse = zMessageResponse;

export type ManualUpdateAttributesResponseZodType = z.infer<typeof zManualUpdateAttributesResponse>;

export const zAbortManualSessionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        session_id: z.string().register(z.globalRegistry, {
            description: 'Identifier of the scraping session containing item and torrent context.'
        })
    }),
    query: z.optional(z.never())
});

export type AbortManualSessionDataZodType = z.infer<typeof zAbortManualSessionData>;

/**
 * Successful Response
 */
export const zAbortManualSessionResponse = zMessageResponse;

export type AbortManualSessionResponseZodType = z.infer<typeof zAbortManualSessionResponse>;

export const zCompleteManualSessionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        session_id: z.string().register(z.globalRegistry, {
            description: 'Identifier of the scraping session containing item and torrent context.'
        })
    }),
    query: z.optional(z.never())
});

export type CompleteManualSessionDataZodType = z.infer<typeof zCompleteManualSessionData>;

/**
 * Successful Response
 */
export const zCompleteManualSessionResponse = zMessageResponse;

export type CompleteManualSessionResponseZodType = z.infer<typeof zCompleteManualSessionResponse>;

export const zParseTorrentTitlesData = z.object({
    body: z.array(z.string()).register(z.globalRegistry, {
        description: 'List of torrent titles to parse'
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type ParseTorrentTitlesDataZodType = z.infer<typeof zParseTorrentTitlesData>;

/**
 * Successful Response
 */
export const zParseTorrentTitlesResponse = zParseTorrentTitleResponse;

export type ParseTorrentTitlesResponseZodType = z.infer<typeof zParseTorrentTitlesResponse>;

export const zFetchOverseerrRequestsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        filter: z.optional(z.union([
            z.enum([
                'all',
                'approved',
                'available',
                'pending',
                'processing',
                'unavailable',
                'failed',
                'deleted',
                'completed'
            ]),
            z.null()
        ])),
        take: z.optional(z.int().register(z.globalRegistry, {
            description: 'Number of requests to fetch'
        })).default(100000)
    }))
});

export type FetchOverseerrRequestsDataZodType = z.infer<typeof zFetchOverseerrRequestsData>;

/**
 * Successful Response
 */
export const zFetchOverseerrRequestsResponse = zMessageResponse;

export type FetchOverseerrRequestsResponseZodType = z.infer<typeof zFetchOverseerrRequestsResponse>;

export const zGetSettingsSchemaData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type GetSettingsSchemaDataZodType = z.infer<typeof zGetSettingsSchemaData>;

/**
 * Response Get Settings Schema
 * Successful Response
 */
export const zGetSettingsSchemaResponse = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: 'Successful Response'
});

export type GetSettingsSchemaResponseZodType = z.infer<typeof zGetSettingsSchemaResponse>;

export const zLoadSettingsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type LoadSettingsDataZodType = z.infer<typeof zLoadSettingsData>;

/**
 * Successful Response
 */
export const zLoadSettingsResponse = zMessageResponse;

export type LoadSettingsResponseZodType = z.infer<typeof zLoadSettingsResponse>;

export const zSaveSettingsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type SaveSettingsDataZodType = z.infer<typeof zSaveSettingsData>;

/**
 * Successful Response
 */
export const zSaveSettingsResponse = zMessageResponse;

export type SaveSettingsResponseZodType = z.infer<typeof zSaveSettingsResponse>;

export const zGetAllSettingsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type GetAllSettingsDataZodType = z.infer<typeof zGetAllSettingsData>;

/**
 * Successful Response
 */
export const zGetAllSettingsResponse = zAppModel;

export type GetAllSettingsResponseZodType = z.infer<typeof zGetAllSettingsResponse>;

export const zGetSettingsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        paths: z.string().min(1).register(z.globalRegistry, {
            description: 'Comma-separated list of settings paths'
        })
    }),
    query: z.optional(z.never())
});

export type GetSettingsDataZodType = z.infer<typeof zGetSettingsData>;

/**
 * Response Get Settings
 * Successful Response
 */
export const zGetSettingsResponse = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: 'Successful Response'
});

export type GetSettingsResponseZodType = z.infer<typeof zGetSettingsResponse>;

export const zSetAllSettingsData = z.object({
    body: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'New settings to apply'
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type SetAllSettingsDataZodType = z.infer<typeof zSetAllSettingsData>;

/**
 * Successful Response
 */
export const zSetAllSettingsResponse = zMessageResponse;

export type SetAllSettingsResponseZodType = z.infer<typeof zSetAllSettingsResponse>;

export const zSetSettingsData = z.object({
    body: z.array(zSetSettings).register(z.globalRegistry, {
        description: 'List of settings to update'
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type SetSettingsDataZodType = z.infer<typeof zSetSettingsData>;

/**
 * Successful Response
 */
export const zSetSettingsResponse = zMessageResponse;

export type SetSettingsResponseZodType = z.infer<typeof zSetSettingsResponse>;

export const zOverseerrApiV1WebhookOverseerrPostData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type OverseerrApiV1WebhookOverseerrPostDataZodType = z.infer<typeof zOverseerrApiV1WebhookOverseerrPostData>;

/**
 * Successful Response
 */
export const zOverseerrApiV1WebhookOverseerrPostResponse = zOverseerrWebhookResponse;

export type OverseerrApiV1WebhookOverseerrPostResponseZodType = z.infer<typeof zOverseerrApiV1WebhookOverseerrPostResponse>;

export const zGetEventTypesApiV1StreamEventTypesGetData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type GetEventTypesApiV1StreamEventTypesGetDataZodType = z.infer<typeof zGetEventTypesApiV1StreamEventTypesGetData>;

/**
 * Successful Response
 */
export const zGetEventTypesApiV1StreamEventTypesGetResponse = zEventTypesResponse;

export type GetEventTypesApiV1StreamEventTypesGetResponseZodType = z.infer<typeof zGetEventTypesApiV1StreamEventTypesGetResponse>;

export const zStreamEventsApiV1StreamEventTypeGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        event_type: z.string().min(1).register(z.globalRegistry, {
            description: 'The type of event to stream'
        })
    }),
    query: z.optional(z.never())
});

export type StreamEventsApiV1StreamEventTypeGetDataZodType = z.infer<typeof zStreamEventsApiV1StreamEventTypeGetData>;