// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

/**
 * AllDebridModel
 */
export const zAllDebridModel = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable AllDebrid'
    })).default(false),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'AllDebrid API key'
    })).default('')
});

export type AllDebridModelZodType = z.infer<typeof zAllDebridModel>;

/**
 * LibraryProfileFilterRules
 * Filter rules for library profile matching (metadata-only)
 */
export const zLibraryProfileFilterRules = z.object({
    content_types: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    genres: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    exclude_genres: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    min_year: z.optional(z.union([
        z.int().gte(1900),
        z.null()
    ])),
    max_year: z.optional(z.union([
        z.int().gte(1900),
        z.null()
    ])),
    is_anime: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    networks: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    countries: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    languages: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    min_rating: z.optional(z.union([
        z.number().gte(0).lte(10),
        z.null()
    ])),
    max_rating: z.optional(z.union([
        z.number().gte(0).lte(10),
        z.null()
    ])),
    content_ratings: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Filter rules for library profile matching (metadata-only)'
});

export type LibraryProfileFilterRulesZodType = z.infer<typeof zLibraryProfileFilterRules>;

/**
 * LibraryProfile
 * Library profile configuration for organizing media into different libraries
 */
export const zLibraryProfile = z.object({
    name: z.string().register(z.globalRegistry, {
        description: 'Human-readable profile name'
    }),
    library_path: z.string().register(z.globalRegistry, {
        description: "VFS path prefix for this profile (e.g., '/kids', '/anime')"
    }),
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable this profile'
    })).default(true),
    filter_rules: z.optional(zLibraryProfileFilterRules)
}).register(z.globalRegistry, {
    description: 'Library profile configuration for organizing media into different libraries'
});

export type LibraryProfileZodType = z.infer<typeof zLibraryProfile>;

/**
 * FilesystemModel
 */
export const zFilesystemModel = z.object({
    mount_path: z.optional(z.string().register(z.globalRegistry, {
        description: 'Path where Riven will mount the virtual filesystem'
    })).default('/path/to/riven/mount'),
    library_profiles: z.optional(z.record(z.string(), zLibraryProfile).register(z.globalRegistry, {
        description: "Library profiles for organizing media into different libraries based on metadata. An example profile is provided (disabled by default) - enable them or create your own. Each profile filters media by metadata (genres, ratings, etc.) and creates VFS paths. Media appears in all matching profile paths. Use '!' prefix in filter lists to exclude values (e.g., genres: ['action', '!horror'] = action movies but not horror)."
    })),
    cache_dir: z.optional(z.string().register(z.globalRegistry, {
        description: 'Directory for caching downloaded chunks'
    })).default('/dev/shm/riven-cache'),
    cache_max_size_mb: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Maximum cache size in MB (10 GiB default)'
    })).default(10240),
    cache_ttl_seconds: z.optional(z.int().register(z.globalRegistry, {
        description: 'Cache time-to-live in seconds (2 hours default)'
    })).default(7200),
    cache_eviction: z.optional(z.enum([
        'LRU',
        'TTL'
    ]).register(z.globalRegistry, {
        description: 'Cache eviction policy (LRU or TTL)'
    })),
    cache_metrics: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable cache metrics logging'
    })).default(true),
    chunk_size_mb: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Size of a single fetch chunk in MB'
    })).default(8),
    fetch_ahead_chunks: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Number of chunks to fetch ahead when streaming'
    })).default(4)
});

export type FilesystemModelZodType = z.infer<typeof zFilesystemModel>;

/**
 * PlexLibraryModel
 */
export const zPlexLibraryModel = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Plex library updates'
    })).default(false),
    token: z.optional(z.string().register(z.globalRegistry, {
        description: 'Plex authentication token'
    })).default(''),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Plex server URL'
    })).default('http://localhost:32400')
});

export type PlexLibraryModelZodType = z.infer<typeof zPlexLibraryModel>;

/**
 * JellyfinLibraryModel
 */
export const zJellyfinLibraryModel = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Jellyfin library updates'
    })).default(false),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Jellyfin API key'
    })).default(''),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Jellyfin server URL'
    })).default('http://localhost:8096')
});

export type JellyfinLibraryModelZodType = z.infer<typeof zJellyfinLibraryModel>;

/**
 * EmbyLibraryModel
 */
export const zEmbyLibraryModel = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Emby library updates'
    })).default(false),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Emby API key'
    })).default(''),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Emby server URL'
    })).default('http://localhost:8096')
});

export type EmbyLibraryModelZodType = z.infer<typeof zEmbyLibraryModel>;

/**
 * UpdatersModel
 */
export const zUpdatersModel = z.object({
    updater_interval: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Interval in seconds between library updates'
    })).default(120),
    library_path: z.optional(z.string().register(z.globalRegistry, {
        description: 'Path to which your media library mount point'
    })).default('/path/to/library/mount'),
    plex: z.optional(zPlexLibraryModel),
    jellyfin: z.optional(zJellyfinLibraryModel),
    emby: z.optional(zEmbyLibraryModel)
});

export type UpdatersModelZodType = z.infer<typeof zUpdatersModel>;

/**
 * RealDebridModel
 */
export const zRealDebridModel = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Real-Debrid'
    })).default(false),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Real-Debrid API key'
    })).default('')
});

export type RealDebridModelZodType = z.infer<typeof zRealDebridModel>;

/**
 * DebridLinkModel
 */
export const zDebridLinkModel = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Debrid-Link'
    })).default(false),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Debrid-Link API key'
    })).default('')
});

export type DebridLinkModelZodType = z.infer<typeof zDebridLinkModel>;

/**
 * DownloadersModel
 */
export const zDownloadersModel = z.object({
    video_extensions: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'List of video file extensions to consider for downloads'
    })),
    movie_filesize_mb_min: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Minimum file size in MB for movies'
    })).default(700),
    movie_filesize_mb_max: z.optional(z.int().gte(-1).register(z.globalRegistry, {
        description: 'Maximum file size in MB for movies (-1 for no limit)'
    })).default(-1),
    episode_filesize_mb_min: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Minimum file size in MB for episodes'
    })).default(100),
    episode_filesize_mb_max: z.optional(z.int().gte(-1).register(z.globalRegistry, {
        description: 'Maximum file size in MB for episodes (-1 for no limit)'
    })).default(-1),
    proxy_url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Proxy URL for downloaders (optional)'
    })).default(''),
    real_debrid: z.optional(zRealDebridModel),
    debrid_link: z.optional(zDebridLinkModel),
    all_debrid: z.optional(zAllDebridModel)
});

export type DownloadersModelZodType = z.infer<typeof zDownloadersModel>;

/**
 * OverseerrModel
 */
export const zOverseerrModel = z.object({
    update_interval: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Update interval in seconds'
    })).default(60),
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Overseerr integration'
    })).default(false),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Overseerr URL'
    })).default('http://localhost:5055'),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Overseerr API key'
    })).default(''),
    use_webhook: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Use webhook instead of polling'
    })).default(false)
});

export type OverseerrModelZodType = z.infer<typeof zOverseerrModel>;

/**
 * PlexWatchlistModel
 */
export const zPlexWatchlistModel = z.object({
    update_interval: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Update interval in seconds'
    })).default(60),
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Plex Watchlist integration'
    })).default(false),
    rss: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Plex Watchlist RSS feed URLs'
    }))
});

export type PlexWatchlistModelZodType = z.infer<typeof zPlexWatchlistModel>;

/**
 * MdblistModel
 */
export const zMdblistModel = z.object({
    update_interval: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Update interval in seconds (24 hours default)'
    })).default(86400),
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable MDBList integration'
    })).default(false),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'MDBList API key'
    })).default(''),
    lists: z.optional(z.array(z.union([
        z.string(),
        z.int()
    ])).register(z.globalRegistry, {
        description: 'MDBList list IDs to monitor'
    }))
});

export type MdblistModelZodType = z.infer<typeof zMdblistModel>;

/**
 * ListrrModel
 */
export const zListrrModel = z.object({
    update_interval: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Update interval in seconds (24 hours default)'
    })).default(86400),
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Listrr integration'
    })).default(false),
    movie_lists: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Listrr movie list IDs'
    })),
    show_lists: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Listrr TV show list IDs'
    })),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Listrr API key'
    })).default('')
});

export type ListrrModelZodType = z.infer<typeof zListrrModel>;

/**
 * TraktOauthModel
 */
export const zTraktOauthModel = z.object({
    oauth_client_id: z.optional(z.string().register(z.globalRegistry, {
        description: 'Trakt OAuth client ID'
    })).default(''),
    oauth_client_secret: z.optional(z.string().register(z.globalRegistry, {
        description: 'Trakt OAuth client secret'
    })).default(''),
    oauth_redirect_uri: z.optional(z.string().register(z.globalRegistry, {
        description: 'Trakt OAuth redirect URI'
    })).default(''),
    access_token: z.optional(z.string().register(z.globalRegistry, {
        description: 'Trakt OAuth access token'
    })).default(''),
    refresh_token: z.optional(z.string().register(z.globalRegistry, {
        description: 'Trakt OAuth refresh token'
    })).default('')
});

export type TraktOauthModelZodType = z.infer<typeof zTraktOauthModel>;

/**
 * TraktModel
 */
export const zTraktModel = z.object({
    update_interval: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Update interval in seconds (24 hours default)'
    })).default(86400),
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Trakt integration'
    })).default(false),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Trakt API key'
    })).default(''),
    watchlist: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Trakt usernames for watchlist monitoring'
    })),
    user_lists: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Trakt user list URLs to monitor'
    })),
    collection: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Trakt usernames for collection monitoring'
    })),
    fetch_trending: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Fetch trending content from Trakt'
    })).default(false),
    trending_count: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Number of trending items to fetch'
    })).default(10),
    fetch_popular: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Fetch popular content from Trakt'
    })).default(false),
    popular_count: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Number of popular items to fetch'
    })).default(10),
    fetch_most_watched: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Fetch most watched content from Trakt'
    })).default(false),
    most_watched_period: z.optional(z.string().register(z.globalRegistry, {
        description: 'Period for most watched (daily, weekly, monthly, yearly)'
    })).default('weekly'),
    most_watched_count: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Number of most watched items to fetch'
    })).default(10),
    oauth: z.optional(zTraktOauthModel),
    proxy_url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Proxy URL for Trakt API requests'
    })).default('')
});

export type TraktModelZodType = z.infer<typeof zTraktModel>;

/**
 * ContentModel
 */
export const zContentModel = z.object({
    overseerr: z.optional(zOverseerrModel),
    plex_watchlist: z.optional(zPlexWatchlistModel),
    mdblist: z.optional(zMdblistModel),
    listrr: z.optional(zListrrModel),
    trakt: z.optional(zTraktModel)
});

export type ContentModelZodType = z.infer<typeof zContentModel>;

/**
 * TorrentioConfig
 */
export const zTorrentioConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Torrentio scraper'
    })).default(false),
    filter: z.optional(z.string().register(z.globalRegistry, {
        description: 'Torrentio filter parameters'
    })).default('sort=qualitysize%7Cqualityfilter=480p,scr,cam'),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Torrentio URL'
    })).default('http://torrentio.strem.fun'),
    timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Request timeout in seconds'
    })).default(30),
    retries: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Number of retries for failed requests'
    })).default(1),
    ratelimit: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable rate limiting'
    })).default(true),
    proxy_url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Proxy URL for Torrentio requests'
    })).default('')
});

export type TorrentioConfigZodType = z.infer<typeof zTorrentioConfig>;

/**
 * JackettConfig
 */
export const zJackettConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Jackett scraper'
    })).default(false),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Jackett URL'
    })).default('http://localhost:9117'),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Jackett API key'
    })).default(''),
    timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Request timeout in seconds'
    })).default(30),
    retries: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Number of retries for failed requests'
    })).default(1),
    infohash_fetch_timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Timeout in seconds for parallel infohash fetching from URLs'
    })).default(30),
    ratelimit: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable rate limiting'
    })).default(true)
});

export type JackettConfigZodType = z.infer<typeof zJackettConfig>;

/**
 * ProwlarrConfig
 */
export const zProwlarrConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Prowlarr scraper'
    })).default(false),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Prowlarr URL'
    })).default('http://localhost:9696'),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Prowlarr API key'
    })).default(''),
    timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Request timeout in seconds'
    })).default(30),
    retries: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Number of retries for failed requests'
    })).default(1),
    infohash_fetch_timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Timeout in seconds for parallel infohash fetching from URLs'
    })).default(30),
    ratelimit: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable rate limiting'
    })).default(true),
    limiter_seconds: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Rate limiter cooldown in seconds'
    })).default(60)
});

export type ProwlarrConfigZodType = z.infer<typeof zProwlarrConfig>;

/**
 * OrionoidConfigParametersDict
 */
export const zOrionoidConfigParametersDict = z.object({
    video3d: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Include 3D video results'
    })).default(false),
    videoquality: z.optional(z.string().register(z.globalRegistry, {
        description: 'Video quality filter'
    })).default('sd_hd8k'),
    limitcount: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Maximum number of results'
    })).default(5)
});

export type OrionoidConfigParametersDictZodType = z.infer<typeof zOrionoidConfigParametersDict>;

/**
 * OrionoidConfig
 */
export const zOrionoidConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Orionoid scraper'
    })).default(false),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'Orionoid API key'
    })).default(''),
    cached_results_only: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Only return cached/downloadable results'
    })).default(false),
    parameters: z.optional(zOrionoidConfigParametersDict),
    timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Request timeout in seconds'
    })).default(30),
    retries: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Number of retries for failed requests'
    })).default(1),
    ratelimit: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable rate limiting'
    })).default(true)
});

export type OrionoidConfigZodType = z.infer<typeof zOrionoidConfig>;

/**
 * MediafusionConfig
 */
export const zMediafusionConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Mediafusion scraper'
    })).default(false),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Mediafusion URL'
    })).default('http://localhost:8000'),
    timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Request timeout in seconds'
    })).default(30),
    retries: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Number of retries for failed requests'
    })).default(1),
    ratelimit: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable rate limiting'
    })).default(true)
});

export type MediafusionConfigZodType = z.infer<typeof zMediafusionConfig>;

/**
 * ZileanConfig
 */
export const zZileanConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Zilean scraper'
    })).default(false),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Zilean URL'
    })).default('http://localhost:8181'),
    timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Request timeout in seconds'
    })).default(30),
    retries: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Number of retries for failed requests'
    })).default(1),
    ratelimit: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable rate limiting'
    })).default(true)
});

export type ZileanConfigZodType = z.infer<typeof zZileanConfig>;

/**
 * CometConfig
 */
export const zCometConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Comet scraper'
    })).default(false),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'Comet URL'
    })).default('http://localhost:8000'),
    timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Request timeout in seconds'
    })).default(30),
    retries: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Number of retries for failed requests'
    })).default(1),
    ratelimit: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable rate limiting'
    })).default(true)
});

export type CometConfigZodType = z.infer<typeof zCometConfig>;

/**
 * RarbgConfig
 */
export const zRarbgConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable RARBG scraper'
    })).default(false),
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'RARBG URL'
    })).default('https://therarbg.to'),
    timeout: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'Request timeout in seconds'
    })).default(30),
    retries: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Number of retries for failed requests'
    })).default(1),
    ratelimit: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable rate limiting'
    })).default(true)
});

export type RarbgConfigZodType = z.infer<typeof zRarbgConfig>;

/**
 * ScraperModel
 */
export const zScraperModel = z.object({
    after_2: z.optional(z.number().register(z.globalRegistry, {
        description: 'Hours to wait after 2 failed scrapes'
    })).default(2),
    after_5: z.optional(z.number().register(z.globalRegistry, {
        description: 'Hours to wait after 5 failed scrapes'
    })).default(6),
    after_10: z.optional(z.number().register(z.globalRegistry, {
        description: 'Hours to wait after 10 failed scrapes'
    })).default(24),
    enable_aliases: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable title aliases for better matching'
    })).default(true),
    bucket_limit: z.optional(z.int().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Maximum results per quality bucket'
    })).default(5),
    max_failed_attempts: z.optional(z.int().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Maximum failed scrape attempts before giving up'
    })).default(0),
    dubbed_anime_only: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Only scrape dubbed anime content'
    })).default(false),
    torrentio: z.optional(zTorrentioConfig),
    jackett: z.optional(zJackettConfig),
    prowlarr: z.optional(zProwlarrConfig),
    orionoid: z.optional(zOrionoidConfig),
    mediafusion: z.optional(zMediafusionConfig),
    zilean: z.optional(zZileanConfig),
    comet: z.optional(zCometConfig),
    rarbg: z.optional(zRarbgConfig)
});

export type ScraperModelZodType = z.infer<typeof zScraperModel>;

/**
 * ResolutionConfig
 * Configuration for which resolutions are enabled.
 */
export const zResolutionConfig = z.object({
    r2160p: z.optional(z.boolean()).default(false),
    r1080p: z.optional(z.boolean()).default(true),
    r720p: z.optional(z.boolean()).default(true),
    r480p: z.optional(z.boolean()).default(false),
    r360p: z.optional(z.boolean()).default(false),
    unknown: z.optional(z.boolean()).default(true)
}).register(z.globalRegistry, {
    description: 'Configuration for which resolutions are enabled.'
});

export type ResolutionConfigZodType = z.infer<typeof zResolutionConfig>;

/**
 * OptionsConfig
 * Configuration for various options.
 */
export const zOptionsConfig = z.object({
    title_similarity: z.optional(z.number()).default(0.85),
    remove_all_trash: z.optional(z.boolean()).default(true),
    remove_ranks_under: z.optional(z.int()).default(-10000),
    remove_unknown_languages: z.optional(z.boolean()).default(false),
    allow_english_in_languages: z.optional(z.boolean()).default(true),
    enable_fetch_speed_mode: z.optional(z.boolean()).default(true),
    remove_adult_content: z.optional(z.boolean()).default(true)
}).register(z.globalRegistry, {
    description: 'Configuration for various options.'
});

export type OptionsConfigZodType = z.infer<typeof zOptionsConfig>;

/**
 * LanguagesConfig
 * Configuration for which languages are enabled.
 */
export const zLanguagesConfig = z.object({
    required: z.optional(z.array(z.string())).default([]),
    exclude: z.optional(z.array(z.string())).default([]),
    preferred: z.optional(z.array(z.string())).default([])
}).register(z.globalRegistry, {
    description: 'Configuration for which languages are enabled.'
});

export type LanguagesConfigZodType = z.infer<typeof zLanguagesConfig>;

/**
 * CustomRank
 * Custom Ranks used in SettingsModel.
 */
export const zCustomRank = z.object({
    fetch: z.optional(z.boolean()).default(true),
    use_custom_rank: z.optional(z.boolean()).default(false),
    rank: z.optional(z.int()).default(0)
}).register(z.globalRegistry, {
    description: 'Custom Ranks used in SettingsModel.'
});

export type CustomRankZodType = z.infer<typeof zCustomRank>;

/**
 * QualityRankModel
 * Ranking configuration for quality attributes.
 */
export const zQualityRankModel = z.object({
    av1: z.optional(zCustomRank),
    avc: z.optional(zCustomRank),
    bluray: z.optional(zCustomRank),
    dvd: z.optional(zCustomRank),
    hdtv: z.optional(zCustomRank),
    hevc: z.optional(zCustomRank),
    mpeg: z.optional(zCustomRank),
    remux: z.optional(zCustomRank),
    vhs: z.optional(zCustomRank),
    web: z.optional(zCustomRank),
    webdl: z.optional(zCustomRank),
    webmux: z.optional(zCustomRank),
    xvid: z.optional(zCustomRank)
}).register(z.globalRegistry, {
    description: 'Ranking configuration for quality attributes.'
});

export type QualityRankModelZodType = z.infer<typeof zQualityRankModel>;

/**
 * RipsRankModel
 * Ranking configuration for rips attributes.
 */
export const zRipsRankModel = z.object({
    bdrip: z.optional(zCustomRank),
    brrip: z.optional(zCustomRank),
    dvdrip: z.optional(zCustomRank),
    hdrip: z.optional(zCustomRank),
    ppvrip: z.optional(zCustomRank),
    satrip: z.optional(zCustomRank),
    tvrip: z.optional(zCustomRank),
    uhdrip: z.optional(zCustomRank),
    vhsrip: z.optional(zCustomRank),
    webdlrip: z.optional(zCustomRank),
    webrip: z.optional(zCustomRank)
}).register(z.globalRegistry, {
    description: 'Ranking configuration for rips attributes.'
});

export type RipsRankModelZodType = z.infer<typeof zRipsRankModel>;

/**
 * HdrRankModel
 * Ranking configuration for HDR attributes.
 */
export const zHdrRankModel = z.object({
    bit10: z.optional(zCustomRank),
    dolby_vision: z.optional(zCustomRank),
    hdr: z.optional(zCustomRank),
    hdr10plus: z.optional(zCustomRank),
    sdr: z.optional(zCustomRank)
}).register(z.globalRegistry, {
    description: 'Ranking configuration for HDR attributes.'
});

export type HdrRankModelZodType = z.infer<typeof zHdrRankModel>;

/**
 * AudioRankModel
 * Ranking configuration for audio attributes.
 */
export const zAudioRankModel = z.object({
    aac: z.optional(zCustomRank),
    atmos: z.optional(zCustomRank),
    dolby_digital: z.optional(zCustomRank),
    dolby_digital_plus: z.optional(zCustomRank),
    dts_lossy: z.optional(zCustomRank),
    dts_lossless: z.optional(zCustomRank),
    flac: z.optional(zCustomRank),
    mono: z.optional(zCustomRank),
    mp3: z.optional(zCustomRank),
    stereo: z.optional(zCustomRank),
    surround: z.optional(zCustomRank),
    truehd: z.optional(zCustomRank)
}).register(z.globalRegistry, {
    description: 'Ranking configuration for audio attributes.'
});

export type AudioRankModelZodType = z.infer<typeof zAudioRankModel>;

/**
 * ExtrasRankModel
 * Ranking configuration for extras attributes.
 */
export const zExtrasRankModel = z.object({
    '3d': z.optional(zCustomRank),
    converted: z.optional(zCustomRank),
    documentary: z.optional(zCustomRank),
    dubbed: z.optional(zCustomRank),
    edition: z.optional(zCustomRank),
    hardcoded: z.optional(zCustomRank),
    network: z.optional(zCustomRank),
    proper: z.optional(zCustomRank),
    repack: z.optional(zCustomRank),
    retail: z.optional(zCustomRank),
    site: z.optional(zCustomRank),
    subbed: z.optional(zCustomRank),
    upscaled: z.optional(zCustomRank),
    scene: z.optional(zCustomRank),
    uncensored: z.optional(zCustomRank)
}).register(z.globalRegistry, {
    description: 'Ranking configuration for extras attributes.'
});

export type ExtrasRankModelZodType = z.infer<typeof zExtrasRankModel>;

/**
 * TrashRankModel
 * Ranking configuration for trash attributes.
 */
export const zTrashRankModel = z.object({
    cam: z.optional(zCustomRank),
    clean_audio: z.optional(zCustomRank),
    pdtv: z.optional(zCustomRank),
    r5: z.optional(zCustomRank),
    screener: z.optional(zCustomRank),
    size: z.optional(zCustomRank),
    telecine: z.optional(zCustomRank),
    telesync: z.optional(zCustomRank)
}).register(z.globalRegistry, {
    description: 'Ranking configuration for trash attributes.'
});

export type TrashRankModelZodType = z.infer<typeof zTrashRankModel>;

/**
 * CustomRanksConfig
 * Configuration for custom ranks.
 */
export const zCustomRanksConfig = z.object({
    quality: z.optional(zQualityRankModel),
    rips: z.optional(zRipsRankModel),
    hdr: z.optional(zHdrRankModel),
    audio: z.optional(zAudioRankModel),
    extras: z.optional(zExtrasRankModel),
    trash: z.optional(zTrashRankModel)
}).register(z.globalRegistry, {
    description: 'Configuration for custom ranks.'
});

export type CustomRanksConfigZodType = z.infer<typeof zCustomRanksConfig>;

/**
 * RTNSettingsModel
 */
export const zRtnSettingsModel = z.object({
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'Name of the settings'
    })).default('example'),
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether these settings will be used or not'
    })).default(true),
    require: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Patterns torrents must match to be considered'
    })),
    exclude: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Patterns that, if matched, result in torrent exclusion'
    })),
    preferred: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Patterns indicating preferred attributes in torrents'
    })),
    resolutions: z.optional(zResolutionConfig),
    options: z.optional(zOptionsConfig),
    languages: z.optional(zLanguagesConfig),
    custom_ranks: z.optional(zCustomRanksConfig)
});

export type RtnSettingsModelZodType = z.infer<typeof zRtnSettingsModel>;

/**
 * IndexerModel
 */
export const zIndexerModel = z.object({
    schedule_offset_minutes: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Offset in minutes after aired_at time to schedule scraping for episodes and movies (30 minutes default)'
    })).default(30)
});

export type IndexerModelZodType = z.infer<typeof zIndexerModel>;

/**
 * DatabaseModel
 */
export const zDatabaseModel = z.object({
    host: z.optional(z.string().min(1).register(z.globalRegistry, {
        description: 'Database connection string'
    }))
});

export type DatabaseModelZodType = z.infer<typeof zDatabaseModel>;

/**
 * NotificationsModel
 */
export const zNotificationsModel = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable notifications'
    })).default(false),
    on_item_type: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Item types to send notifications for'
    })),
    service_urls: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Notification service URLs (e.g., Discord webhooks)'
    }))
});

export type NotificationsModelZodType = z.infer<typeof zNotificationsModel>;

/**
 * SubtitleProviderConfig
 */
export const zSubtitleProviderConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable this subtitle provider'
    })).default(false)
});

export type SubtitleProviderConfigZodType = z.infer<typeof zSubtitleProviderConfig>;

/**
 * SubtitleProvidersDict
 */
export const zSubtitleProvidersDict = z.object({
    opensubtitles: z.optional(zSubtitleProviderConfig)
});

export type SubtitleProvidersDictZodType = z.infer<typeof zSubtitleProvidersDict>;

/**
 * SubtitleConfig
 */
export const zSubtitleConfig = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable subtitle downloading'
    })).default(false),
    languages: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Subtitle languages to download (ISO 639-2 codes)'
    })),
    providers: z.optional(zSubtitleProvidersDict)
});

export type SubtitleConfigZodType = z.infer<typeof zSubtitleConfig>;

/**
 * PostProcessing
 */
export const zPostProcessing = z.object({
    subtitle: z.optional(zSubtitleConfig)
});

export type PostProcessingZodType = z.infer<typeof zPostProcessing>;

/**
 * LoggingModel
 */
export const zLoggingModel = z.object({
    enabled: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable file logging'
    })).default(true),
    clean_interval: z.optional(z.int().register(z.globalRegistry, {
        description: 'Log cleanup interval in seconds (1 hour default)'
    })).default(3600),
    retention_hours: z.optional(z.int().register(z.globalRegistry, {
        description: 'Log retention period in hours'
    })).default(24),
    rotation_mb: z.optional(z.int().register(z.globalRegistry, {
        description: 'Log file rotation size in MB'
    })).default(10),
    compression: z.optional(z.enum([
        'zip',
        'gz',
        'bz2',
        'xz',
        'disabled'
    ]).register(z.globalRegistry, {
        description: 'Log compression format (empty for no compression)'
    }))
});

export type LoggingModelZodType = z.infer<typeof zLoggingModel>;

/**
 * AppModel
 */
export const zAppModel = z.object({
    version: z.optional(z.string().register(z.globalRegistry, {
        description: 'Application version'
    })),
    api_key: z.optional(z.string().register(z.globalRegistry, {
        description: 'API key for Riven API access'
    })).default(''),
    log_level: z.optional(z.enum([
        'TRACE',
        'DEBUG',
        'INFO',
        'WARNING',
        'ERROR',
        'CRITICAL'
    ]).register(z.globalRegistry, {
        description: 'Logging level'
    })),
    retry_interval: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'Interval in seconds to retry failed library items (24 hours default, 0 to disable)'
    })).default(86400),
    tracemalloc: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Enable Python memory tracking (debug)'
    })).default(false),
    filesystem: z.optional(zFilesystemModel),
    updaters: z.optional(zUpdatersModel),
    downloaders: z.optional(zDownloadersModel),
    content: z.optional(zContentModel),
    scraping: z.optional(zScraperModel),
    ranking: z.optional(zRtnSettingsModel),
    indexer: z.optional(zIndexerModel),
    database: z.optional(zDatabaseModel),
    notifications: z.optional(zNotificationsModel),
    post_processing: z.optional(zPostProcessing),
    logging: z.optional(zLoggingModel)
});

export type AppModelZodType = z.infer<typeof zAppModel>;

/**
 * CalendarResponse
 */
export const zCalendarResponse = z.object({
    data: z.record(z.string(), z.unknown())
});

export type CalendarResponseZodType = z.infer<typeof zCalendarResponse>;

/**
 * DebridFile
 * Represents a file from a debrid service
 */
export const zDebridFile = z.object({
    file_id: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    filename: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    filesize: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    download_url: z.optional(z.union([
        z.string(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Represents a file from a debrid service'
});

export type DebridFileZodType = z.infer<typeof zDebridFile>;

/**
 * Container
 * Root model for container mapping file IDs to file information.
 *
 * Example:
 * {
 * "4": {
 * "filename": "show.s01e01.mkv",
 * "filesize": 30791392598
 * },
 * "5": {
 * "filename": "show.s01e02.mkv",
 * "filesize": 25573181861
 * }
 * }
 */
export const zContainer = z.record(z.string(), zDebridFile).register(z.globalRegistry, {
    description: 'Root model for container mapping file IDs to file information.\n\nExample:\n{\n    "4": {\n        "filename": "show.s01e01.mkv",\n        "filesize": 30791392598\n    },\n    "5": {\n        "filename": "show.s01e02.mkv",\n        "filesize": 25573181861\n    }\n}'
});

export type ContainerZodType = z.infer<typeof zContainer>;

/**
 * DownloaderUserInfo
 * Normalized downloader user information response
 */
export const zDownloaderUserInfo = z.object({
    service: z.enum([
        'realdebrid',
        'alldebrid',
        'debridlink'
    ]),
    username: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    email: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    user_id: z.union([
        z.int(),
        z.string()
    ]),
    premium_status: z.enum([
        'free',
        'premium'
    ]),
    premium_expires_at: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    premium_days_left: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    points: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    total_downloaded_bytes: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    cooldown_until: z.optional(z.union([
        z.string(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Normalized downloader user information response'
});

export type DownloaderUserInfoZodType = z.infer<typeof zDownloaderUserInfo>;

/**
 * DownloaderUserInfoResponse
 * Response containing user info for all initialized downloader services
 */
export const zDownloaderUserInfoResponse = z.object({
    services: z.array(zDownloaderUserInfo)
}).register(z.globalRegistry, {
    description: 'Response containing user info for all initialized downloader services'
});

export type DownloaderUserInfoResponseZodType = z.infer<typeof zDownloaderUserInfoResponse>;

/**
 * ValidationError
 */
export const zValidationError = z.object({
    loc: z.array(z.union([
        z.string(),
        z.int()
    ])),
    msg: z.string(),
    type: z.string()
});

export type ValidationErrorZodType = z.infer<typeof zValidationError>;

/**
 * HTTPValidationError
 */
export const zHttpValidationError = z.object({
    detail: z.optional(z.array(zValidationError))
});

export type HttpValidationErrorZodType = z.infer<typeof zHttpValidationError>;

/**
 * ItemAliasesResponse
 */
export const zItemAliasesResponse = z.object({
    aliases: z.record(z.string(), z.array(z.string()))
});

export type ItemAliasesResponseZodType = z.infer<typeof zItemAliasesResponse>;

/**
 * ItemsResponse
 */
export const zItemsResponse = z.object({
    success: z.boolean(),
    items: z.array(z.record(z.string(), z.unknown())),
    page: z.int(),
    limit: z.int(),
    total_items: z.int(),
    total_pages: z.int()
});

export type ItemsResponseZodType = z.infer<typeof zItemsResponse>;

/**
 * LogsResponse
 */
export const zLogsResponse = z.object({
    logs: z.array(z.string())
});

export type LogsResponseZodType = z.infer<typeof zLogsResponse>;

/**
 * MediaTypeEnum
 */
export const zMediaTypeEnum = z.enum([
    'movie',
    'show',
    'season',
    'episode',
    'anime'
]);

export type MediaTypeEnumZodType = z.infer<typeof zMediaTypeEnum>;

/**
 * MessageResponse
 */
export const zMessageResponse = z.object({
    message: z.string(),
    tmdb_ids: z.optional(z.array(z.string())).default([]),
    tvdb_ids: z.optional(z.array(z.string())).default([])
});

export type MessageResponseZodType = z.infer<typeof zMessageResponse>;

/**
 * MountResponse
 */
export const zMountResponse = z.object({
    files: z.record(z.string(), z.string())
});

export type MountResponseZodType = z.infer<typeof zMountResponse>;

/**
 * ParseTorrentTitleResponse
 */
export const zParseTorrentTitleResponse = z.object({
    message: z.string(),
    data: z.array(z.record(z.string(), z.unknown()))
});

export type ParseTorrentTitleResponseZodType = z.infer<typeof zParseTorrentTitleResponse>;

/**
 * ParsedData
 * Parsed data model for a torrent title.
 */
export const zParsedData = z.object({
    raw_title: z.string(),
    parsed_title: z.optional(z.string()).default(''),
    normalized_title: z.optional(z.string()).default(''),
    trash: z.optional(z.boolean()).default(false),
    adult: z.optional(z.boolean()).default(false),
    year: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    resolution: z.optional(z.string()).default('unknown'),
    seasons: z.optional(z.array(z.int())).default([]),
    episodes: z.optional(z.array(z.int())).default([]),
    complete: z.optional(z.boolean()).default(false),
    volumes: z.optional(z.array(z.int())).default([]),
    languages: z.optional(z.array(z.string())).default([]),
    quality: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    hdr: z.optional(z.array(z.string())).default([]),
    codec: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    audio: z.optional(z.array(z.string())).default([]),
    channels: z.optional(z.array(z.string())).default([]),
    dubbed: z.optional(z.boolean()).default(false),
    subbed: z.optional(z.boolean()).default(false),
    date: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    group: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    edition: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    bit_depth: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    bitrate: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    network: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    extended: z.optional(z.boolean()).default(false),
    converted: z.optional(z.boolean()).default(false),
    hardcoded: z.optional(z.boolean()).default(false),
    region: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    ppv: z.optional(z.boolean()).default(false),
    site: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    size: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    proper: z.optional(z.boolean()).default(false),
    repack: z.optional(z.boolean()).default(false),
    retail: z.optional(z.boolean()).default(false),
    upscaled: z.optional(z.boolean()).default(false),
    remastered: z.optional(z.boolean()).default(false),
    unrated: z.optional(z.boolean()).default(false),
    uncensored: z.optional(z.boolean()).default(false),
    documentary: z.optional(z.boolean()).default(false),
    commentary: z.optional(z.boolean()).default(false),
    episode_code: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    country: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    container: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    extension: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    extras: z.optional(z.array(z.string())).default([]),
    torrent: z.optional(z.boolean()).default(false),
    scene: z.optional(z.boolean()).default(false)
}).register(z.globalRegistry, {
    description: 'Parsed data model for a torrent title.'
});

export type ParsedDataZodType = z.infer<typeof zParsedData>;

/**
 * PauseResponse
 */
export const zPauseResponse = z.object({
    message: z.string(),
    ids: z.array(z.int())
});

export type PauseResponseZodType = z.infer<typeof zPauseResponse>;

/**
 * ReindexResponse
 */
export const zReindexResponse = z.object({
    message: z.string()
});

export type ReindexResponseZodType = z.infer<typeof zReindexResponse>;

/**
 * RemoveResponse
 */
export const zRemoveResponse = z.object({
    message: z.string(),
    ids: z.array(z.int())
});

export type RemoveResponseZodType = z.infer<typeof zRemoveResponse>;

/**
 * ResetResponse
 */
export const zResetResponse = z.object({
    message: z.string(),
    ids: z.array(z.int())
});

export type ResetResponseZodType = z.infer<typeof zResetResponse>;

/**
 * RetryResponse
 */
export const zRetryResponse = z.object({
    message: z.string(),
    ids: z.array(z.int())
});

export type RetryResponseZodType = z.infer<typeof zRetryResponse>;

/**
 * RootResponse
 */
export const zRootResponse = z.object({
    message: z.string(),
    tmdb_ids: z.optional(z.array(z.string())).default([]),
    tvdb_ids: z.optional(z.array(z.string())).default([]),
    version: z.string()
});

export type RootResponseZodType = z.infer<typeof zRootResponse>;

/**
 * Stream
 */
export const zStream = z.object({
    infohash: z.string(),
    raw_title: z.string(),
    parsed_title: z.string(),
    parsed_data: zParsedData,
    rank: z.int(),
    lev_ratio: z.number(),
    is_cached: z.optional(z.boolean()).default(false)
});

export type StreamZodType = z.infer<typeof zStream>;

/**
 * ScrapeItemResponse
 */
export const zScrapeItemResponse = z.object({
    message: z.string(),
    streams: z.record(z.string(), zStream)
});

export type ScrapeItemResponseZodType = z.infer<typeof zScrapeItemResponse>;

/**
 * SelectFilesResponse
 */
export const zSelectFilesResponse = z.object({
    message: z.string(),
    download_type: z.enum([
        'cached',
        'uncached'
    ])
});

export type SelectFilesResponseZodType = z.infer<typeof zSelectFilesResponse>;

/**
 * SessionResponse
 */
export const zSessionResponse = z.object({
    message: z.string()
});

export type SessionResponseZodType = z.infer<typeof zSessionResponse>;

/**
 * SetSettings
 */
export const zSetSettings = z.object({
    key: z.string(),
    value: z.unknown()
});

export type SetSettingsZodType = z.infer<typeof zSetSettings>;

/**
 * ShowFileData
 * Root model for show file data that maps seasons to episodes to file data.
 *
 * Example:
 * {
 * 1: {  # Season 1
 * 1: {"filename": "path/to/s01e01.mkv"},  # Episode 1
 * 2: {"filename": "path/to/s01e02.mkv"}   # Episode 2
 * },
 * 2: {  # Season 2
 * 1: {"filename": "path/to/s02e01.mkv"}   # Episode 1
 * }
 * }
 */
export const zShowFileData = z.record(z.string(), z.record(z.string(), zDebridFile)).register(z.globalRegistry, {
    description: 'Root model for show file data that maps seasons to episodes to file data.\n\nExample:\n{\n    1: {  # Season 1\n        1: {"filename": "path/to/s01e01.mkv"},  # Episode 1\n        2: {"filename": "path/to/s01e02.mkv"}   # Episode 2\n    },\n    2: {  # Season 2\n        1: {"filename": "path/to/s02e01.mkv"}   # Episode 1\n    }\n}'
});

export type ShowFileDataZodType = z.infer<typeof zShowFileData>;

/**
 * SortOrderEnum
 */
export const zSortOrderEnum = z.enum([
    'title_asc',
    'title_desc',
    'date_asc',
    'date_desc'
]);

export type SortOrderEnumZodType = z.infer<typeof zSortOrderEnum>;

/**
 * TorrentInfo
 * Torrent information from a debrid service
 */
export const zTorrentInfo = z.object({
    id: z.union([
        z.int(),
        z.string()
    ]),
    name: z.string(),
    status: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    infohash: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    progress: z.optional(z.union([
        z.number(),
        z.null()
    ])),
    bytes: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    created_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    expires_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    completed_at: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    alternative_filename: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    files: z.optional(z.record(z.string(), z.record(z.string(), z.union([
        z.int(),
        z.string()
    ])))),
    links: z.optional(z.array(z.string()))
}).register(z.globalRegistry, {
    description: 'Torrent information from a debrid service'
});

export type TorrentInfoZodType = z.infer<typeof zTorrentInfo>;

/**
 * TorrentContainer
 * Represents a collection of files from an infohash from a debrid service
 */
export const zTorrentContainer = z.object({
    infohash: z.string(),
    files: z.optional(z.array(zDebridFile)),
    torrent_id: z.optional(z.union([
        z.int(),
        z.string(),
        z.null()
    ])),
    torrent_info: z.optional(z.union([
        zTorrentInfo,
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Represents a collection of files from an infohash from a debrid service'
});

export type TorrentContainerZodType = z.infer<typeof zTorrentContainer>;

/**
 * StartSessionResponse
 */
export const zStartSessionResponse = z.object({
    message: z.string(),
    session_id: z.string(),
    torrent_id: z.string(),
    torrent_info: zTorrentInfo,
    containers: z.union([
        zTorrentContainer,
        z.null()
    ]),
    expires_at: z.string()
});

export type StartSessionResponseZodType = z.infer<typeof zStartSessionResponse>;

/**
 * StateResponse
 */
export const zStateResponse = z.object({
    success: z.boolean(),
    states: z.array(z.string())
});

export type StateResponseZodType = z.infer<typeof zStateResponse>;

/**
 * States
 */
export const zStates = z.enum([
    'Unknown',
    'Unreleased',
    'Ongoing',
    'Requested',
    'Indexed',
    'Scraped',
    'Downloaded',
    'Symlinked',
    'Completed',
    'PartiallyCompleted',
    'Failed',
    'Paused'
]);

export type StatesZodType = z.infer<typeof zStates>;

/**
 * StatesFilter
 */
export const zStatesFilter = z.enum([
    'All'
]);

export type StatesFilterZodType = z.infer<typeof zStatesFilter>;

/**
 * StatsResponse
 */
export const zStatsResponse = z.object({
    total_items: z.int(),
    total_movies: z.int(),
    total_shows: z.int(),
    total_seasons: z.int(),
    total_episodes: z.int(),
    total_symlinks: z.int(),
    incomplete_items: z.int(),
    incomplete_retries: z.record(z.string(), z.int()).register(z.globalRegistry, {
        description: 'Media item log string: number of retries'
    }),
    states: z.record(z.string(), z.int())
});

export type StatsResponseZodType = z.infer<typeof zStatsResponse>;

/**
 * TraktOAuthInitiateResponse
 */
export const zTraktOAuthInitiateResponse = z.object({
    auth_url: z.string()
});

export type TraktOAuthInitiateResponseZodType = z.infer<typeof zTraktOAuthInitiateResponse>;

/**
 * UpdateAttributesResponse
 */
export const zUpdateAttributesResponse = z.object({
    message: z.string()
});

export type UpdateAttributesResponseZodType = z.infer<typeof zUpdateAttributesResponse>;

/**
 * UpdateOngoingResponse
 */
export const zUpdateOngoingResponse = z.object({
    message: z.string(),
    updated_items: z.array(z.record(z.string(), z.unknown()))
});

export type UpdateOngoingResponseZodType = z.infer<typeof zUpdateOngoingResponse>;

/**
 * UploadLogsResponse
 */
export const zUploadLogsResponse = z.object({
    success: z.boolean(),
    url: z.url().min(1).max(2083).register(z.globalRegistry, {
        description: 'URL to the uploaded log file. 50M Filesize limit. 180 day retention.'
    })
});

export type UploadLogsResponseZodType = z.infer<typeof zUploadLogsResponse>;

/**
 * VFSStatsResponse
 */
export const zVfsStatsResponse = z.object({
    stats: z.record(z.string(), z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: 'VFS statistics'
    })
});

export type VfsStatsResponseZodType = z.infer<typeof zVfsStatsResponse>;

/**
 * EventResponse
 */
export const zRoutersSecureDefaultEventResponse = z.object({
    events: z.record(z.string(), z.array(z.int()))
});

export type RoutersSecureDefaultEventResponseZodType = z.infer<typeof zRoutersSecureDefaultEventResponse>;

/**
 * EventResponse
 */
export const zRoutersSecureStreamEventResponse = z.object({
    data: z.record(z.string(), z.unknown())
});

export type RoutersSecureStreamEventResponseZodType = z.infer<typeof zRoutersSecureStreamEventResponse>;

export const zRootData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type RootDataZodType = z.infer<typeof zRootData>;

/**
 * Successful Response
 */
export const zRootResponse2 = zRootResponse;

export type RootResponseZodType2 = z.infer<typeof zRootResponse2>;

export const zHealthData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type HealthDataZodType = z.infer<typeof zHealthData>;

/**
 * Successful Response
 */
export const zHealthResponse = zMessageResponse;

export type HealthResponseZodType = z.infer<typeof zHealthResponse>;

export const zDownloadUserInfoData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type DownloadUserInfoDataZodType = z.infer<typeof zDownloadUserInfoData>;

/**
 * Successful Response
 */
export const zDownloadUserInfoResponse = zDownloaderUserInfoResponse;

export type DownloadUserInfoResponseZodType = z.infer<typeof zDownloadUserInfoResponse>;

export const zGenerateapikeyData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type GenerateapikeyDataZodType = z.infer<typeof zGenerateapikeyData>;

/**
 * Successful Response
 */
export const zGenerateapikeyResponse = zMessageResponse;

export type GenerateapikeyResponseZodType = z.infer<typeof zGenerateapikeyResponse>;

export const zServicesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type ServicesDataZodType = z.infer<typeof zServicesData>;

/**
 * Response Services
 * Successful Response
 */
export const zServicesResponse = z.record(z.string(), z.boolean()).register(z.globalRegistry, {
    description: 'Successful Response'
});

export type ServicesResponseZodType = z.infer<typeof zServicesResponse>;

export const zTraktOauthInitiateData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type TraktOauthInitiateDataZodType = z.infer<typeof zTraktOauthInitiateData>;

/**
 * Successful Response
 */
export const zTraktOauthInitiateResponse = zTraktOAuthInitiateResponse;

export type TraktOauthInitiateResponseZodType = z.infer<typeof zTraktOauthInitiateResponse>;

export const zTraktOauthCallbackData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        code: z.string()
    })
});

export type TraktOauthCallbackDataZodType = z.infer<typeof zTraktOauthCallbackData>;

/**
 * Successful Response
 */
export const zTraktOauthCallbackResponse = zMessageResponse;

export type TraktOauthCallbackResponseZodType = z.infer<typeof zTraktOauthCallbackResponse>;

export const zStatsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type StatsDataZodType = z.infer<typeof zStatsData>;

/**
 * Successful Response
 */
export const zStatsResponse2 = zStatsResponse;

export type StatsResponseZodType2 = z.infer<typeof zStatsResponse2>;

export const zLogsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type LogsDataZodType = z.infer<typeof zLogsData>;

/**
 * Successful Response
 */
export const zLogsResponse2 = zLogsResponse;

export type LogsResponseZodType2 = z.infer<typeof zLogsResponse2>;

export const zEventsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type EventsDataZodType = z.infer<typeof zEventsData>;

/**
 * Successful Response
 */
export const zEventsResponse = zRoutersSecureDefaultEventResponse;

export type EventsResponseZodType = z.infer<typeof zEventsResponse>;

export const zMountData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type MountDataZodType = z.infer<typeof zMountData>;

/**
 * Successful Response
 */
export const zMountResponse2 = zMountResponse;

export type MountResponseZodType2 = z.infer<typeof zMountResponse2>;

export const zUploadLogsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type UploadLogsDataZodType = z.infer<typeof zUploadLogsData>;

/**
 * Successful Response
 */
export const zUploadLogsResponse2 = zUploadLogsResponse;

export type UploadLogsResponseZodType2 = z.infer<typeof zUploadLogsResponse2>;

export const zFetchCalendarData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type FetchCalendarDataZodType = z.infer<typeof zFetchCalendarData>;

/**
 * Successful Response
 */
export const zFetchCalendarResponse = zCalendarResponse;

export type FetchCalendarResponseZodType = z.infer<typeof zFetchCalendarResponse>;

export const zGetVfsStatsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type GetVfsStatsDataZodType = z.infer<typeof zGetVfsStatsData>;

/**
 * Successful Response
 */
export const zGetVfsStatsResponse = zVfsStatsResponse;

export type GetVfsStatsResponseZodType = z.infer<typeof zGetVfsStatsResponse>;

export const zGetStatesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type GetStatesDataZodType = z.infer<typeof zGetStatesData>;

/**
 * Successful Response
 */
export const zGetStatesResponse = zStateResponse;

export type GetStatesResponseZodType = z.infer<typeof zGetStatesResponse>;

export const zGetItemsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        limit: z.optional(z.int().gt(0).register(z.globalRegistry, {
            description: 'Number of items per page'
        })).default(50),
        page: z.optional(z.int().gt(0).register(z.globalRegistry, {
            description: 'Page number'
        })).default(1),
        type: z.optional(z.union([
            z.array(zMediaTypeEnum),
            z.null()
        ])),
        states: z.optional(z.union([
            z.array(z.union([
                zStates,
                zStatesFilter
            ])),
            z.null()
        ])),
        sort: z.optional(z.union([
            z.array(zSortOrderEnum),
            z.null()
        ])),
        search: z.optional(z.union([
            z.string().min(1),
            z.null()
        ])),
        extended: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Include extended item details'
        })).default(false)
    }))
});

export type GetItemsDataZodType = z.infer<typeof zGetItemsData>;

/**
 * Successful Response
 */
export const zGetItemsResponse = zItemsResponse;

export type GetItemsResponseZodType = z.infer<typeof zGetItemsResponse>;

export const zAddItemsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        tmdb_ids: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        tvdb_ids: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        media_type: z.optional(z.union([
            z.enum([
                'movie',
                'tv'
            ]),
            z.null()
        ]))
    }))
});

export type AddItemsDataZodType = z.infer<typeof zAddItemsData>;

/**
 * Successful Response
 */
export const zAddItemsResponse = zMessageResponse;

export type AddItemsResponseZodType = z.infer<typeof zAddItemsResponse>;

export const zGetItemData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.object({
        media_type: z.optional(z.enum([
            'movie',
            'tv',
            'item'
        ])),
        extended: z.optional(z.union([
            z.boolean(),
            z.null()
        ]))
    }))
});

export type GetItemDataZodType = z.infer<typeof zGetItemData>;

/**
 * Response Get Item
 * Successful Response
 */
export const zGetItemResponse = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: 'Successful Response'
});

export type GetItemResponseZodType = z.infer<typeof zGetItemResponse>;

export const zResetItemsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        ids: z.string()
    })
});

export type ResetItemsDataZodType = z.infer<typeof zResetItemsData>;

/**
 * Successful Response
 */
export const zResetItemsResponse = zResetResponse;

export type ResetItemsResponseZodType = z.infer<typeof zResetItemsResponse>;

export const zRetryItemsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        ids: z.string()
    })
});

export type RetryItemsDataZodType = z.infer<typeof zRetryItemsData>;

/**
 * Successful Response
 */
export const zRetryItemsResponse = zRetryResponse;

export type RetryItemsResponseZodType = z.infer<typeof zRetryItemsResponse>;

export const zRetryLibraryItemsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type RetryLibraryItemsDataZodType = z.infer<typeof zRetryLibraryItemsData>;

/**
 * Successful Response
 */
export const zRetryLibraryItemsResponse = zRetryResponse;

export type RetryLibraryItemsResponseZodType = z.infer<typeof zRetryLibraryItemsResponse>;

export const zUpdateOngoingItemsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type UpdateOngoingItemsDataZodType = z.infer<typeof zUpdateOngoingItemsData>;

/**
 * Successful Response
 */
export const zUpdateOngoingItemsResponse = zUpdateOngoingResponse;

export type UpdateOngoingItemsResponseZodType = z.infer<typeof zUpdateOngoingItemsResponse>;

export const zRemoveItemData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        ids: z.string()
    })
});

export type RemoveItemDataZodType = z.infer<typeof zRemoveItemData>;

/**
 * Successful Response
 */
export const zRemoveItemResponse = zRemoveResponse;

export type RemoveItemResponseZodType = z.infer<typeof zRemoveItemResponse>;

export const zGetItemStreamsApiV1ItemsItemIdStreamsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        item_id: z.int()
    }),
    query: z.optional(z.never())
});

export type GetItemStreamsApiV1ItemsItemIdStreamsGetDataZodType = z.infer<typeof zGetItemStreamsApiV1ItemsItemIdStreamsGetData>;

export const zBlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        item_id: z.int(),
        stream_id: z.int()
    }),
    query: z.optional(z.never())
});

export type BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostDataZodType = z.infer<typeof zBlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostData>;

export const zUnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        item_id: z.int(),
        stream_id: z.int()
    }),
    query: z.optional(z.never())
});

export type UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostDataZodType = z.infer<typeof zUnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostData>;

export const zResetItemStreamsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        item_id: z.int()
    }),
    query: z.optional(z.never())
});

export type ResetItemStreamsDataZodType = z.infer<typeof zResetItemStreamsData>;

export const zPauseItemsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        ids: z.string()
    })
});

export type PauseItemsDataZodType = z.infer<typeof zPauseItemsData>;

/**
 * Successful Response
 */
export const zPauseItemsResponse = zPauseResponse;

export type PauseItemsResponseZodType = z.infer<typeof zPauseItemsResponse>;

export const zUnpauseItemsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        ids: z.string()
    })
});

export type UnpauseItemsDataZodType = z.infer<typeof zUnpauseItemsData>;

/**
 * Successful Response
 */
export const zUnpauseItemsResponse = zPauseResponse;

export type UnpauseItemsResponseZodType = z.infer<typeof zUnpauseItemsResponse>;

export const zCompositeReindexerData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        item_id: z.optional(z.union([
            z.int(),
            z.null()
        ])),
        tvdb_id: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        tmdb_id: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        imdb_id: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    }))
});

export type CompositeReindexerDataZodType = z.infer<typeof zCompositeReindexerData>;

/**
 * Successful Response
 */
export const zCompositeReindexerResponse = zReindexResponse;

export type CompositeReindexerResponseZodType = z.infer<typeof zCompositeReindexerResponse>;

export const zGetItemAliasesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        item_id: z.int()
    }),
    query: z.optional(z.never())
});

export type GetItemAliasesDataZodType = z.infer<typeof zGetItemAliasesData>;

/**
 * Successful Response
 */
export const zGetItemAliasesResponse = zItemAliasesResponse;

export type GetItemAliasesResponseZodType = z.infer<typeof zGetItemAliasesResponse>;

export const zScrapeItemData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        item_id: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        tmdb_id: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        tvdb_id: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        imdb_id: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        media_type: z.optional(z.union([
            z.enum([
                'movie',
                'tv'
            ]),
            z.null()
        ]))
    }))
});

export type ScrapeItemDataZodType = z.infer<typeof zScrapeItemData>;

/**
 * Successful Response
 */
export const zScrapeItemResponse2 = zScrapeItemResponse;

export type ScrapeItemResponseZodType2 = z.infer<typeof zScrapeItemResponse2>;

export const zStartManualSessionData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        item_id: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        tmdb_id: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        tvdb_id: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        imdb_id: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        media_type: z.optional(z.union([
            z.enum([
                'movie',
                'tv'
            ]),
            z.null()
        ])),
        magnet: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    }))
});

export type StartManualSessionDataZodType = z.infer<typeof zStartManualSessionData>;

/**
 * Successful Response
 */
export const zStartManualSessionResponse = zStartSessionResponse;

export type StartManualSessionResponseZodType = z.infer<typeof zStartManualSessionResponse>;

export const zManualSelectData = z.object({
    body: zContainer,
    path: z.object({
        session_id: z.string()
    }),
    query: z.optional(z.never())
});

export type ManualSelectDataZodType = z.infer<typeof zManualSelectData>;

/**
 * Successful Response
 */
export const zManualSelectResponse = zSelectFilesResponse;

export type ManualSelectResponseZodType = z.infer<typeof zManualSelectResponse>;

export const zManualUpdateAttributesData = z.object({
    body: z.union([
        zDebridFile,
        zShowFileData
    ]),
    path: z.object({
        session_id: z.unknown()
    }),
    query: z.optional(z.never())
});

export type ManualUpdateAttributesDataZodType = z.infer<typeof zManualUpdateAttributesData>;

/**
 * Successful Response
 */
export const zManualUpdateAttributesResponse = zUpdateAttributesResponse;

export type ManualUpdateAttributesResponseZodType = z.infer<typeof zManualUpdateAttributesResponse>;

export const zAbortManualSessionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        session_id: z.string()
    }),
    query: z.optional(z.never())
});

export type AbortManualSessionDataZodType = z.infer<typeof zAbortManualSessionData>;

/**
 * Successful Response
 */
export const zAbortManualSessionResponse = zSessionResponse;

export type AbortManualSessionResponseZodType = z.infer<typeof zAbortManualSessionResponse>;

export const zCompleteManualSessionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        session_id: z.string()
    }),
    query: z.optional(z.never())
});

export type CompleteManualSessionDataZodType = z.infer<typeof zCompleteManualSessionData>;

/**
 * Successful Response
 */
export const zCompleteManualSessionResponse = zSessionResponse;

export type CompleteManualSessionResponseZodType = z.infer<typeof zCompleteManualSessionResponse>;

export const zParseTorrentTitlesData = z.object({
    body: z.array(z.string()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type ParseTorrentTitlesDataZodType = z.infer<typeof zParseTorrentTitlesData>;

/**
 * Successful Response
 */
export const zParseTorrentTitlesResponse = zParseTorrentTitleResponse;

export type ParseTorrentTitlesResponseZodType = z.infer<typeof zParseTorrentTitlesResponse>;

export const zFetchOverseerrRequestsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        filter: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        take: z.optional(z.int()).default(100000)
    }))
});

export type FetchOverseerrRequestsDataZodType = z.infer<typeof zFetchOverseerrRequestsData>;

/**
 * Successful Response
 */
export const zFetchOverseerrRequestsResponse = zMessageResponse;

export type FetchOverseerrRequestsResponseZodType = z.infer<typeof zFetchOverseerrRequestsResponse>;

export const zGetSettingsSchemaData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type GetSettingsSchemaDataZodType = z.infer<typeof zGetSettingsSchemaData>;

/**
 * Response Get Settings Schema
 * Successful Response
 */
export const zGetSettingsSchemaResponse = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: 'Successful Response'
});

export type GetSettingsSchemaResponseZodType = z.infer<typeof zGetSettingsSchemaResponse>;

export const zLoadSettingsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type LoadSettingsDataZodType = z.infer<typeof zLoadSettingsData>;

/**
 * Successful Response
 */
export const zLoadSettingsResponse = zMessageResponse;

export type LoadSettingsResponseZodType = z.infer<typeof zLoadSettingsResponse>;

export const zSaveSettingsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type SaveSettingsDataZodType = z.infer<typeof zSaveSettingsData>;

/**
 * Successful Response
 */
export const zSaveSettingsResponse = zMessageResponse;

export type SaveSettingsResponseZodType = z.infer<typeof zSaveSettingsResponse>;

export const zGetAllSettingsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type GetAllSettingsDataZodType = z.infer<typeof zGetAllSettingsData>;

/**
 * Successful Response
 */
export const zGetAllSettingsResponse = zAppModel;

export type GetAllSettingsResponseZodType = z.infer<typeof zGetAllSettingsResponse>;

export const zGetSettingsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        paths: z.string()
    }),
    query: z.optional(z.never())
});

export type GetSettingsDataZodType = z.infer<typeof zGetSettingsData>;

/**
 * Response Get Settings
 * Successful Response
 */
export const zGetSettingsResponse = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: 'Successful Response'
});

export type GetSettingsResponseZodType = z.infer<typeof zGetSettingsResponse>;

export const zSetAllSettingsData = z.object({
    body: z.record(z.string(), z.unknown()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type SetAllSettingsDataZodType = z.infer<typeof zSetAllSettingsData>;

/**
 * Successful Response
 */
export const zSetAllSettingsResponse = zMessageResponse;

export type SetAllSettingsResponseZodType = z.infer<typeof zSetAllSettingsResponse>;

export const zSetSettingsData = z.object({
    body: z.array(zSetSettings),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type SetSettingsDataZodType = z.infer<typeof zSetSettingsData>;

/**
 * Successful Response
 */
export const zSetSettingsResponse = zMessageResponse;

export type SetSettingsResponseZodType = z.infer<typeof zSetSettingsResponse>;

export const zOverseerrApiV1WebhookOverseerrPostData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type OverseerrApiV1WebhookOverseerrPostDataZodType = z.infer<typeof zOverseerrApiV1WebhookOverseerrPostData>;

/**
 * Response Overseerr Api V1 Webhook Overseerr Post
 * Successful Response
 */
export const zOverseerrApiV1WebhookOverseerrPostResponse = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: 'Successful Response'
});

export type OverseerrApiV1WebhookOverseerrPostResponseZodType = z.infer<typeof zOverseerrApiV1WebhookOverseerrPostResponse>;

export const zGetEventTypesApiV1StreamEventTypesGetData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export type GetEventTypesApiV1StreamEventTypesGetDataZodType = z.infer<typeof zGetEventTypesApiV1StreamEventTypesGetData>;

export const zStreamEventsApiV1StreamEventTypeGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        event_type: z.string()
    }),
    query: z.optional(z.never())
});

export type StreamEventsApiV1StreamEventTypeGetDataZodType = z.infer<typeof zStreamEventsApiV1StreamEventTypeGetData>;

/**
 * Successful Response
 */
export const zStreamEventsApiV1StreamEventTypeGetResponse = zRoutersSecureStreamEventResponse;

export type StreamEventsApiV1StreamEventTypeGetResponseZodType = z.infer<typeof zStreamEventsApiV1StreamEventTypeGetResponse>;