// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from './client';
import type { RootData, RootResponses, HealthData, HealthResponses, HealthErrors, DownloadUserInfoData, DownloadUserInfoResponses, DownloadUserInfoErrors, GenerateapikeyData, GenerateapikeyResponses, GenerateapikeyErrors, ServicesData, ServicesResponses, ServicesErrors, TraktOauthInitiateData, TraktOauthInitiateResponses, TraktOauthInitiateErrors, TraktOauthCallbackData, TraktOauthCallbackResponses, TraktOauthCallbackErrors, StatsData, StatsResponses, StatsErrors, LogsData, LogsResponses, LogsErrors, EventsData, EventsResponses, EventsErrors, MountData, MountResponses, MountErrors, UploadLogsData, UploadLogsResponses, UploadLogsErrors, FetchCalendarData, FetchCalendarResponses, FetchCalendarErrors, GetVfsStatsData, GetVfsStatsResponses, GetVfsStatsErrors, GetStatesData, GetStatesResponses, GetStatesErrors, GetItemsData, GetItemsResponses, GetItemsErrors, AddItemsData, AddItemsResponses, AddItemsErrors, GetItemData, GetItemResponses, GetItemErrors, ResetItemsData, ResetItemsResponses, ResetItemsErrors, RetryItemsData, RetryItemsResponses, RetryItemsErrors, RetryLibraryItemsData, RetryLibraryItemsResponses, RetryLibraryItemsErrors, UpdateOngoingItemsData, UpdateOngoingItemsResponses, UpdateOngoingItemsErrors, RemoveItemData, RemoveItemResponses, RemoveItemErrors, GetItemStreamsApiV1ItemsItemIdStreamsGetData, GetItemStreamsApiV1ItemsItemIdStreamsGetResponses, GetItemStreamsApiV1ItemsItemIdStreamsGetErrors, BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostData, BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostResponses, BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostErrors, UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostData, UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostResponses, UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostErrors, ResetItemStreamsData, ResetItemStreamsResponses, ResetItemStreamsErrors, PauseItemsData, PauseItemsResponses, PauseItemsErrors, UnpauseItemsData, UnpauseItemsResponses, UnpauseItemsErrors, CompositeReindexerData, CompositeReindexerResponses, CompositeReindexerErrors, GetItemAliasesData, GetItemAliasesResponses, GetItemAliasesErrors, GetItemMetadataData, GetItemMetadataResponses, GetItemMetadataErrors, ScrapeItemData, ScrapeItemResponses, ScrapeItemErrors, StartManualSessionData, StartManualSessionResponses, StartManualSessionErrors, ManualSelectData, ManualSelectResponses, ManualSelectErrors, ManualUpdateAttributesData, ManualUpdateAttributesResponses, ManualUpdateAttributesErrors, AbortManualSessionData, AbortManualSessionResponses, AbortManualSessionErrors, CompleteManualSessionData, CompleteManualSessionResponses, CompleteManualSessionErrors, ParseTorrentTitlesData, ParseTorrentTitlesResponses, ParseTorrentTitlesErrors, FetchOverseerrRequestsData, FetchOverseerrRequestsResponses, FetchOverseerrRequestsErrors, GetSettingsSchemaData, GetSettingsSchemaResponses, GetSettingsSchemaErrors, LoadSettingsData, LoadSettingsResponses, LoadSettingsErrors, SaveSettingsData, SaveSettingsResponses, SaveSettingsErrors, GetAllSettingsData, GetAllSettingsResponses, GetAllSettingsErrors, GetSettingsData, GetSettingsResponses, GetSettingsErrors, SetAllSettingsData, SetAllSettingsResponses, SetAllSettingsErrors, SetSettingsData, SetSettingsResponses, SetSettingsErrors, OverseerrApiV1WebhookOverseerrPostData, OverseerrApiV1WebhookOverseerrPostResponses, OverseerrApiV1WebhookOverseerrPostErrors, GetEventTypesApiV1StreamEventTypesGetData, GetEventTypesApiV1StreamEventTypesGetResponses, GetEventTypesApiV1StreamEventTypesGetErrors, StreamEventsApiV1StreamEventTypeGetData, StreamEventsApiV1StreamEventTypeGetResponses, StreamEventsApiV1StreamEventTypeGetErrors, AutoScrapeItemData } from './types.gen';
import { zRootData, zRootResponse2, zHealthData, zHealthResponse, zDownloadUserInfoData, zDownloadUserInfoResponse, zGenerateapikeyData, zGenerateapikeyResponse, zServicesData, zServicesResponse, zTraktOauthInitiateData, zTraktOauthInitiateResponse, zTraktOauthCallbackData, zTraktOauthCallbackResponse, zStatsData, zStatsResponse2, zLogsData, zLogsResponse2, zEventsData, zEventsResponse, zMountData, zMountResponse2, zUploadLogsData, zUploadLogsResponse2, zFetchCalendarData, zFetchCalendarResponse, zGetVfsStatsData, zGetVfsStatsResponse, zGetStatesData, zGetStatesResponse, zGetItemsData, zGetItemsResponse, zAddItemsData, zAddItemsResponse, zGetItemData, zGetItemResponse, zResetItemsData, zResetItemsResponse, zRetryItemsData, zRetryItemsResponse, zRetryLibraryItemsData, zRetryLibraryItemsResponse, zUpdateOngoingItemsData, zUpdateOngoingItemsResponse, zRemoveItemData, zRemoveItemResponse, zGetItemStreamsApiV1ItemsItemIdStreamsGetData, zBlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostData, zUnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostData, zResetItemStreamsData, zPauseItemsData, zPauseItemsResponse, zUnpauseItemsData, zUnpauseItemsResponse, zCompositeReindexerData, zCompositeReindexerResponse, zGetItemAliasesData, zGetItemAliasesResponse, zGetItemMetadataData, zGetItemMetadataResponse, zScrapeItemData, zScrapeItemResponse2, zStartManualSessionData, zStartManualSessionResponse, zManualSelectData, zManualSelectResponse, zManualUpdateAttributesData, zManualUpdateAttributesResponse, zAbortManualSessionData, zAbortManualSessionResponse, zCompleteManualSessionData, zCompleteManualSessionResponse, zParseTorrentTitlesData, zParseTorrentTitlesResponse, zFetchOverseerrRequestsData, zFetchOverseerrRequestsResponse, zGetSettingsSchemaData, zGetSettingsSchemaResponse, zLoadSettingsData, zLoadSettingsResponse, zSaveSettingsData, zSaveSettingsResponse, zGetAllSettingsData, zGetAllSettingsResponse, zGetSettingsData, zGetSettingsResponse, zSetAllSettingsData, zSetAllSettingsResponse, zSetSettingsData, zSetSettingsResponse, zOverseerrApiV1WebhookOverseerrPostData, zOverseerrApiV1WebhookOverseerrPostResponse, zGetEventTypesApiV1StreamEventTypesGetData, zStreamEventsApiV1StreamEventTypeGetData, zStreamEventsApiV1StreamEventTypeGetResponse } from './zod.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Root
 */
export const root = <ThrowOnError extends boolean = false>(options?: Options<RootData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<RootResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zRootData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zRootResponse2.parseAsync(data);
        },
        url: '/api/v1/',
        ...options
    });
};

/**
 * Health
 */
export const health = <ThrowOnError extends boolean = false>(options?: Options<HealthData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<HealthResponses, HealthErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zHealthData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zHealthResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/health',
        ...options
    });
};

/**
 * Download User Info
 * Get normalized user information from all initialized downloader services.
 *
 * Returns user info including premium status, expiration, and service-specific details
 * for all active downloader services (Real-Debrid, Debrid-Link, AllDebrid, etc.)
 */
export const downloadUserInfo = <ThrowOnError extends boolean = false>(options?: Options<DownloadUserInfoData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<DownloadUserInfoResponses, DownloadUserInfoErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDownloadUserInfoData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zDownloadUserInfoResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/downloader_user_info',
        ...options
    });
};

/**
 * Generate Apikey
 */
export const generateapikey = <ThrowOnError extends boolean = false>(options?: Options<GenerateapikeyData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<GenerateapikeyResponses, GenerateapikeyErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGenerateapikeyData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGenerateapikeyResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/generateapikey',
        ...options
    });
};

/**
 * Get Services
 */
export const services = <ThrowOnError extends boolean = false>(options?: Options<ServicesData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ServicesResponses, ServicesErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zServicesData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zServicesResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/services',
        ...options
    });
};

/**
 * Initiate Trakt Oauth
 */
export const traktOauthInitiate = <ThrowOnError extends boolean = false>(options?: Options<TraktOauthInitiateData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<TraktOauthInitiateResponses, TraktOauthInitiateErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zTraktOauthInitiateData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zTraktOauthInitiateResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/trakt/oauth/initiate',
        ...options
    });
};

/**
 * Trakt Oauth Callback
 */
export const traktOauthCallback = <ThrowOnError extends boolean = false>(options: Options<TraktOauthCallbackData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<TraktOauthCallbackResponses, TraktOauthCallbackErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zTraktOauthCallbackData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zTraktOauthCallbackResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/trakt/oauth/callback',
        ...options
    });
};

/**
 * Get Stats
 * Produce aggregated statistics for the media library and its items.
 *
 * The response includes total counts for media items, movies, shows, seasons, and episodes; the total number of filesystem symlinks (determined by existence of FilesystemEntry records linked to movie or episode items); a mapping of each state to its item count; the number of incomplete items; and a mapping of incomplete item IDs to their scraped attempt counts.
 *
 * Returns:
 * StatsResponse: Aggregated statistics with keys `total_items`, `total_movies`, `total_shows`, `total_seasons`, `total_episodes`, `total_symlinks`, `incomplete_items`, `incomplete_retries`, and `states`.
 */
export const stats = <ThrowOnError extends boolean = false>(options?: Options<StatsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<StatsResponses, StatsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zStatsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zStatsResponse2.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/stats',
        ...options
    });
};

/**
 * Get Logs
 */
export const logs = <ThrowOnError extends boolean = false>(options?: Options<LogsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<LogsResponses, LogsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zLogsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zLogsResponse2.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/logs',
        ...options
    });
};

/**
 * Get Events
 */
export const events = <ThrowOnError extends boolean = false>(options?: Options<EventsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<EventsResponses, EventsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zEventsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zEventsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/events',
        ...options
    });
};

/**
 * Get Mount Files
 * Get all files in the Riven VFS mount.
 */
export const mount = <ThrowOnError extends boolean = false>(options?: Options<MountData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<MountResponses, MountErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zMountData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zMountResponse2.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/mount',
        ...options
    });
};

/**
 * Upload Logs
 * Upload the latest log file to paste.c-net.org
 */
export const uploadLogs = <ThrowOnError extends boolean = false>(options?: Options<UploadLogsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<UploadLogsResponses, UploadLogsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zUploadLogsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zUploadLogsResponse2.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/upload_logs',
        ...options
    });
};

/**
 * Fetch Calendar
 * Fetch the calendar of all the items in the library
 */
export const fetchCalendar = <ThrowOnError extends boolean = false>(options?: Options<FetchCalendarData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<FetchCalendarResponses, FetchCalendarErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zFetchCalendarData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zFetchCalendarResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/calendar',
        ...options
    });
};

/**
 * Get VFS Statistics
 * Get statistics about the VFS
 */
export const getVfsStats = <ThrowOnError extends boolean = false>(options?: Options<GetVfsStatsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetVfsStatsResponses, GetVfsStatsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetVfsStatsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetVfsStatsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/vfs_stats',
        ...options
    });
};

/**
 * Get States
 */
export const getStates = <ThrowOnError extends boolean = false>(options?: Options<GetStatesData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetStatesResponses, GetStatesErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetStatesData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetStatesResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/states',
        ...options
    });
};

/**
 * Search Media Items
 * Fetch media items with optional filters and pagination
 */
export const getItems = <ThrowOnError extends boolean = false>(options?: Options<GetItemsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetItemsResponses, GetItemsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetItemsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetItemsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items',
        ...options
    });
};

/**
 * Add Media Items
 * Add media items with bases on TMDB ID or TVDB ID,
 * you can add multiple IDs by comma separating them.
 */
export const addItems = <ThrowOnError extends boolean = false>(options?: Options<AddItemsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<AddItemsResponses, AddItemsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zAddItemsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zAddItemsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/add',
        ...options
    });
};

/**
 * Get Media Item by ID
 * Fetch a single media item by TMDB ID, TVDB ID or item ID. TMDB and TVDB IDs are strings, item ID is an integer.
 */
export const getItem = <ThrowOnError extends boolean = false>(options: Options<GetItemData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetItemResponses, GetItemErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetItemData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetItemResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/{id}',
        ...options
    });
};

/**
 * Reset Media Items
 * Reset media items with bases on item IDs
 */
export const resetItems = <ThrowOnError extends boolean = false>(options: Options<ResetItemsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ResetItemsResponses, ResetItemsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zResetItemsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zResetItemsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/reset',
        ...options
    });
};

/**
 * Retry Media Items
 * Retry media items with bases on item IDs
 */
export const retryItems = <ThrowOnError extends boolean = false>(options: Options<RetryItemsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<RetryItemsResponses, RetryItemsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zRetryItemsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zRetryItemsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/retry',
        ...options
    });
};

/**
 * Retry Library Items
 * Retry items in the library that failed to download
 */
export const retryLibraryItems = <ThrowOnError extends boolean = false>(options?: Options<RetryLibraryItemsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<RetryLibraryItemsResponses, RetryLibraryItemsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zRetryLibraryItemsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zRetryLibraryItemsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/retry_library',
        ...options
    });
};

/**
 * Update Ongoing Items
 * Update state for ongoing and unreleased items
 */
export const updateOngoingItems = <ThrowOnError extends boolean = false>(options?: Options<UpdateOngoingItemsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<UpdateOngoingItemsResponses, UpdateOngoingItemsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zUpdateOngoingItemsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zUpdateOngoingItemsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/update_ongoing',
        ...options
    });
};

/**
 * Remove Media Items
 * Remove media items based on item IDs
 */
export const removeItem = <ThrowOnError extends boolean = false>(options: Options<RemoveItemData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<RemoveItemResponses, RemoveItemErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zRemoveItemData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zRemoveItemResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/remove',
        ...options
    });
};

/**
 * Get Item Streams
 */
export const getItemStreamsApiV1ItemsItemIdStreamsGet = <ThrowOnError extends boolean = false>(options: Options<GetItemStreamsApiV1ItemsItemIdStreamsGetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetItemStreamsApiV1ItemsItemIdStreamsGetResponses, GetItemStreamsApiV1ItemsItemIdStreamsGetErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetItemStreamsApiV1ItemsItemIdStreamsGetData.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/{item_id}/streams',
        ...options
    });
};

/**
 * Blacklist Stream
 */
export const blacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPost = <ThrowOnError extends boolean = false>(options: Options<BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostResponses, BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zBlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostData.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/{item_id}/streams/{stream_id}/blacklist',
        ...options
    });
};

/**
 * Unblacklist Stream
 */
export const unblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPost = <ThrowOnError extends boolean = false>(options: Options<UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostResponses, UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zUnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostData.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/{item_id}/streams/{stream_id}/unblacklist',
        ...options
    });
};

/**
 * Reset Media Item Streams
 * Reset all streams for a media item
 */
export const resetItemStreams = <ThrowOnError extends boolean = false>(options: Options<ResetItemStreamsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ResetItemStreamsResponses, ResetItemStreamsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zResetItemStreamsData.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/{item_id}/streams/reset',
        ...options
    });
};

/**
 * Pause Media Items
 * Pause media items based on item IDs
 */
export const pauseItems = <ThrowOnError extends boolean = false>(options: Options<PauseItemsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PauseItemsResponses, PauseItemsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zPauseItemsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zPauseItemsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/pause',
        ...options
    });
};

/**
 * Unpause Media Items
 * Unpause media items based on item IDs
 */
export const unpauseItems = <ThrowOnError extends boolean = false>(options: Options<UnpauseItemsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<UnpauseItemsResponses, UnpauseItemsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zUnpauseItemsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zUnpauseItemsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/unpause',
        ...options
    });
};

/**
 * Reindex item to pick up new season & episode releases.
 * Submits an item to be re-indexed through the indexer to manually fix shows that don't have release dates. Only works for movies and shows. Requires item id as a parameter.
 */
export const compositeReindexer = <ThrowOnError extends boolean = false>(options?: Options<CompositeReindexerData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<CompositeReindexerResponses, CompositeReindexerErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zCompositeReindexerData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zCompositeReindexerResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/reindex',
        ...options
    });
};

/**
 * Get Media Item Aliases
 * Get aliases for a media item
 */
export const getItemAliases = <ThrowOnError extends boolean = false>(options: Options<GetItemAliasesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetItemAliasesResponses, GetItemAliasesErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetItemAliasesData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetItemAliasesResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/{item_id}/aliases',
        ...options
    });
};

/**
 * Get Media Item Metadata
 * Get metadata for a media item using item ID
 */
export const getItemMetadata = <ThrowOnError extends boolean = false>(options: Options<GetItemMetadataData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetItemMetadataResponses, GetItemMetadataErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetItemMetadataData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetItemMetadataResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/{item_id}/metadata',
        ...options
    });
};

/**
 * Get streams for an item
 * Get streams for an item by any supported ID (item_id, tmdb_id, tvdb_id, imdb_id)
 */
export const scrapeItem = <ThrowOnError extends boolean = false>(options?: Options<ScrapeItemData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ScrapeItemResponses, ScrapeItemErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zScrapeItemData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zScrapeItemResponse2.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/scrape',
        ...options
    });
};

/**
 * Start a manual scraping session
 */
export const startManualSession = <ThrowOnError extends boolean = false>(options?: Options<StartManualSessionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<StartManualSessionResponses, StartManualSessionErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zStartManualSessionData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zStartManualSessionResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/scrape/start_session',
        ...options
    });
};

/**
 * Select files for torrent id, for this to be instant it requires files to be one of /manual/instant_availability response containers
 */
export const manualSelect = <ThrowOnError extends boolean = false>(options: Options<ManualSelectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ManualSelectResponses, ManualSelectErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zManualSelectData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zManualSelectResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/scrape/select_files/{session_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Match container files to item
 * Apply selected file attributes from a scraping session to the referenced media item(s).
 *
 * Locate the media item referenced by the given scraping session, create or reuse a staging FilesystemEntry for the provided file data, attach the file as the item's active stream (or attach to matching episodes for TV items), persist the changes to the database, and enqueue post-processing events for affected items.
 *
 * Parameters:
 * session_id (str): Identifier of the scraping session containing item and torrent context.
 * data (DebridFile | ShowFileData): File metadata for a single movie (`DebridFile`) or a mapping of seasons/episodes to file metadata (`ShowFileData`) for TV content.
 *
 * Returns:
 * dict: A message indicating which item(s) were updated, including the item's log string.
 *
 * Raises:
 * HTTPException: 404 if the session or target item cannot be found; 500 if the session lacks an associated item ID.
 */
export const manualUpdateAttributes = <ThrowOnError extends boolean = false>(options: Options<ManualUpdateAttributesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ManualUpdateAttributesResponses, ManualUpdateAttributesErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zManualUpdateAttributesData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zManualUpdateAttributesResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/scrape/update_attributes/{session_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Abort a manual scraping session
 */
export const abortManualSession = <ThrowOnError extends boolean = false>(options: Options<AbortManualSessionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<AbortManualSessionResponses, AbortManualSessionErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zAbortManualSessionData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zAbortManualSessionResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/scrape/abort_session/{session_id}',
        ...options
    });
};

/**
 * Complete a manual scraping session
 */
export const completeManualSession = <ThrowOnError extends boolean = false>(options: Options<CompleteManualSessionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CompleteManualSessionResponses, CompleteManualSessionErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zCompleteManualSessionData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zCompleteManualSessionResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/scrape/complete_session/{session_id}',
        ...options
    });
};

/**
 * Parse an array of torrent titles
 */
export const parseTorrentTitles = <ThrowOnError extends boolean = false>(options: Options<ParseTorrentTitlesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ParseTorrentTitlesResponses, ParseTorrentTitlesErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zParseTorrentTitlesData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zParseTorrentTitlesResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/scrape/parse',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Fetch Overseerr Requests
 * Get all overseerr requests and make sure they exist in the database
 */
export const fetchOverseerrRequests = <ThrowOnError extends boolean = false>(options?: Options<FetchOverseerrRequestsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<FetchOverseerrRequestsResponses, FetchOverseerrRequestsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zFetchOverseerrRequestsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zFetchOverseerrRequestsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/scrape/overseerr/requests',
        ...options
    });
};

/**
 * Auto Scrape Item
 * Auto scrape an item with specific resolution overrides.
 */
export const autoScrapeItem = <ThrowOnError extends boolean = false>(options: Options<AutoScrapeItemData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ScrapeItemResponses, ScrapeItemErrors, ThrowOnError>({
        ...options,
        url: '/api/v1/scrape/auto',
    });
};

/**
 * Get Settings Schema
 * Get the JSON schema for the settings.
 */
export const getSettingsSchema = <ThrowOnError extends boolean = false>(options?: Options<GetSettingsSchemaData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetSettingsSchemaResponses, GetSettingsSchemaErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetSettingsSchemaData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetSettingsSchemaResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/settings/schema',
        ...options
    });
};

/**
 * Load Settings
 */
export const loadSettings = <ThrowOnError extends boolean = false>(options?: Options<LoadSettingsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<LoadSettingsResponses, LoadSettingsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zLoadSettingsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zLoadSettingsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/settings/load',
        ...options
    });
};

/**
 * Save Settings
 */
export const saveSettings = <ThrowOnError extends boolean = false>(options?: Options<SaveSettingsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<SaveSettingsResponses, SaveSettingsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zSaveSettingsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zSaveSettingsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/settings/save',
        ...options
    });
};

/**
 * Get All Settings
 */
export const getAllSettings = <ThrowOnError extends boolean = false>(options?: Options<GetAllSettingsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetAllSettingsResponses, GetAllSettingsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetAllSettingsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetAllSettingsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/settings/get/all',
        ...options
    });
};

/**
 * Get Settings
 */
export const getSettings = <ThrowOnError extends boolean = false>(options: Options<GetSettingsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetSettingsResponses, GetSettingsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetSettingsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetSettingsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/settings/get/{paths}',
        ...options
    });
};

/**
 * Set All Settings
 */
export const setAllSettings = <ThrowOnError extends boolean = false>(options: Options<SetAllSettingsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SetAllSettingsResponses, SetAllSettingsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zSetAllSettingsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zSetAllSettingsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/settings/set/all',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Set Settings
 */
export const setSettings = <ThrowOnError extends boolean = false>(options: Options<SetSettingsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SetSettingsResponses, SetSettingsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zSetSettingsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zSetSettingsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/settings/set',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Overseerr
 * Webhook for Overseerr
 */
export const overseerrApiV1WebhookOverseerrPost = <ThrowOnError extends boolean = false>(options?: Options<OverseerrApiV1WebhookOverseerrPostData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<OverseerrApiV1WebhookOverseerrPostResponses, OverseerrApiV1WebhookOverseerrPostErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zOverseerrApiV1WebhookOverseerrPostData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zOverseerrApiV1WebhookOverseerrPostResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/webhook/overseerr',
        ...options
    });
};

/**
 * Get Event Types
 */
export const getEventTypesApiV1StreamEventTypesGet = <ThrowOnError extends boolean = false>(options?: Options<GetEventTypesApiV1StreamEventTypesGetData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetEventTypesApiV1StreamEventTypesGetResponses, GetEventTypesApiV1StreamEventTypesGetErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetEventTypesApiV1StreamEventTypesGetData.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/stream/event_types',
        ...options
    });
};

/**
 * Stream Events
 */
export const streamEventsApiV1StreamEventTypeGet = <ThrowOnError extends boolean = false>(options: Options<StreamEventsApiV1StreamEventTypeGetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<StreamEventsApiV1StreamEventTypeGetResponses, StreamEventsApiV1StreamEventTypeGetErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zStreamEventsApiV1StreamEventTypeGetData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zStreamEventsApiV1StreamEventTypeGetResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/stream/{event_type}',
        ...options
    });
};