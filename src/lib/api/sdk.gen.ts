// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from './client';
import type { RootData, RootResponses, HealthData, HealthResponses, HealthErrors, RdData, RdResponses, RdErrors, GenerateapikeyData, GenerateapikeyResponses, GenerateapikeyErrors, ServicesData, ServicesResponses, ServicesErrors, TraktOauthInitiateData, TraktOauthInitiateResponses, TraktOauthInitiateErrors, TraktOauthCallbackData, TraktOauthCallbackResponses, TraktOauthCallbackErrors, StatsData, StatsResponses, StatsErrors, LogsData, LogsResponses, LogsErrors, EventsData, EventsResponses, EventsErrors, MountData, MountResponses, MountErrors, UploadLogsData, UploadLogsResponses, UploadLogsErrors, FetchCalendarData, FetchCalendarResponses, FetchCalendarErrors, GetStatesData, GetStatesResponses, GetStatesErrors, GetItemsData, GetItemsResponses, GetItemsErrors, AddItemsData, AddItemsResponses, AddItemsErrors, GetItemData, GetItemResponses, GetItemErrors, GetItemsByImdbIdsData, GetItemsByImdbIdsResponses, GetItemsByImdbIdsErrors, ResetItemsData, ResetItemsResponses, ResetItemsErrors, RetryItemsData, RetryItemsResponses, RetryItemsErrors, RetryLibraryItemsData, RetryLibraryItemsResponses, RetryLibraryItemsErrors, UpdateOngoingItemsData, UpdateOngoingItemsResponses, UpdateOngoingItemsErrors, RepairSymlinksData, RepairSymlinksResponses, RepairSymlinksErrors, RemoveItemData, RemoveItemResponses, RemoveItemErrors, GetItemStreamsApiV1ItemsItemIdStreamsGetData, GetItemStreamsApiV1ItemsItemIdStreamsGetResponses, GetItemStreamsApiV1ItemsItemIdStreamsGetErrors, BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostData, BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostResponses, BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostErrors, UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostData, UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostResponses, UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostErrors, ResetItemStreamsData, ResetItemStreamsResponses, ResetItemStreamsErrors, PauseItemsData, PauseItemsResponses, PauseItemsErrors, UnpauseItemsData, UnpauseItemsResponses, UnpauseItemsErrors, TraktReindexerData, TraktReindexerResponses, TraktReindexerErrors, FfprobeMediaFilesData, FfprobeMediaFilesResponses, FfprobeMediaFilesErrors, ScrapeItemData, ScrapeItemResponses, ScrapeItemErrors, StartManualSessionData, StartManualSessionResponses, StartManualSessionErrors, ManualSelectData, ManualSelectResponses, ManualSelectErrors, ManualUpdateAttributesData, ManualUpdateAttributesResponses, ManualUpdateAttributesErrors, AbortManualSessionData, AbortManualSessionResponses, AbortManualSessionErrors, CompleteManualSessionData, CompleteManualSessionResponses, CompleteManualSessionErrors, ParseTorrentTitlesData, ParseTorrentTitlesResponses, ParseTorrentTitlesErrors, GetSettingsSchemaData, GetSettingsSchemaResponses, GetSettingsSchemaErrors, LoadSettingsData, LoadSettingsResponses, LoadSettingsErrors, SaveSettingsData, SaveSettingsResponses, SaveSettingsErrors, GetAllSettingsData, GetAllSettingsResponses, GetAllSettingsErrors, GetSettingsData, GetSettingsResponses, GetSettingsErrors, SetAllSettingsData, SetAllSettingsResponses, SetAllSettingsErrors, SetSettingsData, SetSettingsResponses, SetSettingsErrors, OverseerrApiV1WebhookOverseerrPostData, OverseerrApiV1WebhookOverseerrPostResponses, OverseerrApiV1WebhookOverseerrPostErrors, GetEventTypesApiV1StreamEventTypesGetData, GetEventTypesApiV1StreamEventTypesGetResponses, GetEventTypesApiV1StreamEventTypesGetErrors, StreamEventsApiV1StreamEventTypeGetData, StreamEventsApiV1StreamEventTypeGetResponses, StreamEventsApiV1StreamEventTypeGetErrors } from './types.gen';
import { zRootData, zRootResponse2, zHealthData, zHealthResponse, zRdData, zRdResponse, zGenerateapikeyData, zGenerateapikeyResponse, zServicesData, zServicesResponse, zTraktOauthInitiateData, zTraktOauthInitiateResponse, zTraktOauthCallbackData, zTraktOauthCallbackResponse, zStatsData, zStatsResponse2, zLogsData, zLogsResponse2, zEventsData, zEventsResponse, zMountData, zMountResponse2, zUploadLogsData, zUploadLogsResponse2, zFetchCalendarData, zFetchCalendarResponse, zGetStatesData, zGetStatesResponse, zGetItemsData, zGetItemsResponse, zAddItemsData, zAddItemsResponse, zGetItemData, zGetItemResponse, zGetItemsByImdbIdsData, zGetItemsByImdbIdsResponse, zResetItemsData, zResetItemsResponse, zRetryItemsData, zRetryItemsResponse, zRetryLibraryItemsData, zRetryLibraryItemsResponse, zUpdateOngoingItemsData, zUpdateOngoingItemsResponse, zRepairSymlinksData, zRepairSymlinksResponse2, zRemoveItemData, zRemoveItemResponse, zGetItemStreamsApiV1ItemsItemIdStreamsGetData, zBlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostData, zUnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostData, zResetItemStreamsData, zPauseItemsData, zPauseItemsResponse, zUnpauseItemsData, zUnpauseItemsResponse, zTraktReindexerData, zTraktReindexerResponse, zFfprobeMediaFilesData, zFfprobeMediaFilesResponse, zScrapeItemData, zScrapeItemResponse2, zStartManualSessionData, zStartManualSessionResponse, zManualSelectData, zManualSelectResponse, zManualUpdateAttributesData, zManualUpdateAttributesResponse, zAbortManualSessionData, zAbortManualSessionResponse, zCompleteManualSessionData, zCompleteManualSessionResponse, zParseTorrentTitlesData, zParseTorrentTitlesResponse, zGetSettingsSchemaData, zGetSettingsSchemaResponse, zLoadSettingsData, zLoadSettingsResponse, zSaveSettingsData, zSaveSettingsResponse, zGetAllSettingsData, zGetAllSettingsResponse, zGetSettingsData, zGetSettingsResponse, zSetAllSettingsData, zSetAllSettingsResponse, zSetSettingsData, zSetSettingsResponse, zOverseerrApiV1WebhookOverseerrPostData, zOverseerrApiV1WebhookOverseerrPostResponse, zGetEventTypesApiV1StreamEventTypesGetData, zStreamEventsApiV1StreamEventTypeGetData, zStreamEventsApiV1StreamEventTypeGetResponse } from './zod.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Root
 */
export const root = <ThrowOnError extends boolean = false>(options?: Options<RootData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<RootResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zRootData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zRootResponse2.parseAsync(data);
        },
        url: '/api/v1/',
        ...options
    });
};

/**
 * Health
 */
export const health = <ThrowOnError extends boolean = false>(options?: Options<HealthData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<HealthResponses, HealthErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zHealthData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zHealthResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/health',
        ...options
    });
};

/**
 * Get Rd User
 */
export const rd = <ThrowOnError extends boolean = false>(options?: Options<RdData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<RdResponses, RdErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zRdData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zRdResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/rd',
        ...options
    });
};

/**
 * Generate Apikey
 */
export const generateapikey = <ThrowOnError extends boolean = false>(options?: Options<GenerateapikeyData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<GenerateapikeyResponses, GenerateapikeyErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGenerateapikeyData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGenerateapikeyResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/generateapikey',
        ...options
    });
};

/**
 * Get Services
 */
export const services = <ThrowOnError extends boolean = false>(options?: Options<ServicesData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ServicesResponses, ServicesErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zServicesData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zServicesResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/services',
        ...options
    });
};

/**
 * Initiate Trakt Oauth
 */
export const traktOauthInitiate = <ThrowOnError extends boolean = false>(options?: Options<TraktOauthInitiateData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<TraktOauthInitiateResponses, TraktOauthInitiateErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zTraktOauthInitiateData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zTraktOauthInitiateResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/trakt/oauth/initiate',
        ...options
    });
};

/**
 * Trakt Oauth Callback
 */
export const traktOauthCallback = <ThrowOnError extends boolean = false>(options: Options<TraktOauthCallbackData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<TraktOauthCallbackResponses, TraktOauthCallbackErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zTraktOauthCallbackData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zTraktOauthCallbackResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/trakt/oauth/callback',
        ...options
    });
};

/**
 * Get Stats
 */
export const stats = <ThrowOnError extends boolean = false>(options?: Options<StatsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<StatsResponses, StatsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zStatsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zStatsResponse2.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/stats',
        ...options
    });
};

/**
 * Get Logs
 */
export const logs = <ThrowOnError extends boolean = false>(options?: Options<LogsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<LogsResponses, LogsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zLogsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zLogsResponse2.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/logs',
        ...options
    });
};

/**
 * Get Events
 */
export const events = <ThrowOnError extends boolean = false>(options?: Options<EventsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<EventsResponses, EventsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zEventsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zEventsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/events',
        ...options
    });
};

/**
 * Get Rclone Files
 * Get all files in the rclone mount.
 */
export const mount = <ThrowOnError extends boolean = false>(options?: Options<MountData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<MountResponses, MountErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zMountData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zMountResponse2.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/mount',
        ...options
    });
};

/**
 * Upload Logs
 * Upload the latest log file to paste.c-net.org
 */
export const uploadLogs = <ThrowOnError extends boolean = false>(options?: Options<UploadLogsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<UploadLogsResponses, UploadLogsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zUploadLogsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zUploadLogsResponse2.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/upload_logs',
        ...options
    });
};

/**
 * Fetch Calendar
 * Fetch the calendar of all the items in the library
 */
export const fetchCalendar = <ThrowOnError extends boolean = false>(options?: Options<FetchCalendarData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<FetchCalendarResponses, FetchCalendarErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zFetchCalendarData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zFetchCalendarResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/calendar',
        ...options
    });
};

/**
 * Get States
 */
export const getStates = <ThrowOnError extends boolean = false>(options?: Options<GetStatesData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetStatesResponses, GetStatesErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetStatesData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetStatesResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/states',
        ...options
    });
};

/**
 * Retrieve Media Items
 * Fetch media items with optional filters and pagination
 */
export const getItems = <ThrowOnError extends boolean = false>(options?: Options<GetItemsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetItemsResponses, GetItemsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetItemsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetItemsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items',
        ...options
    });
};

/**
 * Add Media Items
 * Add media items with bases on imdb IDs
 */
export const addItems = <ThrowOnError extends boolean = false>(options?: Options<AddItemsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<AddItemsResponses, AddItemsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zAddItemsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zAddItemsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/add',
        ...options
    });
};

/**
 * Retrieve Media Item
 * Fetch a single media item by ID
 */
export const getItem = <ThrowOnError extends boolean = false>(options: Options<GetItemData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetItemResponses, GetItemErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetItemData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetItemResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/{id}',
        ...options
    });
};

/**
 * Retrieve Media Items By IMDb IDs
 * Fetch media items by IMDb IDs
 */
export const getItemsByImdbIds = <ThrowOnError extends boolean = false>(options: Options<GetItemsByImdbIdsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetItemsByImdbIdsResponses, GetItemsByImdbIdsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetItemsByImdbIdsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetItemsByImdbIdsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/imdb/{imdb_ids}',
        ...options
    });
};

/**
 * Reset Media Items
 * Reset media items with bases on item IDs
 */
export const resetItems = <ThrowOnError extends boolean = false>(options: Options<ResetItemsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ResetItemsResponses, ResetItemsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zResetItemsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zResetItemsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/reset',
        ...options
    });
};

/**
 * Retry Media Items
 * Retry media items with bases on item IDs
 */
export const retryItems = <ThrowOnError extends boolean = false>(options: Options<RetryItemsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<RetryItemsResponses, RetryItemsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zRetryItemsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zRetryItemsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/retry',
        ...options
    });
};

/**
 * Retry Library Items
 * Retry items in the library that failed to download
 */
export const retryLibraryItems = <ThrowOnError extends boolean = false>(options?: Options<RetryLibraryItemsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<RetryLibraryItemsResponses, RetryLibraryItemsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zRetryLibraryItemsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zRetryLibraryItemsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/retry_library',
        ...options
    });
};

/**
 * Update Ongoing Items
 * Update state for ongoing and unreleased items
 */
export const updateOngoingItems = <ThrowOnError extends boolean = false>(options?: Options<UpdateOngoingItemsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<UpdateOngoingItemsResponses, UpdateOngoingItemsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zUpdateOngoingItemsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zUpdateOngoingItemsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/update_ongoing',
        ...options
    });
};

/**
 * Repair Broken Symlinks
 * Repair broken symlinks in the library. Optionally, provide a directory path to only scan that directory.
 */
export const repairSymlinks = <ThrowOnError extends boolean = false>(options?: Options<RepairSymlinksData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<RepairSymlinksResponses, RepairSymlinksErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zRepairSymlinksData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zRepairSymlinksResponse2.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/repair_symlinks',
        ...options
    });
};

/**
 * Remove Media Items
 * Remove media items based on item IDs
 */
export const removeItem = <ThrowOnError extends boolean = false>(options: Options<RemoveItemData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<RemoveItemResponses, RemoveItemErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zRemoveItemData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zRemoveItemResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/remove',
        ...options
    });
};

/**
 * Get Item Streams
 */
export const getItemStreamsApiV1ItemsItemIdStreamsGet = <ThrowOnError extends boolean = false>(options: Options<GetItemStreamsApiV1ItemsItemIdStreamsGetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetItemStreamsApiV1ItemsItemIdStreamsGetResponses, GetItemStreamsApiV1ItemsItemIdStreamsGetErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetItemStreamsApiV1ItemsItemIdStreamsGetData.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/{item_id}/streams',
        ...options
    });
};

/**
 * Blacklist Stream
 */
export const blacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPost = <ThrowOnError extends boolean = false>(options: Options<BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostResponses, BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zBlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostData.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/{item_id}/streams/{stream_id}/blacklist',
        ...options
    });
};

/**
 * Unblacklist Stream
 */
export const unblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPost = <ThrowOnError extends boolean = false>(options: Options<UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostResponses, UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zUnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostData.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/{item_id}/streams/{stream_id}/unblacklist',
        ...options
    });
};

/**
 * Reset Media Item Streams
 * Reset all streams for a media item
 */
export const resetItemStreams = <ThrowOnError extends boolean = false>(options: Options<ResetItemStreamsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ResetItemStreamsResponses, ResetItemStreamsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zResetItemStreamsData.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/{item_id}/streams/reset',
        ...options
    });
};

/**
 * Pause Media Items
 * Pause media items based on item IDs
 */
export const pauseItems = <ThrowOnError extends boolean = false>(options: Options<PauseItemsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PauseItemsResponses, PauseItemsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zPauseItemsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zPauseItemsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/pause',
        ...options
    });
};

/**
 * Unpause Media Items
 * Unpause media items based on item IDs
 */
export const unpauseItems = <ThrowOnError extends boolean = false>(options: Options<UnpauseItemsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<UnpauseItemsResponses, UnpauseItemsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zUnpauseItemsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zUnpauseItemsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/unpause',
        ...options
    });
};

/**
 * Reindex item with Trakt Indexer to pick up new season & episode releases.
 * Submits an item to be re-indexed through the indexer to manually fix shows that don't have release dates. Only works for movies and shows. Requires item id as a parameter.
 */
export const traktReindexer = <ThrowOnError extends boolean = false>(options?: Options<TraktReindexerData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<TraktReindexerResponses, TraktReindexerErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zTraktReindexerData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zTraktReindexerResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/reindex',
        ...options
    });
};

/**
 * Parse Media File
 * Parse a media file
 */
export const ffprobeMediaFiles = <ThrowOnError extends boolean = false>(options: Options<FfprobeMediaFilesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<FfprobeMediaFilesResponses, FfprobeMediaFilesErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zFfprobeMediaFilesData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zFfprobeMediaFilesResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/items/ffprobe',
        ...options
    });
};

/**
 * Get streams for an item
 * Get streams for an item
 */
export const scrapeItem = <ThrowOnError extends boolean = false>(options: Options<ScrapeItemData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ScrapeItemResponses, ScrapeItemErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zScrapeItemData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zScrapeItemResponse2.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/scrape/scrape/{id}',
        ...options
    });
};

/**
 * Start a manual scraping session
 */
export const startManualSession = <ThrowOnError extends boolean = false>(options: Options<StartManualSessionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<StartManualSessionResponses, StartManualSessionErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zStartManualSessionData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zStartManualSessionResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/scrape/scrape/start_session',
        ...options
    });
};

/**
 * Select files for torrent id, for this to be instant it requires files to be one of /manual/instant_availability response containers
 */
export const manualSelect = <ThrowOnError extends boolean = false>(options: Options<ManualSelectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ManualSelectResponses, ManualSelectErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zManualSelectData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zManualSelectResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/scrape/scrape/select_files/{session_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Match container files to item
 */
export const manualUpdateAttributes = <ThrowOnError extends boolean = false>(options: Options<ManualUpdateAttributesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ManualUpdateAttributesResponses, ManualUpdateAttributesErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zManualUpdateAttributesData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zManualUpdateAttributesResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/scrape/scrape/update_attributes/{session_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Abort a manual scraping session
 */
export const abortManualSession = <ThrowOnError extends boolean = false>(options: Options<AbortManualSessionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<AbortManualSessionResponses, AbortManualSessionErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zAbortManualSessionData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zAbortManualSessionResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/scrape/scrape/abort_session/{session_id}',
        ...options
    });
};

/**
 * Complete a manual scraping session
 */
export const completeManualSession = <ThrowOnError extends boolean = false>(options: Options<CompleteManualSessionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CompleteManualSessionResponses, CompleteManualSessionErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zCompleteManualSessionData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zCompleteManualSessionResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/scrape/scrape/complete_session/{session_id}',
        ...options
    });
};

/**
 * Parse an array of torrent titles
 */
export const parseTorrentTitles = <ThrowOnError extends boolean = false>(options: Options<ParseTorrentTitlesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ParseTorrentTitlesResponses, ParseTorrentTitlesErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zParseTorrentTitlesData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zParseTorrentTitlesResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/scrape/parse',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Settings Schema
 * Get the JSON schema for the settings.
 */
export const getSettingsSchema = <ThrowOnError extends boolean = false>(options?: Options<GetSettingsSchemaData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetSettingsSchemaResponses, GetSettingsSchemaErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetSettingsSchemaData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetSettingsSchemaResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/settings/schema',
        ...options
    });
};

/**
 * Load Settings
 */
export const loadSettings = <ThrowOnError extends boolean = false>(options?: Options<LoadSettingsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<LoadSettingsResponses, LoadSettingsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zLoadSettingsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zLoadSettingsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/settings/load',
        ...options
    });
};

/**
 * Save Settings
 */
export const saveSettings = <ThrowOnError extends boolean = false>(options?: Options<SaveSettingsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<SaveSettingsResponses, SaveSettingsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zSaveSettingsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zSaveSettingsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/settings/save',
        ...options
    });
};

/**
 * Get All Settings
 */
export const getAllSettings = <ThrowOnError extends boolean = false>(options?: Options<GetAllSettingsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetAllSettingsResponses, GetAllSettingsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetAllSettingsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetAllSettingsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/settings/get/all',
        ...options
    });
};

/**
 * Get Settings
 */
export const getSettings = <ThrowOnError extends boolean = false>(options: Options<GetSettingsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetSettingsResponses, GetSettingsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetSettingsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetSettingsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/settings/get/{paths}',
        ...options
    });
};

/**
 * Set All Settings
 */
export const setAllSettings = <ThrowOnError extends boolean = false>(options: Options<SetAllSettingsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SetAllSettingsResponses, SetAllSettingsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zSetAllSettingsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zSetAllSettingsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/settings/set/all',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Set Settings
 */
export const setSettings = <ThrowOnError extends boolean = false>(options: Options<SetSettingsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SetSettingsResponses, SetSettingsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zSetSettingsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zSetSettingsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/settings/set',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Overseerr
 * Webhook for Overseerr
 */
export const overseerrApiV1WebhookOverseerrPost = <ThrowOnError extends boolean = false>(options?: Options<OverseerrApiV1WebhookOverseerrPostData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<OverseerrApiV1WebhookOverseerrPostResponses, OverseerrApiV1WebhookOverseerrPostErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zOverseerrApiV1WebhookOverseerrPostData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zOverseerrApiV1WebhookOverseerrPostResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/webhook/overseerr',
        ...options
    });
};

/**
 * Get Event Types
 */
export const getEventTypesApiV1StreamEventTypesGet = <ThrowOnError extends boolean = false>(options?: Options<GetEventTypesApiV1StreamEventTypesGetData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetEventTypesApiV1StreamEventTypesGetResponses, GetEventTypesApiV1StreamEventTypesGetErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetEventTypesApiV1StreamEventTypesGetData.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/stream/event_types',
        ...options
    });
};

/**
 * Stream Events
 */
export const streamEventsApiV1StreamEventTypeGet = <ThrowOnError extends boolean = false>(options: Options<StreamEventsApiV1StreamEventTypeGetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<StreamEventsApiV1StreamEventTypeGetResponses, StreamEventsApiV1StreamEventTypeGetErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zStreamEventsApiV1StreamEventTypeGetData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zStreamEventsApiV1StreamEventTypeGetResponse.parseAsync(data);
        },
        security: [
            {
                name: 'x-api-key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/v1/stream/{event_type}',
        ...options
    });
};