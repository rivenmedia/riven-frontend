/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/api/v1/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Root */
        get: operations["root"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Health */
        get: operations["health"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/downloader_user_info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Download User Info
         * @description Get normalized user information from all initialized downloader services.
         *
         *     Returns user info including premium status, expiration, and service-specific details
         *     for all active downloader services (Real-Debrid, Debrid-Link, AllDebrid, etc.)
         */
        get: operations["download_user_info"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/generateapikey": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Generate Apikey */
        post: operations["generate_apikey"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/services": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Services */
        get: operations["services"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/trakt/oauth/initiate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Initiate Trakt Oauth */
        get: operations["trakt_oauth_initiate"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/trakt/oauth/callback": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Trakt Oauth Callback */
        get: operations["trakt_oauth_callback"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Stats
         * @description Produce aggregated statistics for the media library and its items.
         *
         *     The response includes total counts for media items, movies, shows, seasons, and episodes; the total number of filesystem symlinks (determined by existence of FilesystemEntry records linked to movie or episode items); a mapping of each state to its item count; the number of incomplete items; and a mapping of incomplete item IDs to their scraped attempt counts.
         *
         *     Returns:
         *         StatsResponse: Aggregated statistics with keys `total_items`, `total_movies`, `total_shows`, `total_seasons`, `total_episodes`, `total_symlinks`, `incomplete_items`, `incomplete_retries`, and `states`.
         */
        get: operations["stats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/logs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Logs */
        get: operations["logs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Events */
        get: operations["events"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/mount": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Mount Files
         * @description Get all files in the Riven VFS mount.
         */
        get: operations["mount"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/upload_logs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Upload Logs
         * @description Upload the latest log file to paste.c-net.org
         */
        post: operations["upload_logs"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/calendar": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Fetch Calendar
         * @description Fetch the calendar of all the items in the library
         */
        get: operations["fetch_calendar"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/vfs_stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get VFS Statistics
         * @description Get statistics about the VFS
         */
        get: operations["get_vfs_stats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/items/states": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get States */
        get: operations["get_states"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/items": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search Media Items
         * @description Fetch media items with optional filters and pagination
         */
        get: operations["get_items"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/items/add": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add Media Items
         * @description Add media items with bases on TMDB ID or TVDB ID,
         *             you can add multiple IDs by comma separating them.
         */
        post: operations["add_items"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/items/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Media Item by ID
         * @description Fetch a single media item by item ID
         */
        get: operations["get_item"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/items/reset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset Media Items
         * @description Reset media items with bases on item IDs
         */
        post: operations["reset_items"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/items/retry": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Retry Media Items
         * @description Retry media items with bases on item IDs
         */
        post: operations["retry_items"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/items/retry_library": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Retry Library Items
         * @description Retry items in the library that failed to download
         */
        post: operations["retry_library_items"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/items/remove": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Remove Media Items
         * @description Remove media items based on item IDs
         */
        delete: operations["remove_item"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/items/{item_id}/streams": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Media Item Streams
         * @description Get streams for a media item
         */
        get: operations["get_item_streams"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/items/{item_id}/streams/{stream_id}/blacklist": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Blacklist Media Item Stream
         * @description Blacklist a stream for a media item
         */
        post: operations["blacklist_item_stream"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/items/{item_id}/streams/{stream_id}/unblacklist": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Unblacklist Media Item Stream
         * @description Unblacklist a stream for a media item
         */
        post: operations["unblacklist_item_stream"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/items/{item_id}/streams/reset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset Media Item Streams
         * @description Reset all streams for a media item
         */
        post: operations["reset_item_streams"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/items/pause": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Pause Media Items
         * @description Pause media items based on item IDs
         */
        post: operations["pause_items"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/items/unpause": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Unpause Media Items
         * @description Unpause media items based on item IDs
         */
        post: operations["unpause_items"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/items/reindex": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reindex item to pick up new season & episode releases.
         * @description Submits an item to be re-indexed through the indexer to manually fix shows that don't have release dates.
         *             Only works for movies and shows. Requires item id as a parameter.
         */
        post: operations["composite_reindexer"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/items/{item_id}/aliases": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Media Item Aliases
         * @description Get aliases for a media item
         */
        get: operations["get_item_aliases"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/items/{item_id}/metadata": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Media Item Metadata
         * @description Get metadata for a media item using item ID
         */
        get: operations["get_item_metadata"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/scrape/scrape": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get streams for an item
         * @description Get streams for an item by any supported ID (item_id, tmdb_id, tvdb_id, imdb_id)
         */
        get: operations["scrape_item"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/scrape/scrape/start_session": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Start a manual scraping session */
        post: operations["start_manual_session"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/scrape/scrape/select_files/{session_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Select files for torrent id, for this to be instant it requires files to be one of /manual/instant_availability response containers */
        post: operations["manual_select"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/scrape/scrape/update_attributes/{session_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Match container files to item
         * @description Apply selected file attributes from a scraping session to the referenced media item(s).
         *
         *     Locate the media item referenced by the given scraping session, create or reuse a staging FilesystemEntry for the provided file data, attach the file as the item's active stream (or attach to matching episodes for TV items), persist the changes to the database, and enqueue post-processing events for affected items.
         *
         *     Parameters:
         *         session_id (str): Identifier of the scraping session containing item and torrent context.
         *         data (DebridFile | ShowFileData): File metadata for a single movie (`DebridFile`) or a mapping of seasons/episodes to file metadata (`ShowFileData`) for TV content.
         *
         *     Returns:
         *         dict: A message indicating which item(s) were updated, including the item's log string.
         *
         *     Raises:
         *         HTTPException: 404 if the session or target item cannot be found; 500 if the session lacks an associated item ID.
         */
        post: operations["manual_update_attributes"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/scrape/scrape/abort_session/{session_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Abort a manual scraping session */
        post: operations["abort_manual_session"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/scrape/scrape/complete_session/{session_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Complete a manual scraping session */
        post: operations["complete_manual_session"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/scrape/parse": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Parse an array of torrent titles */
        post: operations["parse_torrent_titles"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/scrape/overseerr/requests": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Fetch Overseerr Requests
         * @description Get all overseerr requests and make sure they exist in the database
         */
        post: operations["fetch_overseerr_requests"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/settings/schema": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Settings Schema
         * @description Get the JSON schema for the settings.
         */
        get: operations["get_settings_schema"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/settings/load": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Load Settings */
        get: operations["load_settings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/settings/save": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Save Settings */
        post: operations["save_settings"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/settings/get/all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get All Settings */
        get: operations["get_all_settings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/settings/get/{paths}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Settings */
        get: operations["get_settings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/settings/set/all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Set All Settings */
        post: operations["set_all_settings"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/settings/set": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Set Settings */
        post: operations["set_settings"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/webhook/overseerr": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Overseerr
         * @description Webhook for Overseerr
         */
        post: operations["overseerr_api_v1_webhook_overseerr_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/stream/event_types": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Event Types */
        get: operations["get_event_types_api_v1_stream_event_types_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/stream/{event_type}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Stream Events */
        get: operations["stream_events_api_v1_stream__event_type__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** AutoScrapeRequest */
        AutoScrapeRequest: {
            /** Item Id */
            item_id?: string | null;
            /** Tmdb Id */
            tmdb_id?: string | null;
            /** Tvdb Id */
            tvdb_id?: string | null;
            /** Imdb Id */
            imdb_id?: string | null;
            /**
             * Media Type
             * @enum {string}
             */
            media_type?: "movie" | "tv" | null;
            /** Resolutions */
            resolutions?: string[] | null;
            /** Quality */
            quality?: string[] | null;
            /** Rips */
            rips?: string[] | null;
            /** Hdr */
            hdr?: string[] | null;
            /** Audio */
            audio?: string[] | null;
            /** Extras */
            extras?: string[] | null;
            /** Trash */
            trash?: string[] | null;
            /** Require */
            require?: string[] | null;
            /** Exclude */
            exclude?: string[] | null;
        };
        /** AddMediaItemPayload */
        AddMediaItemPayload: {
            /**
             * Tmdb Ids
             * @description Comma-separated list of TMDB IDs
             */
            tmdb_ids?: string[] | null;
            /**
             * Tvdb Ids
             * @description Comma-separated list of TVDB IDs
             */
            tvdb_ids?: string[] | null;
            /**
             * Media Type
             * @description Media type
             * @enum {string}
             */
            media_type: "movie" | "tv";
        };
        /** AllDebridModel */
        AllDebridModel: {
            /**
             * Enabled
             * @description Enable AllDebrid
             * @default false
             */
            enabled: boolean;
            /**
             * Api Key
             * @description AllDebrid API key
             * @default
             */
            api_key: string;
        };
        /** AppModel */
        AppModel: {
            /**
             * Version
             * @description Application version
             */
            version?: string;
            /**
             * Api Key
             * @description API key for Riven API access
             * @default
             */
            api_key: string;
            /**
             * Log Level
             * @description Logging level
             * @default INFO
             * @enum {string}
             */
            log_level: "TRACE" | "DEBUG" | "INFO" | "WARNING" | "ERROR" | "CRITICAL";
            /**
             * Enable Network Tracing
             * @description Enable detailed network request/response logging
             * @default false
             */
            enable_network_tracing: boolean;
            /**
             * Enable Stream Tracing
             * @description Enable detailed stream request/response logging
             * @default false
             */
            enable_stream_tracing: boolean;
            /**
             * Retry Interval
             * @description Interval in seconds to retry failed library items (24 hours default, 0 to disable)
             * @default 86400
             */
            retry_interval: number;
            /**
             * Tracemalloc
             * @description Enable Python memory tracking (debug)
             * @default false
             */
            tracemalloc: boolean;
            /** @description Filesystem configuration */
            filesystem?: components["schemas"]["FilesystemModel"];
            /** @description Library updaters configuration */
            updaters?: components["schemas"]["UpdatersModel"];
            /** @description Downloader services configuration */
            downloaders?: components["schemas"]["DownloadersModel"];
            /** @description Content services configuration */
            content?: components["schemas"]["ContentModel"];
            /** @description Scraper configuration */
            scraping?: components["schemas"]["ScraperModel"];
            /** @description Result ranking configuration */
            ranking?: components["schemas"]["RTNSettingsModel"];
            /** @description Indexer configuration */
            indexer?: components["schemas"]["IndexerModel"];
            /** @description Database configuration */
            database?: components["schemas"]["DatabaseModel"];
            /** @description Notifications configuration */
            notifications?: components["schemas"]["NotificationsModel"];
            /** @description Post-processing configuration */
            post_processing?: components["schemas"]["PostProcessing"];
            /** @description Logging configuration */
            logging?: components["schemas"]["LoggingModel"];
            /** @description Stream configuration */
            stream?: components["schemas"]["StreamModel"];
        };
        /**
         * AudioMetadata
         * @description Audio track metadata
         */
        AudioMetadata: {
            /** Codec */
            codec?: string | null;
            /** Channels */
            channels?: number | null;
            /** Sample Rate */
            sample_rate?: number | null;
            /** Language */
            language?: string | null;
        };
        /**
         * AudioRankModel
         * @description Ranking configuration for audio attributes.
         */
        AudioRankModel: {
            aac?: components["schemas"]["CustomRank"];
            atmos?: components["schemas"]["CustomRank"];
            dolby_digital?: components["schemas"]["CustomRank"];
            dolby_digital_plus?: components["schemas"]["CustomRank"];
            dts_lossy?: components["schemas"]["CustomRank"];
            dts_lossless?: components["schemas"]["CustomRank"];
            flac?: components["schemas"]["CustomRank"];
            mono?: components["schemas"]["CustomRank"];
            mp3?: components["schemas"]["CustomRank"];
            stereo?: components["schemas"]["CustomRank"];
            surround?: components["schemas"]["CustomRank"];
            truehd?: components["schemas"]["CustomRank"];
        };
        /** CalendarResponse */
        CalendarResponse: {
            /**
             * Data
             * @description Dictionary with dates as keys and lists of media items as values
             */
            data: {
                [key: string]: {
                    [key: string]: unknown;
                };
            };
        };
        /** CometConfig */
        CometConfig: {
            /**
             * Enabled
             * @description Enable Comet scraper
             * @default false
             */
            enabled: boolean;
            /**
             * Url
             * @description Comet URL
             * @default http://localhost:8000
             */
            url: string;
            /**
             * Timeout
             * @description Request timeout in seconds
             * @default 30
             */
            timeout: number;
            /**
             * Retries
             * @description Number of retries for failed requests
             * @default 1
             */
            retries: number;
            /**
             * Ratelimit
             * @description Enable rate limiting
             * @default true
             */
            ratelimit: boolean;
        };
        /**
         * Container
         * @description Root model for container mapping file IDs to file information.
         *
         *     Example:
         *     {
         *         "4": {
         *             "filename": "show.s01e01.mkv",
         *             "filesize": 30791392598
         *         },
         *         "5": {
         *             "filename": "show.s01e02.mkv",
         *             "filesize": 25573181861
         *         }
         *     }
         */
        Container: {
            [key: string]: components["schemas"]["DebridFile"];
        };
        /** ContentModel */
        ContentModel: {
            /** @description Overseerr configuration */
            overseerr?: components["schemas"]["OverseerrModel"];
            /** @description Plex Watchlist configuration */
            plex_watchlist?: components["schemas"]["PlexWatchlistModel"];
            /** @description MDBList configuration */
            mdblist?: components["schemas"]["MdblistModel"];
            /** @description Listrr configuration */
            listrr?: components["schemas"]["ListrrModel"];
            /** @description Trakt configuration */
            trakt?: components["schemas"]["TraktModel"];
        };
        /**
         * CustomRank
         * @description Custom Ranks used in SettingsModel.
         */
        CustomRank: {
            /**
             * Fetch
             * @default true
             */
            fetch: boolean;
            /**
             * Use Custom Rank
             * @default false
             */
            use_custom_rank: boolean;
            /**
             * Rank
             * @default 0
             */
            rank: number;
        };
        /**
         * CustomRanksConfig
         * @description Configuration for custom ranks.
         */
        CustomRanksConfig: {
            quality?: components["schemas"]["QualityRankModel"];
            rips?: components["schemas"]["RipsRankModel"];
            hdr?: components["schemas"]["HdrRankModel"];
            audio?: components["schemas"]["AudioRankModel"];
            extras?: components["schemas"]["ExtrasRankModel"];
            trash?: components["schemas"]["TrashRankModel"];
        };
        /**
         * DataSource
         * @description Source of metadata
         * @enum {string}
         */
        DataSource: "parsed" | "probed" | "hybrid";
        /** DatabaseModel */
        DatabaseModel: {
            /**
             * Host
             * Format: multi-host-uri
             * @description Database connection string
             */
            host?: string;
        };
        /**
         * DebridFile
         * @description Represents a file from a debrid service
         */
        DebridFile: {
            /** File Id */
            file_id: number | null;
            /** Filename */
            filename: string;
            /** Filesize */
            filesize: number;
            /** Download Url */
            download_url?: string | null;
        };
        /** DebridLinkModel */
        DebridLinkModel: {
            /**
             * Enabled
             * @description Enable Debrid-Link
             * @default false
             */
            enabled: boolean;
            /**
             * Api Key
             * @description Debrid-Link API key
             * @default
             */
            api_key: string;
        };
        /**
         * DownloaderUserInfo
         * @description Normalized downloader user information response
         */
        DownloaderUserInfo: {
            /**
             * Service
             * @enum {string}
             */
            service: "realdebrid" | "alldebrid" | "debridlink";
            /** Username */
            username?: string | null;
            /** Email */
            email?: string | null;
            /** User Id */
            user_id: number | string;
            /**
             * Premium Status
             * @enum {string}
             */
            premium_status: "free" | "premium";
            /** Premium Expires At */
            premium_expires_at?: string | null;
            /** Premium Days Left */
            premium_days_left?: number | null;
            /** Points */
            points?: number | null;
            /** Total Downloaded Bytes */
            total_downloaded_bytes?: number | null;
            /** Cooldown Until */
            cooldown_until?: string | null;
        };
        /**
         * DownloaderUserInfoResponse
         * @description Response containing user info for all initialized downloader services
         */
        DownloaderUserInfoResponse: {
            /** Services */
            services: components["schemas"]["DownloaderUserInfo"][];
        };
        /** DownloadersModel */
        DownloadersModel: {
            /**
             * Video Extensions
             * @description list of video file extensions to consider for downloads
             */
            video_extensions?: string[];
            /**
             * Movie Filesize Mb Min
             * @description Minimum file size in MB for movies
             * @default 700
             */
            movie_filesize_mb_min: number;
            /**
             * Movie Filesize Mb Max
             * @description Maximum file size in MB for movies (-1 for no limit)
             * @default -1
             */
            movie_filesize_mb_max: number;
            /**
             * Episode Filesize Mb Min
             * @description Minimum file size in MB for episodes
             * @default 100
             */
            episode_filesize_mb_min: number;
            /**
             * Episode Filesize Mb Max
             * @description Maximum file size in MB for episodes (-1 for no limit)
             * @default -1
             */
            episode_filesize_mb_max: number;
            /**
             * Proxy Url
             * @description Proxy URL for downloaders (optional)
             * @default
             */
            proxy_url: string;
            /** @description Real-Debrid downloader configuration */
            real_debrid?: components["schemas"]["RealDebridModel"];
            /** @description Debrid-Link downloader configuration */
            debrid_link?: components["schemas"]["DebridLinkModel"];
            /** @description AllDebrid downloader configuration */
            all_debrid?: components["schemas"]["AllDebridModel"];
        };
        /** EmbyLibraryModel */
        EmbyLibraryModel: {
            /**
             * Enabled
             * @description Enable Emby library updates
             * @default false
             */
            enabled: boolean;
            /**
             * Api Key
             * @description Emby API key
             * @default
             */
            api_key: string;
            /**
             * Url
             * @description Emby server URL
             * @default http://localhost:8096
             */
            url: string;
        };
        /** EventResponse */
        EventResponse: {
            /** Events */
            events: {
                [key: string]: number[];
            };
        };
        /** EventTypesResponse */
        EventTypesResponse: {
            /** Event Types */
            event_types: string[];
        };
        /**
         * ExtrasRankModel
         * @description Ranking configuration for extras attributes.
         */
        ExtrasRankModel: {
            "3d"?: components["schemas"]["CustomRank"];
            converted?: components["schemas"]["CustomRank"];
            documentary?: components["schemas"]["CustomRank"];
            dubbed?: components["schemas"]["CustomRank"];
            edition?: components["schemas"]["CustomRank"];
            hardcoded?: components["schemas"]["CustomRank"];
            network?: components["schemas"]["CustomRank"];
            proper?: components["schemas"]["CustomRank"];
            repack?: components["schemas"]["CustomRank"];
            retail?: components["schemas"]["CustomRank"];
            site?: components["schemas"]["CustomRank"];
            subbed?: components["schemas"]["CustomRank"];
            upscaled?: components["schemas"]["CustomRank"];
            scene?: components["schemas"]["CustomRank"];
            uncensored?: components["schemas"]["CustomRank"];
        };
        /** FilesystemModel */
        FilesystemModel: {
            /**
             * Mount Path
             * Format: path
             * @description Path where Riven will mount the virtual filesystem
             * @default /path/to/riven/mount
             */
            mount_path: string;
            /**
             * Library Profiles
             * @description Library profiles for organizing media into different libraries based on metadata. An example profile is provided (disabled by default) - enable them or create your own. Each profile filters media by metadata (genres, ratings, etc.) and creates VFS paths. Media appears in all matching profile paths. Use '!' prefix in filter lists to exclude values (e.g., genres: ['action', '!horror'] = action movies but not horror).
             */
            library_profiles?: {
                [key: string]: components["schemas"]["LibraryProfile"];
            };
            /**
             * Cache Dir
             * Format: path
             * @description Directory for caching downloaded chunks
             * @default /dev/shm/riven-cache
             */
            cache_dir: string;
            /**
             * Cache Max Size Mb
             * @description Maximum cache size in MB (10 GiB default)
             * @default 10240
             */
            cache_max_size_mb: number;
            /**
             * Cache Ttl Seconds
             * @description Cache time-to-live in seconds (2 hours default)
             * @default 7200
             */
            cache_ttl_seconds: number;
            /**
             * Cache Eviction
             * @description Cache eviction policy (LRU or TTL)
             * @default LRU
             * @enum {string}
             */
            cache_eviction: "LRU" | "TTL";
            /**
             * Cache Metrics
             * @description Enable cache metrics logging
             * @default true
             */
            cache_metrics: boolean;
            /**
             * Movie Dir Template
             * @description Template for movie directory names. Available variables: title, year, tmdb_id, imdb_id, resolution, codec, hdr, audio, quality, is_remux, is_proper, is_repack, is_extended, is_directors_cut, container. Example: '{title} ({year})' or '{title} ({year}) [{resolution}]'
             * @default {title} ({year}) {{tmdb-{tmdb_id}}}
             */
            movie_dir_template: string;
            /**
             * Movie File Template
             * @description Template for movie file names (without extension). Available variables: title, year, tmdb_id, imdb_id, resolution, codec, hdr, audio, quality, remux, proper, repack, extended, directors_cut, edition (string flags, empty if false). Example: '{title} ({year})' or '{title} ({year}) {edition} [{resolution}] {remux}'
             * @default {title} ({year})
             */
            movie_file_template: string;
            /**
             * Show Dir Template
             * @description Template for show directory names. Available variables: title, year, tvdb_id, imdb_id. Example: '{title} ({year})' or '{title} ({year}) {{tvdb-{tvdb_id}}}'
             * @default {title} ({year}) {{tvdb-{tvdb_id}}}
             */
            show_dir_template: string;
            /**
             * Season Dir Template
             * @description Template for season directory names. Available variables: season (number), show (parent show data with [title], [year], [tvdb_id], [imdb_id]). Example: 'Season {season:02d}' or 'S{season:02d}' or '{show[title]} - Season {season}'
             * @default Season {season:02d}
             */
            season_dir_template: string;
            /**
             * Episode File Template
             * @description Template for episode file names (without extension). Available variables: title, season, episode, show (parent show data with [title], [year], [tvdb_id], [imdb_id]), resolution, codec, hdr, audio, quality, remux, proper, repack, extended, directors_cut, edition. Example: '{show[title]} - s{season:02d}e{episode:02d}' or 'S{season:02d}E{episode:02d} - {title}'. Multi-episode files automatically use range format (e.g., e01-05) based on episode number formatting.
             * @default {show[title]} - s{season:02d}e{episode:02d}
             */
            episode_file_template: string;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /**
         * HdrRankModel
         * @description Ranking configuration for HDR attributes.
         */
        HdrRankModel: {
            bit10?: components["schemas"]["CustomRank"];
            dolby_vision?: components["schemas"]["CustomRank"];
            hdr?: components["schemas"]["CustomRank"];
            hdr10plus?: components["schemas"]["CustomRank"];
            sdr?: components["schemas"]["CustomRank"];
        };
        /** IdListPayload */
        IdListPayload: {
            /**
             * Ids
             * @description List of IDs
             */
            ids: string[];
        };
        /** IndexerModel */
        IndexerModel: {
            /**
             * Schedule Offset Minutes
             * @description Offset in minutes after aired_at time to schedule scraping for episodes and movies (30 minutes default)
             * @default 30
             */
            schedule_offset_minutes: number;
        };
        /** ItemAliasesResponse */
        ItemAliasesResponse: {
            /**
             * Aliases
             * @description The item aliases
             */
            aliases: {
                [key: string]: string[];
            } | null;
        };
        /** ItemsResponse */
        ItemsResponse: {
            /**
             * Success
             * @description Boolean signifying whether the request was successful
             */
            success: boolean;
            /**
             * Items
             * @description The list of media items
             */
            items: {
                [key: string]: unknown;
            }[];
            /**
             * Page
             * @description Current page number
             */
            page: number;
            /**
             * Limit
             * @description Number of items per page
             */
            limit: number;
            /**
             * Total Items
             * @description Total number of items
             */
            total_items: number;
            /**
             * Total Pages
             * @description Total number of pages
             */
            total_pages: number;
        };
        /** JackettConfig */
        JackettConfig: {
            /**
             * Enabled
             * @description Enable Jackett scraper
             * @default false
             */
            enabled: boolean;
            /**
             * Url
             * @description Jackett URL
             * @default http://localhost:9117
             */
            url: string;
            /**
             * Api Key
             * @description Jackett API key
             * @default
             */
            api_key: string;
            /**
             * Timeout
             * @description Request timeout in seconds
             * @default 30
             */
            timeout: number;
            /**
             * Retries
             * @description Number of retries for failed requests
             * @default 1
             */
            retries: number;
            /**
             * Infohash Fetch Timeout
             * @description Timeout in seconds for parallel infohash fetching from URLs
             * @default 30
             */
            infohash_fetch_timeout: number;
            /**
             * Ratelimit
             * @description Enable rate limiting
             * @default true
             */
            ratelimit: boolean;
        };
        /** JellyfinLibraryModel */
        JellyfinLibraryModel: {
            /**
             * Enabled
             * @description Enable Jellyfin library updates
             * @default false
             */
            enabled: boolean;
            /**
             * Api Key
             * @description Jellyfin API key
             * @default
             */
            api_key: string;
            /**
             * Url
             * @description Jellyfin server URL
             * @default http://localhost:8096
             */
            url: string;
        };
        /**
         * LanguagesConfig
         * @description Configuration for which languages are enabled.
         */
        LanguagesConfig: {
            /**
             * Required
             * @default []
             */
            required: string[];
            /**
             * Exclude
             * @default []
             */
            exclude: string[];
            /**
             * Preferred
             * @default []
             */
            preferred: string[];
        };
        /**
         * LibraryProfile
         * @description Library profile configuration for organizing media into different libraries
         */
        LibraryProfile: {
            /**
             * Name
             * @description Human-readable profile name
             */
            name: string;
            /**
             * Library Path
             * @description VFS path prefix for this profile (e.g., '/kids', '/anime')
             */
            library_path: string;
            /**
             * Enabled
             * @description Enable this profile
             * @default true
             */
            enabled: boolean;
            /** @description Metadata filter rules for matching items */
            filter_rules?: components["schemas"]["LibraryProfileFilterRules"];
        };
        /**
         * LibraryProfileFilterRules
         * @description Filter rules for library profile matching (metadata-only)
         */
        LibraryProfileFilterRules: {
            /**
             * Content Types
             * @description Media types to include (movie, show). None/omit = all types
             */
            content_types?: string[] | null;
            /**
             * Genres
             * @description Genres to include/exclude. Prefix with '!' to exclude. Examples: ['action', 'adventure'] = include these genres, ['action', '!horror'] = include action but exclude horror. None/omit = no genre filter
             */
            genres?: string[] | null;
            /**
             * Exclude Genres
             * @description DEPRECATED: Use genres with '!' prefix instead. This field is kept for backward compatibility and will be auto-migrated.
             */
            exclude_genres?: string[] | null;
            /**
             * Min Year
             * @description Minimum release year. None/omit = no minimum
             */
            min_year?: number | null;
            /**
             * Max Year
             * @description Maximum release year. None/omit = no maximum
             */
            max_year?: number | null;
            /**
             * Is Anime
             * @description Filter by anime flag. None/omit = no anime filter
             */
            is_anime?: boolean | null;
            /**
             * Networks
             * @description TV networks to include/exclude. Prefix with '!' to exclude. Examples: ['HBO', 'Netflix'], ['HBO', '!Fox']. None/omit = no network filter
             */
            networks?: string[] | null;
            /**
             * Countries
             * @description Countries to include/exclude. Prefix with '!' to exclude. Examples: ['US', 'GB'], ['US', '!CN']. None/omit = no country filter
             */
            countries?: string[] | null;
            /**
             * Languages
             * @description Languages to include/exclude. Prefix with '!' to exclude. Examples: ['en', 'es'], ['en', '!zh']. None/omit = no language filter
             */
            languages?: string[] | null;
            /**
             * Min Rating
             * @description Minimum rating (0-10 scale). None/omit = no minimum
             */
            min_rating?: number | null;
            /**
             * Max Rating
             * @description Maximum rating (0-10 scale). None/omit = no maximum
             */
            max_rating?: number | null;
            /**
             * Content Ratings
             * @description Content ratings to include/exclude. Prefix with '!' to exclude. Examples: ['PG', 'PG-13'], ['PG', '!R']. Common ratings: G, PG, PG-13, R, NC-17, TV-Y, TV-PG, TV-14, TV-MA. None/omit = no rating filter
             */
            content_ratings?: string[] | null;
        };
        /** ListrrModel */
        ListrrModel: {
            /**
             * Update Interval
             * @description Update interval in seconds (24 hours default)
             * @default 86400
             */
            update_interval: number;
            /**
             * Enabled
             * @description Enable Listrr integration
             * @default false
             */
            enabled: boolean;
            /**
             * Movie Lists
             * @description Listrr movie list IDs
             */
            movie_lists?: string[];
            /**
             * Show Lists
             * @description Listrr TV show list IDs
             */
            show_lists?: string[];
            /**
             * Api Key
             * @description Listrr API key
             * @default
             */
            api_key: string;
        };
        /** LoggingModel */
        LoggingModel: {
            /**
             * Enabled
             * @description Enable file logging
             * @default true
             */
            enabled: boolean;
            /**
             * Clean Interval
             * @description Log cleanup interval in seconds (1 hour default)
             * @default 3600
             */
            clean_interval: number;
            /**
             * Retention Hours
             * @description Log retention period in hours
             * @default 24
             */
            retention_hours: number;
            /**
             * Rotation Mb
             * @description Log file rotation size in MB
             * @default 10
             */
            rotation_mb: number;
            /**
             * Compression
             * @description Log compression format (empty for no compression)
             * @default disabled
             * @enum {string}
             */
            compression: "zip" | "gz" | "bz2" | "xz" | "disabled";
        };
        /** LogsResponse */
        LogsResponse: {
            /** Logs */
            logs: string[];
        };
        /** MdblistModel */
        MdblistModel: {
            /**
             * Update Interval
             * @description Update interval in seconds (24 hours default)
             * @default 86400
             */
            update_interval: number;
            /**
             * Enabled
             * @description Enable MDBList integration
             * @default false
             */
            enabled: boolean;
            /**
             * Api Key
             * @description MDBList API key
             * @default
             */
            api_key: string;
            /**
             * Lists
             * @description MDBList list IDs to monitor
             */
            lists?: (number | string)[];
        };
        /**
         * MediaMetadata
         * @description Unified media metadata model combining parsed and probed data.
         *
         *     This model consolidates filename-parsed data (RTN) and file-probed data (ffprobe)
         *     into a single, coherent structure. When both sources provide the same attribute,
         *     probed data takes precedence as the source of truth.
         *
         *     Attributes:
         *         filename: Original filename
         *         parsed_title: Clean title extracted from filename
         *         year: Release year
         *         video: Video track metadata (codec, resolution, HDR, etc.)
         *         audio_tracks: list of audio tracks with codec, channels, language
         *         subtitle_tracks: list of subtitle tracks with codec, language
         *         duration: Duration in seconds (probed only)
         *         file_size: File size in bytes (probed only)
         *         bitrate: Overall bitrate in bits/sec (probed only)
         *         container_format: Container format(s) (probed only)
         *         quality_source: Source quality (BluRay, WEB-DL, etc.) (parsed only)
         *         is_remux: Whether this is a remux release (parsed only)
         *         is_proper: Whether this is a proper release (parsed only)
         *         is_repack: Whether this is a repack release (parsed only)
         *         is_remastered: Whether this is remastered (parsed only)
         *         is_upscaled: Whether this is upscaled (parsed only)
         *         is_directors_cut: Whether this is director's cut (parsed only)
         *         is_extended: Whether this is extended edition (parsed only)
         *         seasons: Season numbers (for shows) (parsed only)
         *         episodes: Episode numbers (for shows) (parsed only)
         *         data_source: Source of the metadata (parsed, probed, or hybrid)
         *         parsed_at: ISO timestamp when filename was parsed
         *         probed_at: ISO timestamp when file was probed
         */
        MediaMetadata: {
            /** Filename */
            filename?: string | null;
            /** Parsed Title */
            parsed_title?: string | null;
            /** Year */
            year?: number | null;
            video?: components["schemas"]["VideoMetadata"] | null;
            /** Audio Tracks */
            audio_tracks?: components["schemas"]["AudioMetadata"][];
            /** Subtitle Tracks */
            subtitle_tracks?: components["schemas"]["SubtitleMetadata"][];
            /** Duration */
            duration?: number | null;
            /** File Size */
            file_size?: number | null;
            /** Bitrate */
            bitrate?: number | null;
            /** Container Formats */
            container_formats?: string[];
            /** Quality Source */
            quality_source?: string | null;
            /**
             * Is Remux
             * @default false
             */
            is_remux: boolean;
            /**
             * Is Proper
             * @default false
             */
            is_proper: boolean;
            /**
             * Is Repack
             * @default false
             */
            is_repack: boolean;
            /**
             * Is Remastered
             * @default false
             */
            is_remastered: boolean;
            /**
             * Is Upscaled
             * @default false
             */
            is_upscaled: boolean;
            /**
             * Is Directors Cut
             * @default false
             */
            is_directors_cut: boolean;
            /**
             * Is Extended
             * @default false
             */
            is_extended: boolean;
            /** Seasons */
            seasons?: number[];
            /** Episodes */
            episodes?: number[];
            /** @default parsed */
            data_source: components["schemas"]["DataSource"];
            /** Parsed At */
            parsed_at?: string | null;
            /** Probed At */
            probed_at?: string | null;
        };
        /**
         * MediaTypeEnum
         * @enum {string}
         */
        MediaTypeEnum: "movie" | "show" | "season" | "episode" | "anime";
        /** MediafusionConfig */
        MediafusionConfig: {
            /**
             * Enabled
             * @description Enable Mediafusion scraper
             * @default false
             */
            enabled: boolean;
            /**
             * Url
             * @description Mediafusion URL
             * @default http://localhost:8000
             */
            url: string;
            /**
             * Timeout
             * @description Request timeout in seconds
             * @default 30
             */
            timeout: number;
            /**
             * Retries
             * @description Number of retries for failed requests
             * @default 1
             */
            retries: number;
            /**
             * Ratelimit
             * @description Enable rate limiting
             * @default true
             */
            ratelimit: boolean;
        };
        /** MessageResponse */
        MessageResponse: {
            /** Message */
            message: string;
        };
        /** MountResponse */
        MountResponse: {
            /** Files */
            files: {
                [key: string]: string;
            };
        };
        /** NotificationsModel */
        NotificationsModel: {
            /**
             * Enabled
             * @description Enable notifications
             * @default false
             */
            enabled: boolean;
            /**
             * On Item Type
             * @description Item types to send notifications for
             */
            on_item_type?: string[];
            /**
             * Service Urls
             * @description Notification service URLs (e.g., Discord webhooks)
             */
            service_urls?: string[];
        };
        /**
         * OptionsConfig
         * @description Configuration for various options.
         */
        OptionsConfig: {
            /**
             * Title Similarity
             * @default 0.85
             */
            title_similarity: number;
            /**
             * Remove All Trash
             * @default true
             */
            remove_all_trash: boolean;
            /**
             * Remove Ranks Under
             * @default -10000
             */
            remove_ranks_under: number;
            /**
             * Remove Unknown Languages
             * @default false
             */
            remove_unknown_languages: boolean;
            /**
             * Allow English In Languages
             * @default true
             */
            allow_english_in_languages: boolean;
            /**
             * Enable Fetch Speed Mode
             * @default true
             */
            enable_fetch_speed_mode: boolean;
            /**
             * Remove Adult Content
             * @default true
             */
            remove_adult_content: boolean;
        };
        /** OrionoidConfig */
        OrionoidConfig: {
            /**
             * Enabled
             * @description Enable Orionoid scraper
             * @default false
             */
            enabled: boolean;
            /**
             * Api Key
             * @description Orionoid API key
             * @default
             */
            api_key: string;
            /**
             * Cached Results Only
             * @description Only return cached/downloadable results
             * @default false
             */
            cached_results_only: boolean;
            /** @description Additional Orionoid parameters */
            parameters?: components["schemas"]["OrionoidConfigParametersDict"];
            /**
             * Timeout
             * @description Request timeout in seconds
             * @default 30
             */
            timeout: number;
            /**
             * Retries
             * @description Number of retries for failed requests
             * @default 1
             */
            retries: number;
            /**
             * Ratelimit
             * @description Enable rate limiting
             * @default true
             */
            ratelimit: boolean;
        };
        /** OrionoidConfigParametersDict */
        OrionoidConfigParametersDict: {
            /**
             * Video3D
             * @description Include 3D video results
             * @default false
             */
            video3d: boolean;
            /**
             * Videoquality
             * @description Video quality filter
             * @default sd_hd8k
             */
            videoquality: string;
            /**
             * Limitcount
             * @description Maximum number of results
             * @default 5
             */
            limitcount: number;
        };
        /** OverseerrModel */
        OverseerrModel: {
            /**
             * Update Interval
             * @description Update interval in seconds
             * @default 60
             */
            update_interval: number;
            /**
             * Enabled
             * @description Enable Overseerr integration
             * @default false
             */
            enabled: boolean;
            /**
             * Url
             * @description Overseerr URL
             * @default http://localhost:5055
             */
            url: string;
            /**
             * Api Key
             * @description Overseerr API key
             * @default
             */
            api_key: string;
            /**
             * Use Webhook
             * @description Use webhook instead of polling
             * @default false
             */
            use_webhook: boolean;
        };
        /** OverseerrWebhookResponse */
        OverseerrWebhookResponse: {
            /** Success */
            success: boolean;
            /** Message */
            message?: string | null;
        };
        /** ParseTorrentTitleResponse */
        ParseTorrentTitleResponse: {
            /** Message */
            message: string;
            /** Data */
            data: {
                [key: string]: unknown;
            }[];
        };
        /**
         * ParsedData
         * @description Parsed data model for a torrent title.
         */
        ParsedData: {
            /** Raw Title */
            raw_title: string;
            /**
             * Parsed Title
             * @default
             */
            parsed_title: string;
            /**
             * Normalized Title
             * @default
             */
            normalized_title: string;
            /**
             * Trash
             * @default false
             */
            trash: boolean;
            /**
             * Adult
             * @default false
             */
            adult: boolean;
            /** Year */
            year?: number | null;
            /**
             * Resolution
             * @default unknown
             */
            resolution: string;
            /**
             * Seasons
             * @default []
             */
            seasons: number[];
            /**
             * Episodes
             * @default []
             */
            episodes: number[];
            /**
             * Complete
             * @default false
             */
            complete: boolean;
            /**
             * Volumes
             * @default []
             */
            volumes: number[];
            /**
             * Languages
             * @default []
             */
            languages: string[];
            /** Quality */
            quality?: string | null;
            /**
             * Hdr
             * @default []
             */
            hdr: string[];
            /** Codec */
            codec?: string | null;
            /**
             * Audio
             * @default []
             */
            audio: string[];
            /**
             * Channels
             * @default []
             */
            channels: string[];
            /**
             * Dubbed
             * @default false
             */
            dubbed: boolean;
            /**
             * Subbed
             * @default false
             */
            subbed: boolean;
            /** Date */
            date?: string | null;
            /** Group */
            group?: string | null;
            /** Edition */
            edition?: string | null;
            /** Bit Depth */
            bit_depth?: string | null;
            /** Bitrate */
            bitrate?: string | null;
            /** Network */
            network?: string | null;
            /**
             * Extended
             * @default false
             */
            extended: boolean;
            /**
             * Converted
             * @default false
             */
            converted: boolean;
            /**
             * Hardcoded
             * @default false
             */
            hardcoded: boolean;
            /** Region */
            region?: string | null;
            /**
             * Ppv
             * @default false
             */
            ppv: boolean;
            /** Site */
            site?: string | null;
            /** Size */
            size?: string | null;
            /**
             * Proper
             * @default false
             */
            proper: boolean;
            /**
             * Repack
             * @default false
             */
            repack: boolean;
            /**
             * Retail
             * @default false
             */
            retail: boolean;
            /**
             * Upscaled
             * @default false
             */
            upscaled: boolean;
            /**
             * Remastered
             * @default false
             */
            remastered: boolean;
            /**
             * Unrated
             * @default false
             */
            unrated: boolean;
            /**
             * Uncensored
             * @default false
             */
            uncensored: boolean;
            /**
             * Documentary
             * @default false
             */
            documentary: boolean;
            /**
             * Commentary
             * @default false
             */
            commentary: boolean;
            /** Episode Code */
            episode_code?: string | null;
            /** Country */
            country?: string | null;
            /** Container */
            container?: string | null;
            /** Extension */
            extension?: string | null;
            /**
             * Extras
             * @default []
             */
            extras: string[];
            /**
             * Torrent
             * @default false
             */
            torrent: boolean;
            /**
             * Scene
             * @default false
             */
            scene: boolean;
        };
        /** PauseResponse */
        PauseResponse: {
            /** Message */
            message: string;
            /**
             * Ids
             * @description The IDs to pause
             */
            ids: number[];
        };
        /** PlexLibraryModel */
        PlexLibraryModel: {
            /**
             * Enabled
             * @description Enable Plex library updates
             * @default false
             */
            enabled: boolean;
            /**
             * Token
             * @description Plex authentication token
             * @default
             */
            token: string;
            /**
             * Url
             * @description Plex server URL
             * @default http://localhost:32400
             */
            url: string;
        };
        /** PlexWatchlistModel */
        PlexWatchlistModel: {
            /**
             * Update Interval
             * @description Update interval in seconds
             * @default 60
             */
            update_interval: number;
            /**
             * Enabled
             * @description Enable Plex Watchlist integration
             * @default false
             */
            enabled: boolean;
            /**
             * Rss
             * @description Plex Watchlist RSS feed URLs
             */
            rss?: string[];
        };
        /** PostProcessing */
        PostProcessing: {
            /** @description Subtitle post-processing configuration */
            subtitle?: components["schemas"]["SubtitleConfig"];
        };
        /** ProwlarrConfig */
        ProwlarrConfig: {
            /**
             * Enabled
             * @description Enable Prowlarr scraper
             * @default false
             */
            enabled: boolean;
            /**
             * Url
             * @description Prowlarr URL
             * @default http://localhost:9696
             */
            url: string;
            /**
             * Api Key
             * @description Prowlarr API key
             * @default
             */
            api_key: string;
            /**
             * Timeout
             * @description Request timeout in seconds
             * @default 30
             */
            timeout: number;
            /**
             * Retries
             * @description Number of retries for failed requests
             * @default 1
             */
            retries: number;
            /**
             * Infohash Fetch Timeout
             * @description Timeout in seconds for parallel infohash fetching from URLs
             * @default 30
             */
            infohash_fetch_timeout: number;
            /**
             * Ratelimit
             * @description Enable rate limiting
             * @default true
             */
            ratelimit: boolean;
            /**
             * Limiter Seconds
             * @description Rate limiter cooldown in seconds
             * @default 60
             */
            limiter_seconds: number;
        };
        /**
         * QualityRankModel
         * @description Ranking configuration for quality attributes.
         */
        QualityRankModel: {
            av1?: components["schemas"]["CustomRank"];
            avc?: components["schemas"]["CustomRank"];
            bluray?: components["schemas"]["CustomRank"];
            dvd?: components["schemas"]["CustomRank"];
            hdtv?: components["schemas"]["CustomRank"];
            hevc?: components["schemas"]["CustomRank"];
            mpeg?: components["schemas"]["CustomRank"];
            remux?: components["schemas"]["CustomRank"];
            vhs?: components["schemas"]["CustomRank"];
            web?: components["schemas"]["CustomRank"];
            webdl?: components["schemas"]["CustomRank"];
            webmux?: components["schemas"]["CustomRank"];
            xvid?: components["schemas"]["CustomRank"];
        };
        /** RTNSettingsModel */
        RTNSettingsModel: {
            /**
             * Name
             * @description Name of the settings
             * @default example
             */
            name: string;
            /**
             * Enabled
             * @description Whether these settings will be used or not
             * @default true
             */
            enabled: boolean;
            /**
             * Require
             * @description Patterns torrents must match to be considered
             */
            require?: string[];
            /**
             * Exclude
             * @description Patterns that, if matched, result in torrent exclusion
             */
            exclude?: string[];
            /**
             * Preferred
             * @description Patterns indicating preferred attributes in torrents
             */
            preferred?: string[];
            /** @description Configuration for enabled resolutions */
            resolutions?: components["schemas"]["ResolutionConfig"];
            /** @description General options for torrent filtering and ranking */
            options?: components["schemas"]["OptionsConfig"];
            /** @description Language preferences and restrictions */
            languages?: components["schemas"]["LanguagesConfig"];
            /** @description Custom ranking configurations for specific attributes */
            custom_ranks?: components["schemas"]["CustomRanksConfig"];
        };
        /** RarbgConfig */
        RarbgConfig: {
            /**
             * Enabled
             * @description Enable RARBG scraper
             * @default false
             */
            enabled: boolean;
            /**
             * Url
             * @description RARBG URL
             * @default https://therarbg.to
             */
            url: string;
            /**
             * Timeout
             * @description Request timeout in seconds
             * @default 30
             */
            timeout: number;
            /**
             * Retries
             * @description Number of retries for failed requests
             * @default 1
             */
            retries: number;
            /**
             * Ratelimit
             * @description Enable rate limiting
             * @default true
             */
            ratelimit: boolean;
        };
        /** RealDebridModel */
        RealDebridModel: {
            /**
             * Enabled
             * @description Enable Real-Debrid
             * @default false
             */
            enabled: boolean;
            /**
             * Api Key
             * @description Real-Debrid API key
             * @default
             */
            api_key: string;
        };
        /** ReindexPayload */
        ReindexPayload: {
            /**
             * Item Id
             * @description The ID of the media item
             */
            item_id?: number | null;
            /**
             * Tvdb Id
             * @description The TVDB ID of the media item
             */
            tvdb_id?: string | null;
            /**
             * Tmdb Id
             * @description The TMDB ID of the media item
             */
            tmdb_id?: string | null;
            /**
             * Imdb Id
             * @description The IMDB ID of the media item
             */
            imdb_id?: string | null;
        };
        /** RemoveResponse */
        RemoveResponse: {
            /** Message */
            message: string;
            /**
             * Ids
             * @description The IDs to remove
             */
            ids: number[];
        };
        /** ResetResponse */
        ResetResponse: {
            /** Message */
            message: string;
            /** Ids */
            ids: number[];
        };
        /**
         * ResolutionConfig
         * @description Configuration for which resolutions are enabled.
         */
        ResolutionConfig: {
            /**
             * R2160P
             * @default false
             */
            r2160p: boolean;
            /**
             * R1080P
             * @default true
             */
            r1080p: boolean;
            /**
             * R720P
             * @default true
             */
            r720p: boolean;
            /**
             * R480P
             * @default false
             */
            r480p: boolean;
            /**
             * R360P
             * @default false
             */
            r360p: boolean;
            /**
             * Unknown
             * @default true
             */
            unknown: boolean;
        };
        /** RetryResponse */
        RetryResponse: {
            /** Message */
            message: string;
            /**
             * Ids
             * @description The IDs to retry
             */
            ids: number[];
        };
        /**
         * RipsRankModel
         * @description Ranking configuration for rips attributes.
         */
        RipsRankModel: {
            bdrip?: components["schemas"]["CustomRank"];
            brrip?: components["schemas"]["CustomRank"];
            dvdrip?: components["schemas"]["CustomRank"];
            hdrip?: components["schemas"]["CustomRank"];
            ppvrip?: components["schemas"]["CustomRank"];
            satrip?: components["schemas"]["CustomRank"];
            tvrip?: components["schemas"]["CustomRank"];
            uhdrip?: components["schemas"]["CustomRank"];
            vhsrip?: components["schemas"]["CustomRank"];
            webdlrip?: components["schemas"]["CustomRank"];
            webrip?: components["schemas"]["CustomRank"];
        };
        /** RootResponse */
        RootResponse: {
            /** Message */
            message: string;
            /** Version */
            version: string;
        };
        /** ScrapeItemResponse */
        ScrapeItemResponse: {
            /** Message */
            message: string;
            /** Streams */
            streams: {
                [key: string]: components["schemas"]["Stream"];
            };
        };
        /** ScraperModel */
        ScraperModel: {
            /**
             * After 2
             * @description Hours to wait after 2 failed scrapes
             * @default 2
             */
            after_2: number;
            /**
             * After 5
             * @description Hours to wait after 5 failed scrapes
             * @default 6
             */
            after_5: number;
            /**
             * After 10
             * @description Hours to wait after 10 failed scrapes
             * @default 24
             */
            after_10: number;
            /**
             * Enable Aliases
             * @description Enable title aliases for better matching
             * @default true
             */
            enable_aliases: boolean;
            /**
             * Bucket Limit
             * @description Maximum results per quality bucket
             * @default 5
             */
            bucket_limit: number;
            /**
             * Max Failed Attempts
             * @description Maximum failed scrape attempts before giving up
             * @default 0
             */
            max_failed_attempts: number;
            /**
             * Dubbed Anime Only
             * @description Only scrape dubbed anime content
             * @default false
             */
            dubbed_anime_only: boolean;
            /** @description Torrentio configuration */
            torrentio?: components["schemas"]["TorrentioConfig"];
            /** @description Jackett configuration */
            jackett?: components["schemas"]["JackettConfig"];
            /** @description Prowlarr configuration */
            prowlarr?: components["schemas"]["ProwlarrConfig"];
            /** @description Orionoid configuration */
            orionoid?: components["schemas"]["OrionoidConfig"];
            /** @description Mediafusion configuration */
            mediafusion?: components["schemas"]["MediafusionConfig"];
            /** @description Zilean configuration */
            zilean?: components["schemas"]["ZileanConfig"];
            /** @description Comet configuration */
            comet?: components["schemas"]["CometConfig"];
            /** @description RARBG configuration */
            rarbg?: components["schemas"]["RarbgConfig"];
        };
        /** SelectFilesResponse */
        SelectFilesResponse: {
            /** Message */
            message: string;
            /**
             * Download Type
             * @enum {string}
             */
            download_type: "cached" | "uncached";
        };
        /** SetSettings */
        SetSettings: {
            /** Key */
            key: string;
            /** Value */
            value: unknown;
        };
        /**
         * ShowFileData
         * @description Root model for show file data that maps seasons to episodes to file data.
         *
         *     Example:
         *     {
         *         1: {  # Season 1
         *             1: {"filename": "path/to/s01e01.mkv"},  # Episode 1
         *             2: {"filename": "path/to/s01e02.mkv"}   # Episode 2
         *         },
         *         2: {  # Season 2
         *             1: {"filename": "path/to/s02e01.mkv"}   # Episode 1
         *         }
         *     }
         */
        ShowFileData: {
            [key: string]: {
                [key: string]: components["schemas"]["DebridFile"];
            };
        };
        /**
         * SortOrderEnum
         * @enum {string}
         */
        SortOrderEnum: "title_asc" | "title_desc" | "date_asc" | "date_desc";
        /** StartSessionResponse */
        StartSessionResponse: {
            /** Message */
            message: string;
            /** Session Id */
            session_id: string;
            /** Torrent Id */
            torrent_id: string | number;
            torrent_info: components["schemas"]["TorrentInfo"];
            containers: components["schemas"]["TorrentContainer"] | null;
            /** Expires At */
            expires_at: string;
        };
        /** StateResponse */
        StateResponse: {
            /**
             * Success
             * @description Boolean signifying whether the request was successful
             */
            success: boolean;
            /**
             * States
             * @description The list of states
             */
            states: string[];
        };
        /**
         * States
         * @enum {string}
         */
        States: "Unknown" | "Unreleased" | "Ongoing" | "Requested" | "Indexed" | "Scraped" | "Downloaded" | "Symlinked" | "Completed" | "PartiallyCompleted" | "Failed" | "Paused";
        /**
         * StatesFilter
         * @enum {string}
         */
        StatesFilter: "All";
        /** StatsResponse */
        StatsResponse: {
            /** Total Items */
            total_items: number;
            /** Total Movies */
            total_movies: number;
            /** Total Shows */
            total_shows: number;
            /** Total Seasons */
            total_seasons: number;
            /** Total Episodes */
            total_episodes: number;
            /** Total Symlinks */
            total_symlinks: number;
            /** Incomplete Items */
            incomplete_items: number;
            /** States */
            states: {
                [key: string]: number;
            };
            /**
             * Activity
             * @description Dictionary mapping date strings to count of items requested on that day
             */
            activity: {
                [key: string]: number;
            };
            /**
             * Media Year Releases
             * @description List of dictionaries with 'year' and 'count' keys representing media item releases per year
             */
            media_year_releases: {
                [key: string]: number | null;
            }[];
        };
        /** Stream */
        Stream: {
            /** Infohash */
            infohash: string;
            /** Raw Title */
            raw_title: string;
            /** Parsed Title */
            parsed_title: string;
            parsed_data: components["schemas"]["ParsedData"];
            /** Rank */
            rank: number;
            /** Lev Ratio */
            lev_ratio: number;
            /**
             * Is Cached
             * @default false
             */
            is_cached: boolean;
        };
        /** StreamModel */
        StreamModel: {
            /**
             * Chunk Size Mb
             * @description Chunk size in MB for streaming downloads (1 MB default). Note: Smaller chunks are generally more efficient, as the entire chunk must be downloaded before it can be read.
             * @default 1
             */
            chunk_size_mb: number;
            /**
             * Connect Timeout Seconds
             * @description Timeout in seconds for establishing a connection to the streaming service (10 seconds default)
             * @default 10
             */
            connect_timeout_seconds: number;
            /**
             * Chunk Wait Timeout Seconds
             * @description Timeout in seconds for reading a chunk during streaming (10 seconds default)
             * @default 10
             */
            chunk_wait_timeout_seconds: number;
            /**
             * Activity Timeout Seconds
             * @description Timeout in seconds before a stream is considered inactive during resource cleanup (60 seconds default)
             * @default 60
             */
            activity_timeout_seconds: number;
        };
        /** StreamsResponse */
        StreamsResponse: {
            /** Message */
            message: string;
            /**
             * Streams
             * @description The list of streams
             */
            streams: {
                [key: string]: unknown;
            }[];
            /**
             * Blacklisted Streams
             * @description The list of blacklisted streams
             */
            blacklisted_streams: {
                [key: string]: unknown;
            }[];
        };
        /** SubtitleConfig */
        SubtitleConfig: {
            /**
             * Enabled
             * @description Enable subtitle downloading
             * @default false
             */
            enabled: boolean;
            /**
             * Languages
             * @description Subtitle languages to download (ISO 639-2 codes)
             */
            languages?: string[];
            /** @description Subtitle provider configurations */
            providers?: components["schemas"]["SubtitleProvidersDict"];
        };
        /**
         * SubtitleMetadata
         * @description Subtitle track metadata
         */
        SubtitleMetadata: {
            /** Codec */
            codec?: string | null;
            /** Language */
            language?: string | null;
        };
        /** SubtitleProviderConfig */
        SubtitleProviderConfig: {
            /**
             * Enabled
             * @description Enable this subtitle provider
             * @default false
             */
            enabled: boolean;
        };
        /** SubtitleProvidersDict */
        SubtitleProvidersDict: {
            /** @description OpenSubtitles provider configuration */
            opensubtitles?: components["schemas"]["SubtitleProviderConfig"];
        };
        /**
         * TorrentContainer
         * @description Represents a collection of files from an infohash from a debrid service
         */
        TorrentContainer: {
            /** Infohash */
            infohash: string;
            /** Files */
            files?: components["schemas"]["DebridFile"][];
            /** Torrent Id */
            torrent_id?: number | string | null;
            torrent_info?: components["schemas"]["TorrentInfo"] | null;
        };
        /**
         * TorrentFile
         * @description Represents a file within a torrent
         */
        TorrentFile: {
            /** Id */
            id: number;
            /** Path */
            path: string;
            /** Bytes */
            bytes: number;
            /**
             * Selected
             * @enum {integer}
             */
            selected: 0 | 1;
            /** Download Url */
            download_url: string;
        };
        /**
         * TorrentInfo
         * @description Torrent information from a debrid service
         */
        TorrentInfo: {
            /** Id */
            id: number | string;
            /** Name */
            name: string;
            /** Status */
            status?: string | null;
            /** Infohash */
            infohash?: string | null;
            /** Progress */
            progress?: number | null;
            /** Bytes */
            bytes?: number | null;
            /** Created At */
            created_at?: string | null;
            /** Expires At */
            expires_at?: string | null;
            /** Completed At */
            completed_at?: string | null;
            /** Alternative Filename */
            alternative_filename?: string | null;
            /** Files */
            files?: {
                [key: string]: components["schemas"]["TorrentFile"];
            };
            /** Links */
            links?: string[];
        };
        /** TorrentioConfig */
        TorrentioConfig: {
            /**
             * Enabled
             * @description Enable Torrentio scraper
             * @default false
             */
            enabled: boolean;
            /**
             * Filter
             * @description Torrentio filter parameters
             * @default sort=qualitysize%7Cqualityfilter=480p,scr,cam
             */
            filter: string;
            /**
             * Url
             * @description Torrentio URL
             * @default http://torrentio.strem.fun
             */
            url: string;
            /**
             * Timeout
             * @description Request timeout in seconds
             * @default 30
             */
            timeout: number;
            /**
             * Retries
             * @description Number of retries for failed requests
             * @default 1
             */
            retries: number;
            /**
             * Ratelimit
             * @description Enable rate limiting
             * @default true
             */
            ratelimit: boolean;
            /**
             * Proxy Url
             * @description Proxy URL for Torrentio requests
             * @default
             */
            proxy_url: string;
        };
        /** TraktModel */
        TraktModel: {
            /**
             * Update Interval
             * @description Update interval in seconds (24 hours default)
             * @default 86400
             */
            update_interval: number;
            /**
             * Enabled
             * @description Enable Trakt integration
             * @default false
             */
            enabled: boolean;
            /**
             * Api Key
             * @description Trakt API key
             * @default
             */
            api_key: string;
            /**
             * Watchlist
             * @description Trakt usernames for watchlist monitoring
             */
            watchlist?: string[];
            /**
             * User Lists
             * @description Trakt user list URLs to monitor
             */
            user_lists?: string[];
            /**
             * Collection
             * @description Trakt usernames for collection monitoring
             */
            collection?: string[];
            /**
             * Fetch Trending
             * @description Fetch trending content from Trakt
             * @default false
             */
            fetch_trending: boolean;
            /**
             * Trending Count
             * @description Number of trending items to fetch
             * @default 10
             */
            trending_count: number;
            /**
             * Fetch Popular
             * @description Fetch popular content from Trakt
             * @default false
             */
            fetch_popular: boolean;
            /**
             * Popular Count
             * @description Number of popular items to fetch
             * @default 10
             */
            popular_count: number;
            /**
             * Fetch Most Watched
             * @description Fetch most watched content from Trakt
             * @default false
             */
            fetch_most_watched: boolean;
            /**
             * Most Watched Period
             * @description Period for most watched (daily, weekly, monthly, yearly)
             * @default weekly
             */
            most_watched_period: string;
            /**
             * Most Watched Count
             * @description Number of most watched items to fetch
             * @default 10
             */
            most_watched_count: number;
            /** @description Trakt OAuth configuration */
            oauth?: components["schemas"]["TraktOauthModel"];
            /**
             * Proxy Url
             * @description Proxy URL for Trakt API requests
             * @default
             */
            proxy_url: string;
        };
        /** TraktOAuthInitiateResponse */
        TraktOAuthInitiateResponse: {
            /** Auth Url */
            auth_url: string;
        };
        /** TraktOauthModel */
        TraktOauthModel: {
            /**
             * Oauth Client Id
             * @description Trakt OAuth client ID
             * @default
             */
            oauth_client_id: string;
            /**
             * Oauth Client Secret
             * @description Trakt OAuth client secret
             * @default
             */
            oauth_client_secret: string;
            /**
             * Oauth Redirect Uri
             * @description Trakt OAuth redirect URI
             * @default
             */
            oauth_redirect_uri: string;
            /**
             * Access Token
             * @description Trakt OAuth access token
             * @default
             */
            access_token: string;
            /**
             * Refresh Token
             * @description Trakt OAuth refresh token
             * @default
             */
            refresh_token: string;
        };
        /**
         * TrashRankModel
         * @description Ranking configuration for trash attributes.
         */
        TrashRankModel: {
            cam?: components["schemas"]["CustomRank"];
            clean_audio?: components["schemas"]["CustomRank"];
            pdtv?: components["schemas"]["CustomRank"];
            r5?: components["schemas"]["CustomRank"];
            screener?: components["schemas"]["CustomRank"];
            size?: components["schemas"]["CustomRank"];
            telecine?: components["schemas"]["CustomRank"];
            telesync?: components["schemas"]["CustomRank"];
        };
        /** UpdatersModel */
        UpdatersModel: {
            /**
             * Updater Interval
             * @description Interval in seconds between library updates
             * @default 120
             */
            updater_interval: number;
            /**
             * Library Path
             * Format: path
             * @description Path to which your media library mount point
             * @default /path/to/library/mount
             */
            library_path: string;
            /** @description Plex library configuration */
            plex?: components["schemas"]["PlexLibraryModel"];
            /** @description Jellyfin library configuration */
            jellyfin?: components["schemas"]["JellyfinLibraryModel"];
            /** @description Emby library configuration */
            emby?: components["schemas"]["EmbyLibraryModel"];
        };
        /** UploadLogsResponse */
        UploadLogsResponse: {
            /** Success */
            success: boolean;
            /**
             * Url
             * Format: uri
             * @description URL to the uploaded log file. 50M Filesize limit. 180 day retention.
             */
            url: string;
        };
        /** VFSStatsResponse */
        VFSStatsResponse: {
            /**
             * Stats
             * @description VFS statistics
             */
            stats: {
                [key: string]: {
                    [key: string]: unknown;
                };
            };
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /**
         * VideoMetadata
         * @description Video track metadata
         */
        VideoMetadata: {
            /** Codec */
            codec?: string | null;
            /** Resolution Width */
            resolution_width?: number | null;
            /** Resolution Height */
            resolution_height?: number | null;
            /** Frame Rate */
            frame_rate?: number | null;
            /** Bit Depth */
            bit_depth?: number | null;
            /** Hdr Type */
            hdr_type?: string | null;
        };
        /** ZileanConfig */
        ZileanConfig: {
            /**
             * Enabled
             * @description Enable Zilean scraper
             * @default false
             */
            enabled: boolean;
            /**
             * Url
             * @description Zilean URL
             * @default http://localhost:8181
             */
            url: string;
            /**
             * Timeout
             * @description Request timeout in seconds
             * @default 30
             */
            timeout: number;
            /**
             * Retries
             * @description Number of retries for failed requests
             * @default 1
             */
            retries: number;
            /**
             * Ratelimit
             * @description Enable rate limiting
             * @default true
             */
            ratelimit: boolean;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    root: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RootResponse"];
                };
            };
        };
    };
    health: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    download_user_info: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DownloaderUserInfoResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    generate_apikey: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    services: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: boolean;
                    };
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    trakt_oauth_initiate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TraktOAuthInitiateResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    trakt_oauth_callback: {
        parameters: {
            query: {
                /** @description The OAuth code returned by Trakt */
                code: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    stats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatsResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    logs: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogsResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    events: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    mount: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MountResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    upload_logs: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UploadLogsResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    fetch_calendar: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CalendarResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_vfs_stats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VFSStatsResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_states: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StateResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_items: {
        parameters: {
            query?: {
                /** @description Number of items per page */
                limit?: number;
                /** @description Page number */
                page?: number;
                /** @description Filter by media type(s) */
                type?: components["schemas"]["MediaTypeEnum"][] | null;
                /** @description Filter by state(s) */
                states?: (components["schemas"]["States"] | components["schemas"]["StatesFilter"])[] | null;
                /** @description Sort order(s). Multiple sorts allowed but only one per type (title or date) */
                sort?: components["schemas"]["SortOrderEnum"][] | null;
                /** @description Search by title or IMDB/TVDB/TMDB ID */
                search?: string | null;
                /** @description Include extended item details */
                extended?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ItemsResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_items: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AddMediaItemPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_item: {
        parameters: {
            query: {
                /** @description The type of media item */
                media_type: "movie" | "tv" | "item";
                /** @description Whether to include extended information */
                extended?: boolean;
            };
            header?: never;
            path: {
                /**
                 * @description The ID of the media item. For 'item' type, use the numeric item ID;
                 *                     for 'movie' or 'tv' types, use the TMDB or TVDB ID respectively.
                 */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    reset_items: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["IdListPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResetResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    retry_items: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["IdListPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RetryResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    retry_library_items: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RetryResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    remove_item: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["IdListPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RemoveResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_item_streams: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the media item */
                item_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StreamsResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    blacklist_item_stream: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the media item */
                item_id: number;
                /** @description The ID of the stream */
                stream_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    unblacklist_item_stream: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the media item */
                item_id: number;
                /** @description The ID of the stream */
                stream_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    reset_item_streams: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the media item */
                item_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    pause_items: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["IdListPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PauseResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    unpause_items: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["IdListPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PauseResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    composite_reindexer: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ReindexPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_item_aliases: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the media item */
                item_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ItemAliasesResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_item_metadata: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the media item */
                item_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaMetadata"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    scrape_item: {
        parameters: {
            query?: {
                /** @description The ID of the media item */
                item_id?: number | null;
                /** @description The TMDB ID of the media item */
                tmdb_id?: string | null;
                /** @description The TVDB ID of the media item */
                tvdb_id?: string | null;
                /** @description The IMDB ID of the media item */
                imdb_id?: string | null;
                /** @description The media type */
                media_type?: ("movie" | "tv") | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ScrapeItemResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    start_manual_session: {
        parameters: {
            query: {
                magnet: string;
                /** @description The ID of the media item */
                item_id?: number | null;
                /** @description The TMDB ID of the media item */
                tmdb_id?: string | null;
                /** @description The TVDB ID of the media item */
                tvdb_id?: string | null;
                /** @description The IMDB ID of the media item */
                imdb_id?: string | null;
                /** @description The media type */
                media_type?: ("movie" | "tv") | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StartSessionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    manual_select: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Identifier of the scraping session containing item and torrent context. */
                session_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Container"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SelectFilesResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    manual_update_attributes: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Identifier of the scraping session containing item and torrent context. */
                session_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DebridFile"] | components["schemas"]["ShowFileData"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    abort_manual_session: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Identifier of the scraping session containing item and torrent context. */
                session_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    complete_manual_session: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Identifier of the scraping session containing item and torrent context. */
                session_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    parse_torrent_titles: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": string[];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ParseTorrentTitleResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    fetch_overseerr_requests: {
        parameters: {
            query?: {
                /** @description Filter for Overseerr requests */
                filter?: ("all" | "approved" | "available" | "pending" | "processing" | "unavailable" | "failed" | "deleted" | "completed") | null;
                /** @description Number of requests to fetch */
                take?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_settings_schema: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    load_settings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    save_settings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_all_settings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AppModel"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_settings: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Comma-separated list of settings paths */
                paths: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    set_all_settings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    [key: string]: unknown;
                };
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    set_settings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SetSettings"][];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    overseerr_api_v1_webhook_overseerr_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OverseerrWebhookResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_event_types_api_v1_stream_event_types_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventTypesResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    stream_events_api_v1_stream__event_type__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The type of event to stream */
                event_type: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
}
