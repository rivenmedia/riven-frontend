// This file is auto-generated by @hey-api/openapi-ts

export type AllDebridModel = {
    enabled?: boolean;
    api_key?: string;
};

export type AppModel = {
    version?: string;
    api_key?: string;
    debug?: boolean;
    debug_database?: boolean;
    log?: boolean;
    force_refresh?: boolean;
    map_metadata?: boolean;
    tracemalloc?: boolean;
    symlink?: SymlinkModel;
    updaters?: UpdatersModel;
    downloaders?: DownloadersModel;
    content?: ContentModel;
    scraping?: ScraperModel;
    ranking?: RtnSettingsModel;
    indexer?: IndexerModel;
    database?: DatabaseModel;
    notifications?: NotificationsModel;
    post_processing?: PostProcessing;
};

/**
 * Ranking configuration for audio attributes.
 */
export type AudioRankModel = {
    aac?: CustomRank;
    ac3?: CustomRank;
    atmos?: CustomRank;
    dolby_digital?: CustomRank;
    dolby_digital_plus?: CustomRank;
    dts_lossy?: CustomRank;
    dts_lossless?: CustomRank;
    eac3?: CustomRank;
    flac?: CustomRank;
    mono?: CustomRank;
    mp3?: CustomRank;
    stereo?: CustomRank;
    surround?: CustomRank;
    truehd?: CustomRank;
};

export type CalendarResponse = {
    data: {
        [key: string]: unknown;
    };
};

export type CometConfig = {
    enabled?: boolean;
    url?: string;
    timeout?: number;
    ratelimit?: boolean;
};

/**
 * Root model for container mapping file IDs to file information.
 *
 * Example:
 * {
 * "4": {
 * "filename": "show.s01e01.mkv",
 * "filesize": 30791392598
 * },
 * "5": {
 * "filename": "show.s01e02.mkv",
 * "filesize": 25573181861
 * }
 * }
 */
export type Container = {
    [key: string]: DebridFile;
};

export type ContentModel = {
    overseerr?: OverseerrModel;
    plex_watchlist?: PlexWatchlistModel;
    mdblist?: MdblistModel;
    listrr?: ListrrModel;
    trakt?: TraktModel;
};

/**
 * Custom Ranks used in SettingsModel.
 */
export type CustomRank = {
    fetch?: boolean;
    use_custom_rank?: boolean;
    rank?: number;
};

/**
 * Configuration for custom ranks.
 */
export type CustomRanksConfig = {
    quality?: QualityRankModel;
    rips?: RipsRankModel;
    hdr?: HdrRankModel;
    audio?: AudioRankModel;
    extras?: ExtrasRankModel;
    trash?: TrashRankModel;
};

export type DatabaseModel = {
    host?: string;
};

/**
 * Represents a file from a debrid service
 */
export type DebridFile = {
    file_id?: number | null;
    filename?: string | null;
    filesize?: number | null;
};

export type DownloadersModel = {
    video_extensions?: Array<string>;
    movie_filesize_mb_min?: number;
    movie_filesize_mb_max?: number;
    episode_filesize_mb_min?: number;
    episode_filesize_mb_max?: number;
    proxy_url?: string;
    real_debrid?: RealDebridModel;
    all_debrid?: AllDebridModel;
};

export type EmbyLibraryModel = {
    enabled?: boolean;
    api_key?: string;
    url?: string;
};

/**
 * Ranking configuration for extras attributes.
 */
export type ExtrasRankModel = {
    '3d'?: CustomRank;
    converted?: CustomRank;
    documentary?: CustomRank;
    dubbed?: CustomRank;
    edition?: CustomRank;
    hardcoded?: CustomRank;
    network?: CustomRank;
    proper?: CustomRank;
    repack?: CustomRank;
    retail?: CustomRank;
    site?: CustomRank;
    subbed?: CustomRank;
    upscaled?: CustomRank;
    scene?: CustomRank;
};

export type FfprobeResponse = {
    message: string;
    data: {
        [key: string]: unknown;
    };
};

export type HttpValidationError = {
    detail?: Array<ValidationError>;
};

/**
 * Ranking configuration for HDR attributes.
 */
export type HdrRankModel = {
    bit10?: CustomRank;
    dolby_vision?: CustomRank;
    hdr?: CustomRank;
    hdr10plus?: CustomRank;
    sdr?: CustomRank;
};

export type IndexerModel = {
    update_interval?: number;
};

export type ItemsResponse = {
    success: boolean;
    items: Array<{
        [key: string]: unknown;
    }>;
    page: number;
    limit: number;
    total_items: number;
    total_pages: number;
};

export type JackettConfig = {
    enabled?: boolean;
    url?: string;
    api_key?: string;
    timeout?: number;
    ratelimit?: boolean;
};

export type JellyfinLibraryModel = {
    enabled?: boolean;
    api_key?: string;
    url?: string;
};

export type KnightcrawlerConfig = {
    enabled?: boolean;
    filter?: string;
    url?: string;
    timeout?: number;
    ratelimit?: boolean;
};

/**
 * Configuration for which languages are enabled.
 */
export type LanguagesConfig = {
    required?: Array<string>;
    exclude?: Array<string>;
    preferred?: Array<string>;
};

export type ListrrModel = {
    update_interval?: number;
    enabled?: boolean;
    movie_lists?: Array<string>;
    show_lists?: Array<string>;
    api_key?: string;
};

export type LogsResponse = {
    logs: Array<string>;
};

export type MdblistModel = {
    update_interval?: number;
    enabled?: boolean;
    api_key?: string;
    lists?: Array<string | number>;
};

export type MediafusionConfig = {
    enabled?: boolean;
    url?: string;
    timeout?: number;
    ratelimit?: boolean;
};

export type MessageResponse = {
    message: string;
};

export type MountResponse = {
    files: {
        [key: string]: string;
    };
};

export type NotificationsModel = {
    enabled?: boolean;
    title?: string;
    on_item_type?: Array<string>;
    service_urls?: Array<string>;
};

/**
 * Configuration for various options.
 */
export type OptionsConfig = {
    title_similarity?: number;
    remove_all_trash?: boolean;
    remove_ranks_under?: number;
    remove_unknown_languages?: boolean;
    allow_english_in_languages?: boolean;
    enable_fetch_speed_mode?: boolean;
    remove_adult_content?: boolean;
};

export type OrionoidConfig = {
    enabled?: boolean;
    api_key?: string;
    cached_results_only?: boolean;
    parameters?: {
        [key: string]: unknown;
    };
    timeout?: number;
    /**
     * @deprecated
     */
    ratelimit?: boolean;
};

export type OverseerrModel = {
    update_interval?: number;
    enabled?: boolean;
    url?: string;
    api_key?: string;
    use_webhook?: boolean;
};

export type ParseTorrentTitleResponse = {
    message: string;
    data: Array<{
        [key: string]: unknown;
    }>;
};

/**
 * Parsed data model for a torrent title.
 */
export type ParsedData = {
    raw_title: string;
    parsed_title?: string;
    normalized_title?: string;
    trash?: boolean;
    adult?: boolean;
    year?: number | null;
    resolution?: string;
    seasons?: Array<number>;
    episodes?: Array<number>;
    complete?: boolean;
    volumes?: Array<number>;
    languages?: Array<string>;
    quality?: string | null;
    hdr?: Array<string>;
    codec?: string | null;
    audio?: Array<string>;
    channels?: Array<string>;
    dubbed?: boolean;
    subbed?: boolean;
    date?: string | null;
    group?: string | null;
    edition?: string | null;
    bit_depth?: string | null;
    bitrate?: string | null;
    network?: string | null;
    extended?: boolean;
    converted?: boolean;
    hardcoded?: boolean;
    region?: string | null;
    ppv?: boolean;
    site?: string | null;
    size?: string | null;
    proper?: boolean;
    repack?: boolean;
    retail?: boolean;
    upscaled?: boolean;
    remastered?: boolean;
    unrated?: boolean;
    documentary?: boolean;
    episode_code?: string | null;
    country?: string | null;
    container?: string | null;
    extension?: string | null;
    extras?: Array<string>;
    torrent?: boolean;
    scene?: boolean;
};

export type PauseResponse = {
    message: string;
    ids: Array<string>;
};

export type PlexLibraryModel = {
    enabled?: boolean;
    token?: string;
    url?: string;
};

export type PlexWatchlistModel = {
    update_interval?: number;
    enabled?: boolean;
    rss?: Array<string>;
};

export type PostProcessing = {
    subliminal?: SubliminalConfig;
};

export type ProwlarrConfig = {
    enabled?: boolean;
    url?: string;
    api_key?: string;
    timeout?: number;
    ratelimit?: boolean;
    limiter_seconds?: number;
};

/**
 * Ranking configuration for quality attributes.
 */
export type QualityRankModel = {
    av1?: CustomRank;
    avc?: CustomRank;
    bluray?: CustomRank;
    dvd?: CustomRank;
    hdtv?: CustomRank;
    hevc?: CustomRank;
    mpeg?: CustomRank;
    remux?: CustomRank;
    vhs?: CustomRank;
    web?: CustomRank;
    webdl?: CustomRank;
    webmux?: CustomRank;
    xvid?: CustomRank;
};

export type RdUser = {
    id: number;
    username: string;
    email: string;
    /**
     * User's RD points
     */
    points: number;
    locale: string;
    /**
     * URL to the user's avatar
     */
    avatar: string;
    type: 'free' | 'premium';
    /**
     * Premium subscription left in seconds
     */
    premium: number;
};

export type RtnSettingsModel = {
    /**
     * Identifier for the settings profile
     */
    profile?: string;
    /**
     * Patterns torrents must match to be considered
     */
    require?: Array<string>;
    /**
     * Patterns that, if matched, result in torrent exclusion
     */
    exclude?: Array<string>;
    /**
     * Patterns indicating preferred attributes in torrents
     */
    preferred?: Array<string>;
    /**
     * Configuration for enabled resolutions
     */
    resolutions?: ResolutionConfig;
    /**
     * General options for torrent filtering and ranking
     */
    options?: OptionsConfig;
    /**
     * Language preferences and restrictions
     */
    languages?: LanguagesConfig;
    /**
     * Custom ranking configurations for specific attributes
     */
    custom_ranks?: CustomRanksConfig;
};

export type RealDebridModel = {
    enabled?: boolean;
    api_key?: string;
};

export type RemoveResponse = {
    message: string;
    ids: Array<string>;
};

export type RepairSymlinksResponse = {
    message: string;
};

export type ResetResponse = {
    message: string;
    ids: Array<string>;
};

/**
 * Configuration for which resolutions are enabled.
 */
export type ResolutionConfig = {
    r2160p?: boolean;
    r1080p?: boolean;
    r720p?: boolean;
    r480p?: boolean;
    r360p?: boolean;
    unknown?: boolean;
};

export type RetryResponse = {
    message: string;
    ids: Array<string>;
};

/**
 * Ranking configuration for rips attributes.
 */
export type RipsRankModel = {
    bdrip?: CustomRank;
    brrip?: CustomRank;
    dvdrip?: CustomRank;
    hdrip?: CustomRank;
    ppvrip?: CustomRank;
    satrip?: CustomRank;
    tvrip?: CustomRank;
    uhdrip?: CustomRank;
    vhsrip?: CustomRank;
    webdlrip?: CustomRank;
    webrip?: CustomRank;
};

export type RootResponse = {
    message: string;
    version: string;
};

export type ScrapeItemResponse = {
    message: string;
    streams: {
        [key: string]: Stream;
    };
};

export type ScraperModel = {
    after_2?: number;
    after_5?: number;
    after_10?: number;
    parse_debug?: boolean;
    enable_aliases?: boolean;
    bucket_limit?: number;
    max_failed_attempts?: number;
    dubbed_anime_only?: boolean;
    torrentio?: TorrentioConfig;
    knightcrawler?: KnightcrawlerConfig;
    jackett?: JackettConfig;
    prowlarr?: ProwlarrConfig;
    orionoid?: OrionoidConfig;
    mediafusion?: MediafusionConfig;
    zilean?: ZileanConfig;
    comet?: CometConfig;
};

export type SelectFilesResponse = {
    message: string;
    download_type: 'cached' | 'uncached';
};

export type SessionResponse = {
    message: string;
};

export type SetSettings = {
    key: string;
    value: unknown;
};

/**
 * Root model for show file data that maps seasons to episodes to file data.
 *
 * Example:
 * {
 * 1: {  # Season 1
 * 1: {"filename": "path/to/s01e01.mkv"},  # Episode 1
 * 2: {"filename": "path/to/s01e02.mkv"}   # Episode 2
 * },
 * 2: {  # Season 2
 * 1: {"filename": "path/to/s02e01.mkv"}   # Episode 1
 * }
 * }
 */
export type ShowFileData = {
    [key: string]: {
        [key: string]: DebridFile;
    };
};

export type StartSessionResponse = {
    message: string;
    session_id: string;
    torrent_id: string;
    torrent_info: TorrentInfo;
    containers: TorrentContainer | null;
    expires_at: string;
};

export type StateResponse = {
    success: boolean;
    states: Array<string>;
};

export type States = 'Unknown' | 'Unreleased' | 'Ongoing' | 'Requested' | 'Indexed' | 'Scraped' | 'Downloaded' | 'Symlinked' | 'Completed' | 'PartiallyCompleted' | 'Failed' | 'Paused';

export type StatsResponse = {
    total_items: number;
    total_movies: number;
    total_shows: number;
    total_seasons: number;
    total_episodes: number;
    total_symlinks: number;
    incomplete_items: number;
    /**
     * Media item log string: number of retries
     */
    incomplete_retries: {
        [key: string]: number;
    };
    states: {
        [key: string]: number;
    };
};

export type Stream = {
    infohash: string;
    raw_title: string;
    parsed_title: string;
    parsed_data: ParsedData;
    rank: number;
    lev_ratio: number;
    is_cached?: boolean;
};

export type SubliminalConfig = {
    enabled?: boolean;
    languages?: Array<string>;
    providers?: {
        [key: string]: unknown;
    };
};

export type SymlinkModel = {
    rclone_path?: string;
    library_path?: string;
    separate_anime_dirs?: boolean;
    repair_symlinks?: boolean;
    repair_interval?: number;
};

/**
 * Represents a collection of files from an infohash from a debrid service
 */
export type TorrentContainer = {
    infohash: string;
    files?: Array<DebridFile>;
};

/**
 * Torrent information from a debrid service
 */
export type TorrentInfo = {
    id: number | string;
    name: string;
    status?: string | null;
    infohash?: string | null;
    progress?: number | null;
    bytes?: number | null;
    created_at?: string | null;
    expires_at?: string | null;
    completed_at?: string | null;
    alternative_filename?: string | null;
    files?: {
        [key: string]: {
            [key: string]: number | string;
        };
    };
};

export type TorrentioConfig = {
    enabled?: boolean;
    filter?: string;
    url?: string;
    timeout?: number;
    /**
     * @deprecated
     */
    ratelimit?: boolean;
    proxy_url?: string;
};

export type TraktModel = {
    update_interval?: number;
    enabled?: boolean;
    api_key?: string;
    watchlist?: Array<string>;
    user_lists?: Array<string>;
    collection?: Array<string>;
    fetch_trending?: boolean;
    trending_count?: number;
    fetch_popular?: boolean;
    popular_count?: number;
    fetch_most_watched?: boolean;
    most_watched_period?: string;
    most_watched_count?: number;
    oauth?: TraktOauthModel;
};

export type TraktOAuthInitiateResponse = {
    auth_url: string;
};

export type TraktOauthModel = {
    oauth_client_id?: string;
    oauth_client_secret?: string;
    oauth_redirect_uri?: string;
    access_token?: string;
    refresh_token?: string;
};

/**
 * Ranking configuration for trash attributes.
 */
export type TrashRankModel = {
    cam?: CustomRank;
    clean_audio?: CustomRank;
    pdtv?: CustomRank;
    r5?: CustomRank;
    screener?: CustomRank;
    size?: CustomRank;
    telecine?: CustomRank;
    telesync?: CustomRank;
};

export type UpdateAttributesResponse = {
    message: string;
};

export type UpdateOngoingResponse = {
    message: string;
    updated_items: Array<{
        [key: string]: unknown;
    }>;
};

export type UpdatersModel = {
    updater_interval?: number;
    plex?: PlexLibraryModel;
    jellyfin?: JellyfinLibraryModel;
    emby?: EmbyLibraryModel;
};

export type UploadLogsResponse = {
    success: boolean;
    /**
     * URL to the uploaded log file. 50M Filesize limit. 180 day retention.
     */
    url: string;
};

export type ValidationError = {
    loc: Array<string | number>;
    msg: string;
    type: string;
};

export type ZileanConfig = {
    enabled?: boolean;
    url?: string;
    timeout?: number;
    /**
     * @deprecated
     */
    ratelimit?: boolean;
};

export type RoutersSecureDefaultEventResponse = {
    events: {
        [key: string]: Array<string>;
    };
};

export type RoutersSecureStreamEventResponse = {
    data: {
        [key: string]: unknown;
    };
};

export type RootData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/';
};

export type RootResponses = {
    /**
     * Successful Response
     */
    200: RootResponse;
};

export type RootResponse2 = RootResponses[keyof RootResponses];

export type HealthData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/health';
};

export type HealthErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type HealthResponses = {
    /**
     * Successful Response
     */
    200: MessageResponse;
};

export type HealthResponse = HealthResponses[keyof HealthResponses];

export type RdData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/rd';
};

export type RdErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type RdResponses = {
    /**
     * Successful Response
     */
    200: RdUser;
};

export type RdResponse = RdResponses[keyof RdResponses];

export type GenerateapikeyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/generateapikey';
};

export type GenerateapikeyErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type GenerateapikeyResponses = {
    /**
     * Successful Response
     */
    200: MessageResponse;
};

export type GenerateapikeyResponse = GenerateapikeyResponses[keyof GenerateapikeyResponses];

export type ServicesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/services';
};

export type ServicesErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type ServicesResponses = {
    /**
     * Successful Response
     */
    200: {
        [key: string]: boolean;
    };
};

export type ServicesResponse = ServicesResponses[keyof ServicesResponses];

export type TraktOauthInitiateData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/trakt/oauth/initiate';
};

export type TraktOauthInitiateErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type TraktOauthInitiateResponses = {
    /**
     * Successful Response
     */
    200: TraktOAuthInitiateResponse;
};

export type TraktOauthInitiateResponse = TraktOauthInitiateResponses[keyof TraktOauthInitiateResponses];

export type TraktOauthCallbackData = {
    body?: never;
    path?: never;
    query: {
        code: string;
    };
    url: '/api/v1/trakt/oauth/callback';
};

export type TraktOauthCallbackErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type TraktOauthCallbackError = TraktOauthCallbackErrors[keyof TraktOauthCallbackErrors];

export type TraktOauthCallbackResponses = {
    /**
     * Successful Response
     */
    200: MessageResponse;
};

export type TraktOauthCallbackResponse = TraktOauthCallbackResponses[keyof TraktOauthCallbackResponses];

export type StatsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/stats';
};

export type StatsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type StatsResponses = {
    /**
     * Successful Response
     */
    200: StatsResponse;
};

export type StatsResponse2 = StatsResponses[keyof StatsResponses];

export type LogsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/logs';
};

export type LogsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type LogsResponses = {
    /**
     * Successful Response
     */
    200: LogsResponse;
};

export type LogsResponse2 = LogsResponses[keyof LogsResponses];

export type EventsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/events';
};

export type EventsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type EventsResponses = {
    /**
     * Successful Response
     */
    200: RoutersSecureDefaultEventResponse;
};

export type EventsResponse = EventsResponses[keyof EventsResponses];

export type MountData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/mount';
};

export type MountErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type MountResponses = {
    /**
     * Successful Response
     */
    200: MountResponse;
};

export type MountResponse2 = MountResponses[keyof MountResponses];

export type UploadLogsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/upload_logs';
};

export type UploadLogsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type UploadLogsResponses = {
    /**
     * Successful Response
     */
    200: UploadLogsResponse;
};

export type UploadLogsResponse2 = UploadLogsResponses[keyof UploadLogsResponses];

export type FetchCalendarData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/calendar';
};

export type FetchCalendarErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type FetchCalendarResponses = {
    /**
     * Successful Response
     */
    200: CalendarResponse;
};

export type FetchCalendarResponse = FetchCalendarResponses[keyof FetchCalendarResponses];

export type GetStatesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/items/states';
};

export type GetStatesErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type GetStatesResponses = {
    /**
     * Successful Response
     */
    200: StateResponse;
};

export type GetStatesResponse = GetStatesResponses[keyof GetStatesResponses];

export type GetItemsData = {
    body?: never;
    path?: never;
    query?: {
        limit?: number | null;
        page?: number | null;
        type?: string | null;
        states?: string | null;
        sort?: ('date_desc' | 'date_asc' | 'title_asc' | 'title_desc') | null;
        search?: string | null;
        extended?: boolean | null;
        is_anime?: boolean | null;
    };
    url: '/api/v1/items';
};

export type GetItemsErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetItemsError = GetItemsErrors[keyof GetItemsErrors];

export type GetItemsResponses = {
    /**
     * Successful Response
     */
    200: ItemsResponse;
};

export type GetItemsResponse = GetItemsResponses[keyof GetItemsResponses];

export type AddItemsData = {
    body?: never;
    path?: never;
    query?: {
        imdb_ids?: string;
    };
    url: '/api/v1/items/add';
};

export type AddItemsErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type AddItemsError = AddItemsErrors[keyof AddItemsErrors];

export type AddItemsResponses = {
    /**
     * Successful Response
     */
    200: MessageResponse;
};

export type AddItemsResponse = AddItemsResponses[keyof AddItemsResponses];

export type GetItemData = {
    body?: never;
    path: {
        id: string;
    };
    query?: {
        use_tmdb_id?: boolean | null;
    };
    url: '/api/v1/items/{id}';
};

export type GetItemErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetItemError = GetItemErrors[keyof GetItemErrors];

export type GetItemResponses = {
    /**
     * Successful Response
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetItemResponse = GetItemResponses[keyof GetItemResponses];

export type GetItemsByImdbIdsData = {
    body?: never;
    path: {
        imdb_ids: string;
    };
    query?: never;
    url: '/api/v1/items/imdb/{imdb_ids}';
};

export type GetItemsByImdbIdsErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetItemsByImdbIdsError = GetItemsByImdbIdsErrors[keyof GetItemsByImdbIdsErrors];

export type GetItemsByImdbIdsResponses = {
    /**
     * Successful Response
     */
    200: Array<{
        [key: string]: unknown;
    }>;
};

export type GetItemsByImdbIdsResponse = GetItemsByImdbIdsResponses[keyof GetItemsByImdbIdsResponses];

export type ResetItemsData = {
    body?: never;
    path?: never;
    query: {
        ids: string;
    };
    url: '/api/v1/items/reset';
};

export type ResetItemsErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ResetItemsError = ResetItemsErrors[keyof ResetItemsErrors];

export type ResetItemsResponses = {
    /**
     * Successful Response
     */
    200: ResetResponse;
};

export type ResetItemsResponse = ResetItemsResponses[keyof ResetItemsResponses];

export type RetryItemsData = {
    body?: never;
    path?: never;
    query: {
        ids: string;
    };
    url: '/api/v1/items/retry';
};

export type RetryItemsErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type RetryItemsError = RetryItemsErrors[keyof RetryItemsErrors];

export type RetryItemsResponses = {
    /**
     * Successful Response
     */
    200: RetryResponse;
};

export type RetryItemsResponse = RetryItemsResponses[keyof RetryItemsResponses];

export type RetryLibraryItemsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/items/retry_library';
};

export type RetryLibraryItemsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type RetryLibraryItemsResponses = {
    /**
     * Successful Response
     */
    200: RetryResponse;
};

export type RetryLibraryItemsResponse = RetryLibraryItemsResponses[keyof RetryLibraryItemsResponses];

export type UpdateOngoingItemsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/items/update_ongoing';
};

export type UpdateOngoingItemsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type UpdateOngoingItemsResponses = {
    /**
     * Successful Response
     */
    200: UpdateOngoingResponse;
};

export type UpdateOngoingItemsResponse = UpdateOngoingItemsResponses[keyof UpdateOngoingItemsResponses];

export type RepairSymlinksData = {
    body?: never;
    path?: never;
    query?: {
        directory?: string | null;
    };
    url: '/api/v1/items/repair_symlinks';
};

export type RepairSymlinksErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type RepairSymlinksError = RepairSymlinksErrors[keyof RepairSymlinksErrors];

export type RepairSymlinksResponses = {
    /**
     * Successful Response
     */
    200: RepairSymlinksResponse;
};

export type RepairSymlinksResponse2 = RepairSymlinksResponses[keyof RepairSymlinksResponses];

export type RemoveItemData = {
    body?: never;
    path?: never;
    query: {
        ids: string;
    };
    url: '/api/v1/items/remove';
};

export type RemoveItemErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type RemoveItemError = RemoveItemErrors[keyof RemoveItemErrors];

export type RemoveItemResponses = {
    /**
     * Successful Response
     */
    200: RemoveResponse;
};

export type RemoveItemResponse = RemoveItemResponses[keyof RemoveItemResponses];

export type GetItemStreamsApiV1ItemsItemIdStreamsGetData = {
    body?: never;
    path: {
        item_id: string;
    };
    query?: never;
    url: '/api/v1/items/{item_id}/streams';
};

export type GetItemStreamsApiV1ItemsItemIdStreamsGetErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetItemStreamsApiV1ItemsItemIdStreamsGetError = GetItemStreamsApiV1ItemsItemIdStreamsGetErrors[keyof GetItemStreamsApiV1ItemsItemIdStreamsGetErrors];

export type GetItemStreamsApiV1ItemsItemIdStreamsGetResponses = {
    /**
     * Successful Response
     */
    200: unknown;
};

export type BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostData = {
    body?: never;
    path: {
        item_id: string;
        stream_id: number;
    };
    query?: never;
    url: '/api/v1/items/{item_id}/streams/{stream_id}/blacklist';
};

export type BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostError = BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostErrors[keyof BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostErrors];

export type BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostResponses = {
    /**
     * Successful Response
     */
    200: unknown;
};

export type UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostData = {
    body?: never;
    path: {
        item_id: string;
        stream_id: number;
    };
    query?: never;
    url: '/api/v1/items/{item_id}/streams/{stream_id}/unblacklist';
};

export type UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostError = UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostErrors[keyof UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostErrors];

export type UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostResponses = {
    /**
     * Successful Response
     */
    200: unknown;
};

export type ResetItemStreamsData = {
    body?: never;
    path: {
        item_id: string;
    };
    query?: never;
    url: '/api/v1/items/{item_id}/streams/reset';
};

export type ResetItemStreamsErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ResetItemStreamsError = ResetItemStreamsErrors[keyof ResetItemStreamsErrors];

export type ResetItemStreamsResponses = {
    /**
     * Successful Response
     */
    200: unknown;
};

export type PauseItemsData = {
    body?: never;
    path?: never;
    query: {
        ids: string;
    };
    url: '/api/v1/items/pause';
};

export type PauseItemsErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type PauseItemsError = PauseItemsErrors[keyof PauseItemsErrors];

export type PauseItemsResponses = {
    /**
     * Successful Response
     */
    200: PauseResponse;
};

export type PauseItemsResponse = PauseItemsResponses[keyof PauseItemsResponses];

export type UnpauseItemsData = {
    body?: never;
    path?: never;
    query: {
        ids: string;
    };
    url: '/api/v1/items/unpause';
};

export type UnpauseItemsErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type UnpauseItemsError = UnpauseItemsErrors[keyof UnpauseItemsErrors];

export type UnpauseItemsResponses = {
    /**
     * Successful Response
     */
    200: PauseResponse;
};

export type UnpauseItemsResponse = UnpauseItemsResponses[keyof UnpauseItemsResponses];

export type FfprobeMediaFilesData = {
    body?: never;
    path?: never;
    query: {
        id: string;
    };
    url: '/api/v1/items/ffprobe';
};

export type FfprobeMediaFilesErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type FfprobeMediaFilesError = FfprobeMediaFilesErrors[keyof FfprobeMediaFilesErrors];

export type FfprobeMediaFilesResponses = {
    /**
     * Successful Response
     */
    200: FfprobeResponse;
};

export type FfprobeMediaFilesResponse = FfprobeMediaFilesResponses[keyof FfprobeMediaFilesResponses];

export type ScrapeItemData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/v1/scrape/scrape/{id}';
};

export type ScrapeItemErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ScrapeItemError = ScrapeItemErrors[keyof ScrapeItemErrors];

export type ScrapeItemResponses = {
    /**
     * Successful Response
     */
    200: ScrapeItemResponse;
};

export type ScrapeItemResponse2 = ScrapeItemResponses[keyof ScrapeItemResponses];

export type StartManualSessionData = {
    body?: never;
    path?: never;
    query: {
        item_id: string;
        magnet: string;
    };
    url: '/api/v1/scrape/scrape/start_session';
};

export type StartManualSessionErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type StartManualSessionError = StartManualSessionErrors[keyof StartManualSessionErrors];

export type StartManualSessionResponses = {
    /**
     * Successful Response
     */
    200: StartSessionResponse;
};

export type StartManualSessionResponse = StartManualSessionResponses[keyof StartManualSessionResponses];

export type ManualSelectData = {
    body: Container;
    path: {
        session_id: string;
    };
    query?: never;
    url: '/api/v1/scrape/scrape/select_files/{session_id}';
};

export type ManualSelectErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ManualSelectError = ManualSelectErrors[keyof ManualSelectErrors];

export type ManualSelectResponses = {
    /**
     * Successful Response
     */
    200: SelectFilesResponse;
};

export type ManualSelectResponse = ManualSelectResponses[keyof ManualSelectResponses];

export type ManualUpdateAttributesData = {
    body: DebridFile | ShowFileData;
    path: {
        session_id: unknown;
    };
    query?: never;
    url: '/api/v1/scrape/scrape/update_attributes/{session_id}';
};

export type ManualUpdateAttributesErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ManualUpdateAttributesError = ManualUpdateAttributesErrors[keyof ManualUpdateAttributesErrors];

export type ManualUpdateAttributesResponses = {
    /**
     * Successful Response
     */
    200: UpdateAttributesResponse;
};

export type ManualUpdateAttributesResponse = ManualUpdateAttributesResponses[keyof ManualUpdateAttributesResponses];

export type AbortManualSessionData = {
    body?: never;
    path: {
        session_id: string;
    };
    query?: never;
    url: '/api/v1/scrape/scrape/abort_session/{session_id}';
};

export type AbortManualSessionErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type AbortManualSessionError = AbortManualSessionErrors[keyof AbortManualSessionErrors];

export type AbortManualSessionResponses = {
    /**
     * Successful Response
     */
    200: SessionResponse;
};

export type AbortManualSessionResponse = AbortManualSessionResponses[keyof AbortManualSessionResponses];

export type CompleteManualSessionData = {
    body?: never;
    path: {
        session_id: string;
    };
    query?: never;
    url: '/api/v1/scrape/scrape/complete_session/{session_id}';
};

export type CompleteManualSessionErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type CompleteManualSessionError = CompleteManualSessionErrors[keyof CompleteManualSessionErrors];

export type CompleteManualSessionResponses = {
    /**
     * Successful Response
     */
    200: SessionResponse;
};

export type CompleteManualSessionResponse = CompleteManualSessionResponses[keyof CompleteManualSessionResponses];

export type ParseTorrentTitlesData = {
    body: Array<string>;
    path?: never;
    query?: never;
    url: '/api/v1/scrape/parse';
};

export type ParseTorrentTitlesErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ParseTorrentTitlesError = ParseTorrentTitlesErrors[keyof ParseTorrentTitlesErrors];

export type ParseTorrentTitlesResponses = {
    /**
     * Successful Response
     */
    200: ParseTorrentTitleResponse;
};

export type ParseTorrentTitlesResponse = ParseTorrentTitlesResponses[keyof ParseTorrentTitlesResponses];

export type GetSettingsSchemaData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/settings/schema';
};

export type GetSettingsSchemaErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type GetSettingsSchemaResponses = {
    /**
     * Successful Response
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetSettingsSchemaResponse = GetSettingsSchemaResponses[keyof GetSettingsSchemaResponses];

export type LoadSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/settings/load';
};

export type LoadSettingsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type LoadSettingsResponses = {
    /**
     * Successful Response
     */
    200: MessageResponse;
};

export type LoadSettingsResponse = LoadSettingsResponses[keyof LoadSettingsResponses];

export type SaveSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/settings/save';
};

export type SaveSettingsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SaveSettingsResponses = {
    /**
     * Successful Response
     */
    200: MessageResponse;
};

export type SaveSettingsResponse = SaveSettingsResponses[keyof SaveSettingsResponses];

export type GetAllSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/settings/get/all';
};

export type GetAllSettingsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type GetAllSettingsResponses = {
    /**
     * Successful Response
     */
    200: AppModel;
};

export type GetAllSettingsResponse = GetAllSettingsResponses[keyof GetAllSettingsResponses];

export type GetSettingsData = {
    body?: never;
    path: {
        paths: string;
    };
    query?: never;
    url: '/api/v1/settings/get/{paths}';
};

export type GetSettingsErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetSettingsError = GetSettingsErrors[keyof GetSettingsErrors];

export type GetSettingsResponses = {
    /**
     * Successful Response
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetSettingsResponse = GetSettingsResponses[keyof GetSettingsResponses];

export type SetAllSettingsData = {
    body: {
        [key: string]: unknown;
    };
    path?: never;
    query?: never;
    url: '/api/v1/settings/set/all';
};

export type SetAllSettingsErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type SetAllSettingsError = SetAllSettingsErrors[keyof SetAllSettingsErrors];

export type SetAllSettingsResponses = {
    /**
     * Successful Response
     */
    200: MessageResponse;
};

export type SetAllSettingsResponse = SetAllSettingsResponses[keyof SetAllSettingsResponses];

export type SetSettingsData = {
    body: Array<SetSettings>;
    path?: never;
    query?: never;
    url: '/api/v1/settings/set';
};

export type SetSettingsErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type SetSettingsError = SetSettingsErrors[keyof SetSettingsErrors];

export type SetSettingsResponses = {
    /**
     * Successful Response
     */
    200: MessageResponse;
};

export type SetSettingsResponse = SetSettingsResponses[keyof SetSettingsResponses];

export type OverseerrApiV1WebhookOverseerrPostData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/webhook/overseerr';
};

export type OverseerrApiV1WebhookOverseerrPostErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type OverseerrApiV1WebhookOverseerrPostResponses = {
    /**
     * Successful Response
     */
    200: {
        [key: string]: unknown;
    };
};

export type OverseerrApiV1WebhookOverseerrPostResponse = OverseerrApiV1WebhookOverseerrPostResponses[keyof OverseerrApiV1WebhookOverseerrPostResponses];

export type GetEventTypesApiV1StreamEventTypesGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/stream/event_types';
};

export type GetEventTypesApiV1StreamEventTypesGetErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type GetEventTypesApiV1StreamEventTypesGetResponses = {
    /**
     * Successful Response
     */
    200: unknown;
};

export type StreamEventsApiV1StreamEventTypeGetData = {
    body?: never;
    path: {
        event_type: string;
    };
    query?: never;
    url: '/api/v1/stream/{event_type}';
};

export type StreamEventsApiV1StreamEventTypeGetErrors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type StreamEventsApiV1StreamEventTypeGetError = StreamEventsApiV1StreamEventTypeGetErrors[keyof StreamEventsApiV1StreamEventTypeGetErrors];

export type StreamEventsApiV1StreamEventTypeGetResponses = {
    /**
     * Successful Response
     */
    200: RoutersSecureStreamEventResponse;
};

export type StreamEventsApiV1StreamEventTypeGetResponse = StreamEventsApiV1StreamEventTypeGetResponses[keyof StreamEventsApiV1StreamEventTypeGetResponses];

export type ClientOptions = {
    baseUrl: 'http://localhost:7105' | (string & {});
};