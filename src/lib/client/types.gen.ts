// This file is auto-generated by @hey-api/openapi-ts

export type AllDebridModel = {
    enabled?: boolean;
    api_key?: string;
};

export type AppModel = {
    version?: string;
    api_key?: string;
    debug?: boolean;
    debug_database?: boolean;
    log?: boolean;
    force_refresh?: boolean;
    map_metadata?: boolean;
    tracemalloc?: boolean;
    symlink?: SymlinkModel;
    updaters?: UpdatersModel;
    downloaders?: DownloadersModel;
    content?: ContentModel;
    scraping?: ScraperModel;
    ranking?: RTNSettingsModel;
    indexer?: IndexerModel;
    database?: DatabaseModel;
    notifications?: NotificationsModel;
    post_processing?: PostProcessing;
};

/**
 * Ranking configuration for audio attributes.
 */
export type AudioRankModel = {
    aac?: CustomRank;
    ac3?: CustomRank;
    atmos?: CustomRank;
    dolby_digital?: CustomRank;
    dolby_digital_plus?: CustomRank;
    dts_lossy?: CustomRank;
    dts_lossless?: CustomRank;
    eac3?: CustomRank;
    flac?: CustomRank;
    mono?: CustomRank;
    mp3?: CustomRank;
    stereo?: CustomRank;
    surround?: CustomRank;
    truehd?: CustomRank;
};

export type CometConfig = {
    enabled?: boolean;
    url?: string;
    indexers?: Array<(string)>;
    timeout?: number;
    ratelimit?: boolean;
};

/**
 * Root model for container mapping file IDs to file information.
 *
 * Example:
 * {
 * "4": {
 * "filename": "show.s01e01.mkv",
 * "filesize": 30791392598
 * },
 * "5": {
 * "filename": "show.s01e02.mkv",
 * "filesize": 25573181861
 * }
 * }
 */
export type Container = {
    [key: string]: DebridFile;
};

export type ContentModel = {
    overseerr?: OverseerrModel;
    plex_watchlist?: PlexWatchlistModel;
    mdblist?: MdblistModel;
    listrr?: ListrrModel;
    trakt?: TraktModel;
};

/**
 * Custom Ranks used in SettingsModel.
 */
export type CustomRank = {
    fetch?: boolean;
    use_custom_rank?: boolean;
    rank?: number;
};

/**
 * Configuration for custom ranks.
 */
export type CustomRanksConfig = {
    quality?: QualityRankModel;
    rips?: RipsRankModel;
    hdr?: HdrRankModel;
    audio?: AudioRankModel;
    extras?: ExtrasRankModel;
    trash?: TrashRankModel;
};

export type DatabaseModel = {
    host?: string;
};

/**
 * Represents a file from a debrid service
 */
export type DebridFile = {
    file_id?: (number | null);
    filename?: (string | null);
    filesize?: (number | null);
};

export type DownloadersModel = {
    video_extensions?: Array<(string)>;
    movie_filesize_mb_min?: number;
    movie_filesize_mb_max?: number;
    episode_filesize_mb_min?: number;
    episode_filesize_mb_max?: number;
    proxy_url?: string;
    real_debrid?: RealDebridModel;
    all_debrid?: AllDebridModel;
};

export type EmbyLibraryModel = {
    enabled?: boolean;
    api_key?: string;
    url?: string;
};

export type EventResponse = {
    data: {
        [key: string]: unknown;
    };
};

/**
 * Ranking configuration for extras attributes.
 */
export type ExtrasRankModel = {
    '3d'?: CustomRank;
    converted?: CustomRank;
    documentary?: CustomRank;
    dubbed?: CustomRank;
    edition?: CustomRank;
    hardcoded?: CustomRank;
    network?: CustomRank;
    proper?: CustomRank;
    repack?: CustomRank;
    retail?: CustomRank;
    site?: CustomRank;
    subbed?: CustomRank;
    upscaled?: CustomRank;
    scene?: CustomRank;
};

export type HTTPValidationError = {
    detail?: Array<ValidationError>;
};

/**
 * Ranking configuration for HDR attributes.
 */
export type HdrRankModel = {
    bit10?: CustomRank;
    dolby_vision?: CustomRank;
    hdr?: CustomRank;
    hdr10plus?: CustomRank;
    sdr?: CustomRank;
};

export type IndexerModel = {
    update_interval?: number;
};

export type ItemsResponse = {
    success: boolean;
    items: Array<{
        [key: string]: unknown;
    }>;
    page: number;
    limit: number;
    total_items: number;
    total_pages: number;
};

export type JackettConfig = {
    enabled?: boolean;
    url?: string;
    api_key?: string;
    timeout?: number;
    ratelimit?: boolean;
};

export type JellyfinLibraryModel = {
    enabled?: boolean;
    api_key?: string;
    url?: string;
};

export type KnightcrawlerConfig = {
    enabled?: boolean;
    filter?: string;
    url?: string;
    timeout?: number;
    ratelimit?: boolean;
};

/**
 * Configuration for which languages are enabled.
 */
export type LanguagesConfig = {
    required?: Array<(string)>;
    exclude?: Array<(string)>;
    preferred?: Array<(string)>;
};

export type ListrrModel = {
    update_interval?: number;
    enabled?: boolean;
    movie_lists?: Array<(string)>;
    show_lists?: Array<(string)>;
    api_key?: string;
};

export type MdblistModel = {
    update_interval?: number;
    enabled?: boolean;
    api_key?: string;
    lists?: Array<(string | number)>;
};

export type MediafusionConfig = {
    enabled?: boolean;
    url?: string;
    timeout?: number;
    ratelimit?: boolean;
};

export type MessageResponse = {
    message: string;
};

export type NotificationsModel = {
    enabled?: boolean;
    title?: string;
    on_item_type?: Array<(string)>;
    service_urls?: Array<(string)>;
};

/**
 * Configuration for various options.
 */
export type OptionsConfig = {
    title_similarity?: number;
    remove_all_trash?: boolean;
    remove_ranks_under?: number;
    remove_unknown_languages?: boolean;
    allow_english_in_languages?: boolean;
    enable_fetch_speed_mode?: boolean;
    remove_adult_content?: boolean;
};

export type OrionoidConfig = {
    enabled?: boolean;
    api_key?: string;
    cached_results_only?: boolean;
    parameters?: {
        [key: string]: unknown;
    };
    timeout?: number;
    /**
     * @deprecated
     */
    ratelimit?: boolean;
};

export type OverseerrModel = {
    update_interval?: number;
    enabled?: boolean;
    url?: string;
    api_key?: string;
    use_webhook?: boolean;
};

/**
 * Parsed data model for a torrent title.
 */
export type ParsedData = {
    raw_title: string;
    parsed_title?: string;
    normalized_title?: string;
    trash?: boolean;
    adult?: boolean;
    year?: (number | null);
    resolution?: string;
    seasons?: Array<(number)>;
    episodes?: Array<(number)>;
    complete?: boolean;
    volumes?: Array<(number)>;
    languages?: Array<(string)>;
    quality?: (string | null);
    hdr?: Array<(string)>;
    codec?: (string | null);
    audio?: Array<(string)>;
    channels?: Array<(string)>;
    dubbed?: boolean;
    subbed?: boolean;
    date?: (string | null);
    group?: (string | null);
    edition?: (string | null);
    bit_depth?: (string | null);
    bitrate?: (string | null);
    network?: (string | null);
    extended?: boolean;
    converted?: boolean;
    hardcoded?: boolean;
    region?: (string | null);
    ppv?: boolean;
    site?: (string | null);
    size?: (string | null);
    proper?: boolean;
    repack?: boolean;
    retail?: boolean;
    upscaled?: boolean;
    remastered?: boolean;
    unrated?: boolean;
    documentary?: boolean;
    episode_code?: (string | null);
    country?: (string | null);
    container?: (string | null);
    extension?: (string | null);
    extras?: Array<(string)>;
    torrent?: boolean;
    scene?: boolean;
};

export type PauseResponse = {
    message: string;
    ids: Array<(string)>;
};

export type PlexLibraryModel = {
    enabled?: boolean;
    token?: string;
    url?: string;
};

export type PlexWatchlistModel = {
    update_interval?: number;
    enabled?: boolean;
    rss?: Array<(string)>;
};

export type PostProcessing = {
    subliminal?: SubliminalConfig;
};

export type ProwlarrConfig = {
    enabled?: boolean;
    url?: string;
    api_key?: string;
    timeout?: number;
    ratelimit?: boolean;
    limiter_seconds?: number;
};

/**
 * Ranking configuration for quality attributes.
 */
export type QualityRankModel = {
    av1?: CustomRank;
    avc?: CustomRank;
    bluray?: CustomRank;
    dvd?: CustomRank;
    hdtv?: CustomRank;
    hevc?: CustomRank;
    mpeg?: CustomRank;
    remux?: CustomRank;
    vhs?: CustomRank;
    web?: CustomRank;
    webdl?: CustomRank;
    webmux?: CustomRank;
    xvid?: CustomRank;
};

export type RDUser = {
    id: number;
    username: string;
    email: string;
    /**
     * User's RD points
     */
    points: number;
    locale: string;
    /**
     * URL to the user's avatar
     */
    avatar: string;
    type: 'free' | 'premium';
    /**
     * Premium subscription left in seconds
     */
    premium: number;
};

export type type = 'free' | 'premium';

export type RTNSettingsModel = {
    /**
     * Identifier for the settings profile
     */
    profile?: string;
    /**
     * Patterns torrents must match to be considered
     */
    require?: Array<(string)>;
    /**
     * Patterns that, if matched, result in torrent exclusion
     */
    exclude?: Array<(string)>;
    /**
     * Patterns indicating preferred attributes in torrents
     */
    preferred?: Array<(string)>;
    /**
     * Configuration for enabled resolutions
     */
    resolutions?: ResolutionConfig;
    /**
     * General options for torrent filtering and ranking
     */
    options?: OptionsConfig;
    /**
     * Language preferences and restrictions
     */
    languages?: LanguagesConfig;
    /**
     * Custom ranking configurations for specific attributes
     */
    custom_ranks?: CustomRanksConfig;
};

export type RealDebridModel = {
    enabled?: boolean;
    api_key?: string;
};

export type RemoveResponse = {
    message: string;
    ids: Array<(string)>;
};

export type RepairSymlinksResponse = {
    message: string;
};

export type ResetResponse = {
    message: string;
    ids: Array<(string)>;
};

/**
 * Configuration for which resolutions are enabled.
 */
export type ResolutionConfig = {
    r2160p?: boolean;
    r1080p?: boolean;
    r720p?: boolean;
    r480p?: boolean;
    r360p?: boolean;
    unknown?: boolean;
};

export type RetryResponse = {
    message: string;
    ids: Array<(string)>;
};

/**
 * Ranking configuration for rips attributes.
 */
export type RipsRankModel = {
    bdrip?: CustomRank;
    brrip?: CustomRank;
    dvdrip?: CustomRank;
    hdrip?: CustomRank;
    ppvrip?: CustomRank;
    satrip?: CustomRank;
    tvrip?: CustomRank;
    uhdrip?: CustomRank;
    vhsrip?: CustomRank;
    webdlrip?: CustomRank;
    webrip?: CustomRank;
};

export type RootResponse = {
    message: string;
    version: string;
};

export type ScrapeItemResponse = {
    message: string;
    streams: {
        [key: string]: Stream;
    };
};

export type ScraperModel = {
    after_2?: number;
    after_5?: number;
    after_10?: number;
    parse_debug?: boolean;
    enable_aliases?: boolean;
    bucket_limit?: number;
    max_failed_attempts?: number;
    dubbed_anime_only?: boolean;
    torrentio?: TorrentioConfig;
    knightcrawler?: KnightcrawlerConfig;
    jackett?: JackettConfig;
    prowlarr?: ProwlarrConfig;
    orionoid?: OrionoidConfig;
    mediafusion?: MediafusionConfig;
    zilean?: ZileanConfig;
    comet?: CometConfig;
};

export type SelectFilesResponse = {
    message: string;
    download_type: 'cached' | 'uncached';
};

export type download_type = 'cached' | 'uncached';

export type SessionResponse = {
    message: string;
};

export type SetSettings = {
    key: string;
    value: unknown;
};

/**
 * Root model for show file data that maps seasons to episodes to file data.
 *
 * Example:
 * {
 * 1: {  # Season 1
 * 1: {"filename": "path/to/s01e01.mkv"},  # Episode 1
 * 2: {"filename": "path/to/s01e02.mkv"}   # Episode 2
 * },
 * 2: {  # Season 2
 * 1: {"filename": "path/to/s02e01.mkv"}   # Episode 1
 * }
 * }
 */
export type ShowFileData = {
    [key: string]: {
        [key: string]: DebridFile;
    };
};

export type StartSessionResponse = {
    message: string;
    session_id: string;
    torrent_id: string;
    torrent_info: TorrentInfo;
    containers: (TorrentContainer | null);
    expires_at: string;
};

export type StateResponse = {
    success: boolean;
    states: Array<(string)>;
};

export type States = 'Unknown' | 'Unreleased' | 'Ongoing' | 'Requested' | 'Indexed' | 'Scraped' | 'Downloaded' | 'Symlinked' | 'Completed' | 'PartiallyCompleted' | 'Failed' | 'Paused';

export type StatsResponse = {
    total_items: number;
    total_movies: number;
    total_shows: number;
    total_seasons: number;
    total_episodes: number;
    total_symlinks: number;
    incomplete_items: number;
    /**
     * Media item log string: number of retries
     */
    incomplete_retries: {
        [key: string]: (number);
    };
    states: {
        [key: string]: (number);
    };
};

export type Stream = {
    infohash: string;
    raw_title: string;
    parsed_title: string;
    parsed_data: ParsedData;
    rank: number;
    lev_ratio: number;
    is_cached: boolean;
};

export type SubliminalConfig = {
    enabled?: boolean;
    languages?: Array<(string)>;
    providers?: {
        [key: string]: unknown;
    };
};

export type SymlinkModel = {
    rclone_path?: string;
    library_path?: string;
    separate_anime_dirs?: boolean;
    repair_symlinks?: boolean;
    repair_interval?: number;
};

/**
 * Represents a collection of files from an infohash from a debrid service
 */
export type TorrentContainer = {
    infohash: string;
    files?: Array<DebridFile>;
};

/**
 * Torrent information from a debrid service
 */
export type TorrentInfo = {
    id: (number | string);
    name: string;
    status?: (string | null);
    infohash?: (string | null);
    progress?: (number | null);
    bytes?: (number | null);
    created_at?: (string | null);
    expires_at?: (string | null);
    completed_at?: (string | null);
    alternative_filename?: (string | null);
    files?: {
        [key: string]: {
            [key: string]: (number | string);
        };
    };
};

export type TorrentioConfig = {
    enabled?: boolean;
    filter?: string;
    url?: string;
    timeout?: number;
    /**
     * @deprecated
     */
    ratelimit?: boolean;
    proxy_url?: string;
};

export type TraktModel = {
    update_interval?: number;
    enabled?: boolean;
    api_key?: string;
    watchlist?: Array<(string)>;
    user_lists?: Array<(string)>;
    collection?: Array<(string)>;
    fetch_trending?: boolean;
    trending_count?: number;
    fetch_popular?: boolean;
    popular_count?: number;
    fetch_most_watched?: boolean;
    most_watched_period?: string;
    most_watched_count?: number;
    oauth?: TraktOauthModel;
};

export type TraktOAuthInitiateResponse = {
    auth_url: string;
};

export type TraktOauthModel = {
    oauth_client_id?: string;
    oauth_client_secret?: string;
    oauth_redirect_uri?: string;
    access_token?: string;
    refresh_token?: string;
};

/**
 * Ranking configuration for trash attributes.
 */
export type TrashRankModel = {
    cam?: CustomRank;
    clean_audio?: CustomRank;
    pdtv?: CustomRank;
    r5?: CustomRank;
    screener?: CustomRank;
    size?: CustomRank;
    telecine?: CustomRank;
    telesync?: CustomRank;
};

export type UpdateAttributesResponse = {
    message: string;
};

export type UpdateOngoingResponse = {
    message: string;
    updated_items: Array<{
        [key: string]: unknown;
    }>;
};

export type UpdatersModel = {
    updater_interval?: number;
    plex?: PlexLibraryModel;
    jellyfin?: JellyfinLibraryModel;
    emby?: EmbyLibraryModel;
};

export type UploadLogsResponse = {
    success: boolean;
    /**
     * URL to the uploaded log file. 50M Filesize limit. 180 day retention.
     */
    url: string;
};

export type ValidationError = {
    loc: Array<(string | number)>;
    msg: string;
    type: string;
};

export type ZileanConfig = {
    enabled?: boolean;
    url?: string;
    timeout?: number;
    /**
     * @deprecated
     */
    ratelimit?: boolean;
};

export type RootResponse2 = (RootResponse);

export type RootError = unknown;

export type HealthResponse = (MessageResponse);

export type HealthError = (unknown);

export type RdResponse = (RDUser);

export type RdError = (unknown);

export type GenerateapikeyResponse = (MessageResponse);

export type GenerateapikeyError = (unknown);

export type ServicesResponse = ({
    [key: string]: (boolean);
});

export type ServicesError = (unknown);

export type TraktOauthInitiateResponse = (TraktOAuthInitiateResponse);

export type TraktOauthInitiateError = (unknown);

export type TraktOauthCallbackData = {
    query: {
        code: string;
    };
};

export type TraktOauthCallbackResponse = (MessageResponse);

export type TraktOauthCallbackError = (unknown | HTTPValidationError);

export type StatsResponse2 = (StatsResponse);

export type StatsError = (unknown);

export type LogsResponse = (string);

export type LogsError = (unknown);

export type EventsResponse = ({
    [key: string]: Array<(string)>;
});

export type EventsError = (unknown);

export type MountResponse = ({
    [key: string]: (string);
});

export type MountError = (unknown);

export type UploadLogsResponse2 = (UploadLogsResponse);

export type UploadLogsError = (unknown);

export type OverseerrApiV1WebhookOverseerrPostResponse = ({
    [key: string]: unknown;
});

export type OverseerrApiV1WebhookOverseerrPostError = (unknown);

export type GetStatesResponse = (StateResponse);

export type GetStatesError = (unknown);

export type GetItemsData = {
    query?: {
        extended?: (boolean | null);
        is_anime?: (boolean | null);
        limit?: (number | null);
        page?: (number | null);
        search?: (string | null);
        sort?: ('date_desc' | 'date_asc' | 'title_asc' | 'title_desc' | null);
        states?: (string | null);
        type?: (string | null);
    };
};

export type GetItemsResponse = (ItemsResponse);

export type GetItemsError = (unknown | HTTPValidationError);

export type AddItemsData = {
    query?: {
        imdb_ids?: string;
    };
};

export type AddItemsResponse = (MessageResponse);

export type AddItemsError = (unknown | HTTPValidationError);

export type GetItemData = {
    path: {
        id: string;
    };
    query?: {
        use_tmdb_id?: (boolean | null);
    };
};

export type GetItemResponse = ({
    [key: string]: unknown;
});

export type GetItemError = (unknown | HTTPValidationError);

export type GetItemsByImdbIdsData = {
    path: {
        imdb_ids: string;
    };
};

export type GetItemsByImdbIdsResponse = (Array<{
    [key: string]: unknown;
}>);

export type GetItemsByImdbIdsError = (unknown | HTTPValidationError);

export type ResetItemsData = {
    query: {
        ids: string;
    };
};

export type ResetItemsResponse = (ResetResponse);

export type ResetItemsError = (unknown | HTTPValidationError);

export type RetryItemsData = {
    query: {
        ids: string;
    };
};

export type RetryItemsResponse = (RetryResponse);

export type RetryItemsError = (unknown | HTTPValidationError);

export type RetryLibraryItemsResponse = (RetryResponse);

export type RetryLibraryItemsError = (unknown);

export type UpdateOngoingItemsResponse = (UpdateOngoingResponse);

export type UpdateOngoingItemsError = (unknown);

export type RepairSymlinksData = {
    query?: {
        directory?: (string | null);
    };
};

export type RepairSymlinksResponse2 = (RepairSymlinksResponse);

export type RepairSymlinksError = (unknown | HTTPValidationError);

export type RemoveItemData = {
    query: {
        ids: string;
    };
};

export type RemoveItemResponse = (RemoveResponse);

export type RemoveItemError = (unknown | HTTPValidationError);

export type GetItemStreamsApiV1ItemsItemIdStreamsGetData = {
    path: {
        item_id: string;
    };
};

export type GetItemStreamsApiV1ItemsItemIdStreamsGetResponse = (unknown);

export type GetItemStreamsApiV1ItemsItemIdStreamsGetError = (unknown | HTTPValidationError);

export type BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostData = {
    path: {
        item_id: string;
        stream_id: number;
    };
};

export type BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostResponse = (unknown);

export type BlacklistStreamApiV1ItemsItemIdStreamsStreamIdBlacklistPostError = (unknown | HTTPValidationError);

export type UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostData = {
    path: {
        item_id: string;
        stream_id: number;
    };
};

export type UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostResponse = (unknown);

export type UnblacklistStreamApiV1ItemsItemIdStreamsStreamIdUnblacklistPostError = (unknown | HTTPValidationError);

export type ResetItemStreamsData = {
    path: {
        item_id: string;
    };
};

export type ResetItemStreamsResponse = (unknown);

export type ResetItemStreamsError = (unknown | HTTPValidationError);

export type PauseItemsData = {
    query: {
        ids: string;
    };
};

export type PauseItemsResponse = (PauseResponse);

export type PauseItemsError = (unknown | HTTPValidationError);

export type UnpauseItemsData = {
    query: {
        ids: string;
    };
};

export type UnpauseItemsResponse = (PauseResponse);

export type UnpauseItemsError = (unknown | HTTPValidationError);

export type ScrapeItemData = {
    path: {
        id: string;
    };
};

export type ScrapeItemResponse2 = (ScrapeItemResponse);

export type ScrapeItemError = (HTTPValidationError);

export type StartManualSessionData = {
    query: {
        item_id: string;
        magnet: string;
    };
};

export type StartManualSessionResponse = (StartSessionResponse);

export type StartManualSessionError = (HTTPValidationError);

export type ManualSelectData = {
    body: Container;
    path: {
        session_id: string;
    };
};

export type ManualSelectResponse = (SelectFilesResponse);

export type ManualSelectError = (HTTPValidationError);

export type ManualUpdateAttributesData = {
    body: (DebridFile | ShowFileData);
    path: {
        session_id: unknown;
    };
};

export type ManualUpdateAttributesResponse = (UpdateAttributesResponse);

export type ManualUpdateAttributesError = (HTTPValidationError);

export type AbortManualSessionApiV1ScrapeScrapeAbortSessionSessionIdPostData = {
    path: {
        session_id: string;
    };
};

export type AbortManualSessionApiV1ScrapeScrapeAbortSessionSessionIdPostResponse = (SessionResponse);

export type AbortManualSessionApiV1ScrapeScrapeAbortSessionSessionIdPostError = (HTTPValidationError);

export type CompleteManualSessionData = {
    path: {
        session_id: string;
    };
};

export type CompleteManualSessionResponse = (SessionResponse);

export type CompleteManualSessionError = (HTTPValidationError);

export type GetSettingsSchemaResponse = ({
    [key: string]: unknown;
});

export type GetSettingsSchemaError = (unknown);

export type LoadSettingsResponse = (MessageResponse);

export type LoadSettingsError = (unknown);

export type SaveSettingsResponse = (MessageResponse);

export type SaveSettingsError = (unknown);

export type GetAllSettingsResponse = (AppModel);

export type GetAllSettingsError = (unknown);

export type GetSettingsData = {
    path: {
        paths: string;
    };
};

export type GetSettingsResponse = ({
    [key: string]: unknown;
});

export type GetSettingsError = (unknown | HTTPValidationError);

export type SetAllSettingsData = {
    body: {
        [key: string]: unknown;
    };
};

export type SetAllSettingsResponse = (MessageResponse);

export type SetAllSettingsError = (unknown | HTTPValidationError);

export type SetSettingsData = {
    body: Array<SetSettings>;
};

export type SetSettingsResponse = (MessageResponse);

export type SetSettingsError = (unknown | HTTPValidationError);

export type GetEventTypesApiV1StreamEventTypesGetResponse = (unknown);

export type GetEventTypesApiV1StreamEventTypesGetError = (unknown);

export type StreamEventsApiV1StreamEventTypeGetData = {
    path: {
        event_type: string;
    };
};

export type StreamEventsApiV1StreamEventTypeGetResponse = (EventResponse);

export type StreamEventsApiV1StreamEventTypeGetError = (unknown | HTTPValidationError);